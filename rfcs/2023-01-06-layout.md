---
Start Date: 06-01-2023
RFC PR:
Blade Issue:
---

# Layout primitives and components

## Summary

This proposal outlines Blade's approach towards _the much requested_ layout primitives and components. It covers the proposed components, APIs along with prior art and alternatives considered.

### Background

In the React ecosystem, there are a plethora of ways to do layouts. With this design, our aim is to strike a fine balance between flexibility and constraints, so everything fits nicely with Blade's philosophy.

Since Blade is a [cross platform design system](https://portal.gitnation.org/contents/the-sorcery-of-building-a-cross-platform-design-system-architecture) that works in both React and React Native _(Learn Once, Write Anywhere)_; we've to make the layout strategy work within the constraints of both, for example - React Native doesn't _yet_ support flex [gap](https://github.com/facebook/yoga/pull/1116) [property](https://github.com/styled-components/styled-components/issues/3628) or CSS grid.

## Basic Example

With this proposal, we'll implement few primitives for handling layouts. Here are some pseudo code examples to explain how layout primitives / components can look in practice:

```tsx
import { Box, Button, Heading, Text } from '@razorpay/blade/components';

// adding spacing adjustments to entire container
<Box marginTop="spacing.1">
  <Button>Space on top</Button>
</Box>;

// adding space in between siblings
<Stack spacing="spacing.2">
  <Button>Need</Button>
  <Button>Some</Button>
  <Button>Space</Button>
</Stack>;

// components themselves can include layout properties
<Heading>Title</Heading>
<Text sx={{ marginTop: 'spacing.1' }}>Content</Text>
```

## Motivation

### Why

At the moment, we don't provide any primitives from Blade to help with composing multiple UI elements to build a larger layout. Consider a small example with two buttons aligned vertically and some spacing in between:

<div align="center">
<img src="./images/layout/layout-sample-ui.png" width="200" />
</div>

Here's one contrived way to implement this UI in current state:

```tsx
<div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
  <Button>Button 1</Button>
  <div style={{ marginTop: theme.spacing[2] }}>
    <Button>Button 2</Button>
  </div>
</div>
```

There can be multiple ways to implement this in practice, for example:

1. Instead of using `style`, `className` could be used by consumers preferring to keep CSS separate.
1. React Native consumers might be using `View` instead of `div` with [`StyleSheet`](https://reactnative.dev/docs/stylesheet) API.
1. Some may be using `styled-components` and instead of writing styles inline creating [wrapper components](https://styled-components.com/docs/basics#getting-started) like `FlexContainer`, `ButtonContainer` with `styled.div` API and applying the style attributes there.
1. Some may have a custom `Flex` component that accepts props such as `flexDirection`, `alignItems` or a custom `Box` component for applying spacing with a `marginTop` prop.

Considering the variety of ways this can be implemented, few things are quite cumbersome:

1. Need for a lot of wrapper components _(wrapocalypse)_ for spacing and alignment, which quickly grows out of hand as UI evolves. One can't add styling for layout directly on a Blade component because we don't support `className` or `style` prop, which makes wrappers a necessity even for small things.
1. No built-ins for responsive layouts, say you want more spacing on desktop and less on mobile
1. Need for manually hooking into the `theme` object for reaching into token values so the consumers can utilize them (eg. `theme.spacing[2]`).
1. Considering Blade is aimed at bridging cross platform gaps, you still need to write JSX with platform specific elements such as `div`, `View`.

#### `blade-old`

Historically, in `blade-old` _(deprecated)_ we followed an enhancer components based pattern which looked like below:

```tsx
<Space padding={[2.5, 0, 5, 0]}>
  <View>
    <Heading>Account Blocked</Heading>
  </View>
</Space>
```

This suffered from some related problems:

1. Need for creating nested wrapper components for everything for any adjustments - `Space`, `Size` and `View`
1. Readability wasn't as good because actual styles would get applied to the nested `View` which also made refactors harder
1. Slightly higher learning curve
1. No built-ins for responsive styles

### Proposed solution

With layout primitives in place, the above example could be implemented like:

```tsx
// one of the ways
<Flex flexDirection="column" alignItems="center">
  <Button>Button 1</Button>
  <Button sx={{ marginTop: 'spacing.2' }}>Button 2</Button>
</Flex>
```

Thus, layout primitives can ease up building UIs with:

1. Avoiding need for dedicatedly creating wrapper components for majority of usecases with ability to apply spacing directly on components with `sx`, having components such as `Stack`, `Spacer` for adding spacing between siblings or max flexibility with a `Box` component
1. Provide built-in capabilities for easing up responsive layouts with breakpoints based props such as `{ base: 'spacing.1', m: 'spacing.2' }`
1. No need to manually pass tokens for layout styling, the primitives will be able to derive actual value from tokens like `spacing.1`, `spacing.2`, etc.
1. Cross platform components such as `Box`, `Flex`, `Spacer` etc. that work for both React and React Native with the same API.

Indubitably, layouts have been one of the most requested feature by developers using Blade _([link](https://docs.google.com/document/d/14VAfBW7vz6hYOC1eWQO-_wOcECLU9UXRHVOSPC6OxZ8/edit#heading=h.zg0vxpo7xuc8) to internal document)_.

## Detailed Design

### Prior art

Every existing design system has tried to solved layouts bit differently. However, I've observed a few trends that seem to offer the best DX:

- A general purpose `Box` component along with helpful derivatives such as `Flex`, `Grid`, `Stack`, etc.
- Having support for theme aware styling props directly on components (such as `marginTop`, `paddingRight`, etc.)
- Reliance on having a `sx` prop for theme aware styling on components
- Built-in support for responsive styles on theme aware properties by either accepting an array / object format for values at different breakpoints
- Finally, some design systems also support a `style` or `className` prop on components for overrides and layouts for maximum flexibility

A brief study of some layout primitives is compiled below.

#### General purpose `Box` component

- [Chakra](https://chakra-ui.com/docs/components/box) - supports general purpose `Box` plus helpers such as [`Flex`](https://chakra-ui.com/docs/components/flex), [`Spacer`](https://chakra-ui.com/docs/components/flex/usage#using-the-spacer) [`Grid`](https://chakra-ui.com/docs/components/grid)
- [Polaris](https://polaris.shopify.com/components/box) - supports a general purpose `Box`
- [Reshaped](https://reshaped.so/content/docs/utilities/view) - supports a general purpose `View` component that supports style props, grid based layouts, responsive styles, gaps (spacing in between siblings)
- [MUI](https://mui.com/material-ui/react-box/)
- [Mantine](https://mantine.dev/core/box/) - along with helpers such as [`Flex`](https://mantine.dev/core/flex/), [`Space`](https://mantine.dev/core/space/)
- [Spectrum](https://react-spectrum.adobe.com/react-spectrum/View.html) - along with helpers for [`Flex`](https://react-spectrum.adobe.com/react-spectrum/Flex.html), [`Grid`](https://react-spectrum.adobe.com/react-spectrum/Grid.html)
- [Primer](https://primer.style/react/Box) - they deprecated `Flex` and `Grid` helpers
- [Styled system](https://styled-system.com/guides/build-a-box)
- [Nativebase](https://docs.nativebase.io/next/box) - along with helpers for [`Flex`](https://docs.nativebase.io/next/flex), [`Spacer`](https://docs.nativebase.io/next/flex#h3-using-the-spacer)

#### Style props

Theme aware style props to map the passed value to apt token in scale (for example `padding={4}` maps to 4th index in the spacing scale). Users may also pass values that don't exist in the scale such as `padding="7px"` in most such design systems.

- [Chakra](https://chakra-ui.com/docs/styled-system/style-props) - supports style props on all components with some helpful shorthands such as `mb`, `mx`, etc.
- [Reshaped](https://reshaped.so/content/docs/getting-started/react/core-concepts#values-and-tokens) - supported on some components such as `Card`, `View` (not all, eg. not supported on `Alert`).
- [Mantine](https://mantine.dev/styles/style-props/)
- [Spectrum](https://react-spectrum.adobe.com/react-spectrum/styling.html#style-props)
- [Primer](https://primer.style/react/system-props) - supported only on `Box` and `Text` components, recommends using `sx` prop on other components.
- [Nativebase](https://docs.nativebase.io/next/utility-first)

#### `sx` prop

Quite similar to style props. Seen in various design systems:

- [Chakra](https://chakra-ui.com/docs/styled-system/the-sx-prop) - recommended as an escape hatch when something is not supported by style props or for writing custom [theme aware CSS rules](https://chakra-ui.com/docs/styled-system/the-sx-prop#creating-nested-selectors), pseudo selectors
- [MUI](https://mui.com/material-ui/react-box/#the-sx-prop)
- [Primer](https://primer.style/react/overriding-styles) - with a nice [philosophical quote](https://primer.style/react/philosophy#assume-that-people-will-break-the-rules-provide-safe-ways-for-them-to-do-so)
- [Mantine](https://mantine.dev/styles/sx/)
- [Dripsy](https://www.dripsy.xyz/usage/overview) - along with a helper hook for [`useSx`](https://www.dripsy.xyz/apis/useSx)

#### Responsive styles

Generally there are built-ins to handle responsive styles by either accepting values as object or array such as `padding={{ sm: 2, md: 3 }}`.

- [Chakra](https://chakra-ui.com/docs/styled-system/responsive-styles) - supports both object and array formats
- [Reshaped](https://reshaped.so/content/docs/getting-started/react/core-concepts#responsive-properties) - supports object format with mobile first approach.
- [Spectrum](https://react-spectrum.adobe.com/react-spectrum/layout.html#responsive-layout)
- [Primer](https://primer.style/react/overriding-styles#responsive-values)

#### `Stack` component for spacing

- [Chakra](https://chakra-ui.com/docs/components/stack)
- [Mantine](https://mantine.dev/core/stack/)
- [MUI](https://mui.com/material-ui/react-stack/)
- [Polaris](https://polaris.shopify.com/components/stack)
- [Antd](https://ant.design/components/space) - utilizes a `Space` and `Space.Compact` component
- [Nativebase](https://docs.nativebase.io/next/stack)

#### `className` or `style` props

- [Reshaped](https://reshaped.so/content/docs/getting-started/react/core-concepts#classnames-and-attributes) - supports `className` on all components
- [Mantine](https://mantine.dev/styles/styles-api/)
- [Spectrum](https://react-spectrum.adobe.com/react-spectrum/styling.html#escape-hatches) - supports `UNSAFE` prefix props and recommends users to talk to the design system team if these are actually needed

#### Grid system

Few design systems support a grid system _(12 column, 24 column, etc.)_, although not as flexible it seems to work for applications strictly following grids from design.

- [Carbon](https://react.carbondesignsystem.com/?path=/docs/elements-grid--default)
- [Reshaped](https://reshaped.so/content/docs/utilities/view#multi-column-layout)
- [Polaris](https://polaris.shopify.com/components/grid)
- [Mantine](https://mantine.dev/core/grid/)
- [MUI](https://mui.com/material-ui/react-grid/)
- [Antd](https://ant.design/components/grid)
- [Bootstrap, the real OG](https://getbootstrap.com/docs/5.3/layout/grid/#how-it-works)

### Layout primitives and components for Blade

In order to provide a good balance of flexibility and constraints within blade we should support the theme aware components and primitives listed below.

#### `Box` component

A general purpose component for building layouts. This component will do a bulk of heavy lifting for composing layouts. Sample usage:

```tsx
<Box
  display="flex"
  flexDirection="column"
  alignItems="center"
  marginTop="spacing.1"
  marginBottom="spacing.2"
  paddingX="spacing.1"
  gap="spacing.1"
>
  <Button>Button 1</Button>
  <Button>Button 2</Button>
  <Button>Button 3</Button>
</Box>
```

Since blade is not a general purpose design system we should lean more towards constraints initially, assess usecases in the future and then increase flexibility. Proposed props for initial version:

| Category            | Props                                       | Notes                                                                                                                                |
| ------------------- | ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| Spacing             | `margin*`, `padding*`,                      | [List of props](https://github.com/styled-system/styled-system/blob/master/docs/table.md#space) referenced from styled-system.       |
| Layout              | `width*`, `height*`, `overflow*`, `display` | [List of props](https://github.com/styled-system/styled-system/blob/master/docs/table.md#layout) referenced from styled-system.      |
| Flexbox             | `flex*`, `align*`, `justify*`, `order`      | [List of props](https://github.com/styled-system/styled-system/blob/master/docs/table.md#flexbox) referenced from styled-system.     |
| Gap                 | `gap`, `rowGap`, `columnGap`                | Provides native flex functionality for spacing siblings.                                                                             |
| Position            | `position`, `zIndex`, `top`, etc.           | [List of props](https://github.com/styled-system/styled-system/blob/master/docs/table.md#position) referenced from styled-system.    |
| Grid **(web only)** | `grid*`                                     | [List of props](https://github.com/styled-system/styled-system/blob/master/docs/table.md#grid-layout) referenced from styled-system. |

**Spacing values**

We should intentionally keep the values of spacing based props restricted to spacing tokens i.e. `spacing.1`, `spacing.2`, etc. The tradeoff being, spacing tokens are capped (`spacing.11`) so it wouldn't be feasible for users to specify larger spacings (without updating spacing tokens in theme), in such cases they would've to rely on custom components or styling. Giving the flexibility to pass any value here can lead to inconsistencies where users may be passing values not in tokens (eg. `7px`) or passing the token value directly rather than using the actual token (eg. `2px` instead of `spacing.1`). We'll also rely on the full token name with `spacing` prefix i.e. `spacing.1`, `spacing.2`, etc. instead of `1`, `2`, etc. to avoid confusions _(does this `2` imply `2px` or `spacing.2`)_.

**Negative values**

There are some usecases where you may want to pass negative values (eg. negative margin values to create full-bleed layouts that break out of main content). In order to support this we would need spacing values to support negative tokens as well like `-spacing.1`, `-spacing.2`, etc. This might look bit unconventional compared to having `-1`, `-2`, etc. but that's a tradeoff we'll have to make in order to restrict values to `spacing.*` tokens.

Few points to note for React (web):

- We should avoid supporting shorthands to save from confusions _(should I use `mb` or `marginBottom`)_.
- Flex gap has ~91% global [coverage](https://caniuse.com/?search=flex%20gap) (support added in some browsers mid 2020). Although the support looks decent, this might be problematic for some products supporting these browsers. There is a [post CSS plugin](https://github.com/gavinmcfarland/flex-gap-polyfill) which can polyfill this _(with some known limitations)_. Alternative is to internally translate gap properties to utilize CSS selectors such as [lobotomized owl](https://alistapart.com/article/axiomatic-css-and-lobotomized-owls/) `* + *`.
- Going forward with native `gap` supports seems like a fine choice here in favor of keeping things simple and native. Tradeoff being, older browsers will be able to render the layout with a degraded experience _(without spacing)_.
- CSS grid has ~96% global [coverage](https://caniuse.com/?search=css%20grid). Although we can only natively support it on web, it's worth the investment since it can simplify building grid based layouts.

Few points to note for React Native:

- React Native currently doesn't support `gap` specific properties, however `gap` support is [now added](https://github.com/facebook/react-native-website/pull/3398) and planned for an upcoming [`0.71` release](https://github.com/reactwg/react-native-releases/discussions/41).
- Polyfilling this on native for older releases seems bit hacky _(with cloning and wrapping child elements)_ and unneeded because unlike browsers, all users can receive an updated React Native v0.71 app (once released), tradeoff being we will only be supporting `gap` based props in React Native going forward from `0.71`, so consumer apps should update their React Native version in order to consume these APIs.
- No support for grid props since it isn't supported natively.
- The TypeScript typings and autosuggestions should appropriately be adjusted for web and native to accommodate the differences, eg. grid properties, `inline-flex` display properties won't be supported. This can be done with [`moduleSuffixes`](https://www.typescriptlang.org/tsconfig#moduleSuffixes) detailed in the [related RFC](./writing-cross-platform-typescript.md).

We have an [internal Box component](../packages/blade/src/components/Box/) but it exposes lot more properties than the ones associated with layout. It seems like a good idea to have a different public `Box` component with the restrictive but fully covered layout properties from above table.

#### `Flex` component

A helper component over the `Box` component with `display` set as `Flex`. Arguably, this component seems unneeded without flex specific shorthand properties because the behavior can be achieved with a `display="flex"` prop on `Box`. Supports same properties.

#### `Grid` component

A helper **web only** component over the `Box` component with `display` set as `grid`. Similar to `Flex` component, it may be argued this component is unneeded with `display="grid"` set on `Box`. Supports same properties.

#### `Spacer` component

A helper component over the `Box` component primarily aimed at putting space in between components. Useful when the spacing is different between each sibling and can't be solved by gap based properties. Sample usage:

```tsx
<Box
  display="flex"
  flexDirection="column"
  alignItems="center"
  marginTop="spacing.1"
  marginBottom="spacing.2"
  paddingX="spacing.1"
>
  <Button>Button 1</Button>
  <Spacer size="spacing.1" />
  <Button>Button 2</Button>
  <Spacer size="spacing.2" />
  <Button>Button 3</Button>
</Box>
```

Supported properties:

| Prop   | Description                                                                       |
| ------ | --------------------------------------------------------------------------------- |
| `size` | Sets both height and width equally. If not provided sets the spacer to `flex: 1`. |

All properties are optional and accepts only spacing tokens.

#### Responsive styles

In order to ease up building responsive UIs all the style prop values will also support an alternate object based format that accepts breakpoints specific values, keeping mobile-first approach (`@media(min-width)`). Sample usage:

```tsx
<Box
  display="flex"
  flexDirection={{ base: 'column', l: 'row' }}
  alignItems="center"
  marginTop="spacing.1"
  marginBottom="spacing.2"
  paddingX="spacing.1"
  gap={{ base: 'spacing.1', m: 'spacing.2', l: 'spacing.3' }}
>
  <Button>Button 1</Button>
  <Button>Button 2</Button>
  <Button>Button 3</Button>
</Box>
```

The keys are derived from breakpoints tokens. An extra `base` key can be added as a helper to define values for breakpoints below the ones provided, for example `{ base: 'column', l: 'row' }` implies the value is `column` for all breakpoints less than `l`.

#### `sx` prop

All presentational components in Blade will support the `sx` prop. Layout components such as `Box`, `Flex`, `Grid`, `Stack` etc. will not support this prop, instead relying on the style props listed in the table above. The `sx` prop will support all properties (including responsive ones) that are supported by `Box` (listed in table above) in object format. The values will also be same as supported in `Box`. Sample usage:

```tsx
<Box
  display="flex"
  flexDirection="column"
  alignItems="center"
  marginTop="spacing.1"
  marginBottom="spacing.2"
  paddingX="spacing.1"
>
  <Button>Button 1</Button>
  <Button sx={{ marginTop: 'spacing.1' }}>Button 2</Button>
  <Button sx={{ marginTop: 'spacing.2' }}>Button 3</Button>
</Box>
```

`sx` prop will be the preferred choice for minor adjustments that can be done directly on the component without a need for creating extra `Box` wrapper _(which also keeps the DOM less nested)_. We won't have layout props support for presentational components. This also gives a nicer separation between other props and layout specific props. Later on, we might want to expand the scope of `sx` to cover things beyond layout if need arises.

As a tradeoff, `sx` prop is pretty dangerous in terms of the flexibility it provides. It gives power to customize any component to beyond recognition, for example you could customize the padding that comes on `Button`. In light of this capability we might want to consider alternatives.

Primer has an interesting take on this:

> Assume that people will break the rules, provide safe ways for them to do so
>
> - [Primer](https://primer.style/react/philosophy#assume-that-people-will-break-the-rules-provide-safe-ways-for-them-to-do-so)

#### Not doing, yet

- `className`, `style` prop
- Grid systems
- bleed layouts
- stack components (same as Flex)
- page level layouts (nav, header, sidebar, footer, etc.)

Blade is not a general purpose design system so we should lean more towards constraints initially, rather than giving total flexibility

_(all wider viewports will inherit largest provided breakpoint value)_

This is the bulk of the RFC. Explain the design in enough detail for somebody familiar with the Design System to understand, and for somebody familiar with the implementation to implement. This should get into specifics and corner-cases, and include examples of how the feature is used. Any new terminology should be defined here.

### Roadmap

Since layout components have a huge scope we should target to launch these progressively. This also gives us room to iterate based on feedback from consumers.

Here's a proposed timeline:

1.

## Drawbacks/Constraints

- Implementation cost, both in terms of code size and complexity.
- Go nuts with components `sx` et al

Why should we _not_ do this? Maybe try to consider the following constraints

- Implementation cost, both in terms of code size and complexity.
- The impact of it on new as well as existing consumer projects.
- Cost of migration.

There are tradeoffs to choosing any path. Attempt to identify them here.

## Alternatives

- Not doing this and let teams manage layout on their own (non ideal)
- More restrictive API (include primer quote, offer safe ways)

What other designs/patterns/strategies have been considered?

## Adoption strategy

- Announcement
- Storybook guideline doc for ramping up
- Progressive adoption, teams will adopt themselves since it improves DX and velocity with out of box primitives and components
- Non breaking change

If we implement this proposal, how will existing consumer projects adopt it?

- Is this a breaking change?
- Can we write a codemod?
- How do we prioritise this with business and product folks?
- How do we communicate with other teams? Will updating docs suffice or do we need a dedicated interaction with them?

## How do we educate people?

- Add a guideline doc in storybook which talks about layout strategy with some sample examples (covering all supported APIs with best practices), include this rfc for background reading
- TS docs and auto suggestions so people don't need to always refer documentation site

## Open Questions

- Custom values instead of just restricting to `spacing.1`, etc.
- `spacing.1`, `spacing.2` instead of `1`, `2`, etc.
- Custom props instead of having `sx`? `marginTop`, etc.
- `className` support? For people wishing to manage layouts separately via CSS. It will also make it possible to do `styled(Button)` to customize any component's styles
- css grid? No support in react native, maybe we don't have a dedicated Grid component but you can still make your box work as grid on web? Or have a web only grid because it makes grid based layouts quite easy on web, why be restricted with Flex.
- flex gap? No support in react native
- responsive properties
- `useSx` hook for custom components
- same api on React and React Native as much as possible (instead of div, view, etc. just box would be nice)
  - note that there isn't a 100% 1:1 mapping on UI from web to native, minor tweaks will always be needed because react native flex just mimicks tha flex implementation on web
- if someone is overriding the theme tokens then typings will be off (like it happened in website with chakra)
- figma to code? designers use the spacer at some places at other places devs will see the px value and using TS hints select the correct spacing value
- restricting properties for `sx` (only layout properties rather than all css properties)
- Do we need helper components like grid, flex, stack or just box works?
- Minor caveat of `sx`, people will pass object literals so it re-renders all the time, not a huge issue for now
- shorthands? https://chakra-ui.com/docs/styled-system/style-props
- responsive hiding https://reshaped.so/content/docs/utilities/view#hiding-items can use maybe display: { sm: 'hidden', 'md': 'block' } types
- only restricted props support added initially, not everything

## References

All references have been added inline. This RFC takes inspiration from a lot of existing design systems and UI libraries _standing on the shoulders of giants_:

- Chakra
- Reshaped
- Spectrum
- Primer
- Mantine
- MUI
- Polaris
- Styled system / Theme UI
- Dripsy
- Nativebase
- `blade-old`

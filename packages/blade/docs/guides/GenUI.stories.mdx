import { Meta } from '@storybook/addon-docs';

<Meta title="Guides/Generative UI" />

# Blade GenUI SDK

## Quick Start

```tsx
import { GenUIProvider, GenUISchemaRenderer } from './sdk';

function App() {
  const components = [
    // Note TEXT can have markdown content, the SDK will handle the rendering of markdown
    { component: 'TEXT', content: '# Hello World' },
    { component: 'BADGE', text: 'New', color: 'positive' },
  ];

  return (
    <GenUIProvider>
      <GenUISchemaRenderer components={components} />
    </GenUIProvider>
  );
}
```

## Built-in Components

**TEXT**  
Markdown text with Blade typography

**CHART**  
Bar, line, area, pie charts

**TABLE**  
Data table with typed cells

**CARD**  
Card container with header/footer

**BADGE**  
Status badge

**STACK**  
Vertical / horizontal flex layout

**GRID**  
CSS grid layout

**INFO_GROUP**  
Key-value pairs display

**BUTTON**  
Action button

**LINK**  
External link

**ALERT**  
Alert / notification box

**DIVIDER**  
Horizontal / vertical divider


## Defining Custom Components

```tsx
import { GenUIProvider, type CustomComponent } from './sdk';

// Step 1: Define the custom component
type MyWidgetComponentProps = CustomComponent<'MY_WIDGET', {
  title: string;
  value: number;
}>;

const MyComponent = ({ title, value }: MyWidgetComponentProps) => (
  <div>{title}: {value}</div>
);

// Step 2: Register it in the GenUIProvider
<GenUIProvider
  config={{
    components: {
      MY_WIDGET: { renderer: MyComponent },
    },
  }}
>
  // Step 3: Render the JSON which includes the custom component
  <GenUISchemaRenderer components={[{ component: 'MY_WIDGET', title: 'My Widget', value: 123 }]} />
</GenUIProvider>
```

## Handling Streaming in Custom Components

During streaming, components receive **partial/incomplete data** as the LLM generates JSON token-by-token. Your custom components must handle these gracefully to avoid runtime errors.

Let's take an example of a custom component that renders a metric card with a title, value, trend, and history.

**Summary:**
1. **Early return with skeleton** — Check required props, show loading state until data is complete
2. **Validate string values** — Partial strings like `"ac"` arrive before `"active"`
3. **Filter arrays** — Remove incomplete items before rendering lists
4. **Optional chaining** — Safe access for nested/optional properties
5. **Custom memo** — Prevent unnecessary re-renders during streaming

```tsx
type MetricCardProps = CustomComponent<'METRIC_CARD', {
  title?: string;
  value?: number;
  status?: 'positive' | 'negative' | 'notice' | 'neutral' | 'primary' | 'information';
  meta?: { updatedAt?: string; author?: string };
  text?: string;
  history?: Array<{ date?: string; value?: number }>;
}>;

const MetricCard = memo(
  ({ title, value, status, meta, color, history }: MetricCardProps) => {
    // Tip 1: Early return with skeleton for missing required props
    // During streaming, props arrive incrementally - show loading state until ready
    if (!title || value === undefined) {
      return <Skeleton width="200px" height="100px" />;
    }

    // Tip 2: Validate enum-like string values before using
    // During streaming "active" might arrive as: "ac" -> "act" -> "activ" ... -> "active"
    const validStatuses = ['active', 'inactive', 'pending'];
    const safeStatus = status && validStatuses.includes(status) ? status : undefined;

    // Tip 3: Filter incomplete items from arrays
    // Array items stream one-by-one and may have missing fields
    const validHistory = history?.filter(h => h.date && h.value !== undefined) ?? [];

    return (
      <Card>
        <Text>{title}</Text>
        <Amount value={value} />
        {safeStatus && <Indicator color={safeStatus} />}
        {validHistory.length > 0 && <Sparkline data={validHistory} />}
        {/* Tip 4: Use optional chaining for nested objects */}
        {meta?.updatedAt && <Text size="small">Updated: {meta.updatedAt}</Text>}
        {meta?.author && <Text size="small">Author: {meta.author}</Text>}
      </Card>
    );
  },
  // Tip 5: Custom memo comparison to reduce re-renders during streaming
  // Only re-render when data actually changes, not on every stream chunk
  // This is only required if data that is streamed is complex or nested
  (prevProps, nextProps) => {
    return (
      prevProps.status === nextProps.status &&
      prevProps.history?.length === nextProps.history?.length
    );
  }
);
```

## Action Handling

Handle button/alert actions via `onActionClick`:

Clicking on any built-in GenUI components like `BUTTON` and `ALERT`'s action buttons will trigger the `onActionClick` callback with the action data.

Built-in Click Action Schema:

```tsx
const ClickActionSchema = z.object({
  type: z.literal('CLICK'),
  data: z.object({
    message: z.string().describe('The message to be sent to the LLM when the button is clicked'),
  }),
}).describe('A natural language action to be performed when the button is clicked, this will be executed as a further query to LLM')
```

```jsx
<GenUIProvider
  onActionClick={(action) => {
    console.log(action.type, action.data);
    // TODO: Send another message to the LLM
    // send({ role: 'human', content: action.data.message })
    // -> 'Say hello' sent to LLM
  }}
>
  <GenUISchemaRenderer
    components={[
      {
        component: 'BUTTON',
        text: 'Click me',
        action: { type: 'CLICK', data: { message: 'Say hello' } },
      },
    ]}
  />
</GenUIProvider>
```

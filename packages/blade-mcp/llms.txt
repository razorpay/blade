# Blade Design System - Complete Documentation

> This file contains the complete documentation for the Blade Design System.
> It is auto-generated from the knowledgebase directory.
> Generated on: 2025-12-30T06:16:54.338Z

---

## Table of Contents

### General

- AvailableIcons
- ChartColorSystem
- index
- Usage
- WhiteLabelling

### Patterns

- Confirmation
- CreationView
- Dashboard
- DetailedView
- FormGroup
- index
- ListView
- Settings

### Components

- Accordion
- ActionList
- Alert
- Amount
- AnimateInteractions
- AreaChart
- AutoComplete
- Avatar
- Badge
- BarChart
- BottomNav
- BottomSheet
- Box
- Breadcrumb
- Button
- ButtonGroup
- Card
- Carousel
- ChatMessage
- Checkbox
- Chip
- Code
- Collapsible
- Counter
- CounterInput
- DatePicker
- Display
- Divider
- DonutChart
- Drawer
- Dropdown
- Elevate
- EmptyState
- Fade
- FileUpload
- Heading
- IconButton
- Icons
- Indicator
- InfoGroup
- InputGroup
- LineChart
- Link
- List
- ListView
- Menu
- Modal
- Morph
- Move
- OTPInput
- Pagination
- PasswordInput
- PhoneNumberInput
- Popover
- Preview
- ProgressBar
- QuickFilter
- Radio
- Scale
- SearchInput
- SelectInput
- SideNav
- Skeleton
- SkipNav
- Slide
- Spinner
- SpotlightPopoverTour
- Stagger
- StepGroup
- Switch
- Table
- Tabs
- Tag
- Text
- TextArea
- TextInput
- TimePicker
- Toast
- Tooltip
- TopNav
- VisuallyHidden

---

# GENERAL

> General documentation about Blade Design System setup, usage, and configuration.

---

## AvailableIcons

# Available Icons in Blade

## How to use Icons

All icons are exported from `@razorpay/blade/components`. They can be used in components that support IconComponent type. Or used as standalone components.

```tsx
import {
  Button,
  Badge,
  // Icons import
  AcceptPaymentsIcon,
  ArrowRightIcon,
} from '@razorpay/blade/components';

<>
  {/* Components with icon prop */}
  <Button icon={AcceptPaymentsIcon}>Button with Icon</Button>
  <Badge icon={AcceptPaymentsIcon}>Badge with Icon</Badge>
  {/* Icons as standalone components */}
  <ArrowRightIcon size="small" color="surface.icon.primary.normal" />
</>;
```

## Note

- If the icon is expected to be clickable, use `IconButton` component.
- If the icon clickable and looks like a link, use `<Link icon={IconName} href="" />`

## List of Available Icons

- AcceptPaymentsIcon
- ActivityIcon
- AddressBookIcon
- AffordabilityIcon
- AirplayIcon
- AlertCircleIcon
- AlertOctagonIcon
- AlertOnlyIcon
- AlertTriangleIcon
- AlignCenterIcon
- AlignJustifyIcon
- AlignLeftIcon
- AlignRightIcon
- AnchorIcon
- AndroidIcon
- AnnouncementIcon
- ApertureIcon
- AppStoreIcon
- AppleIcon
- ArrowDownIcon
- ArrowDownLeftIcon
- ArrowDownRightIcon
- ArrowLeftIcon
- ArrowRightIcon
- ArrowSquareDownIcon
- ArrowSquareDownLeftIcon
- ArrowSquareDownRightIcon
- ArrowSquareLeftIcon
- ArrowSquareRightIcon
- ArrowSquareUpIcon
- ArrowSquareUpLeftIcon
- ArrowSquareUpRightIcon
- ArrowUpIcon
- ArrowUpLeftIcon
- ArrowUpRightIcon
- AtSignIcon
- AttachmentIcon
- AutomateAccountingIcon
- AutomatePayrollIcon
- AwardIcon
- BankAccountVerificationIcon
- BankIcon
- BarChartAltIcon
- BarChartIcon
- BarCodeIcon
- Battery100PercentIcon
- Battery20PercentIcon
- Battery40PercentIcon
- Battery60PercentIcon
- Battery80PercentIcon
- BatteryChargingIcon
- BatteryIcon
- BellIcon
- BellOffIcon
- BfsiIcon
- BillIcon
- BillMeIcon
- BluetoothIcon
- BoldIcon
- BookIcon
- BookmarkIcon
- BoxIcon
- BriefcaseIcon
- BugIcon
- BuildingIcon
- BulkPayoutsIcon
- BusinessBankingIcon
- BusinessSpendManagementIcon
- CalendarIcon
- CameraIcon
- CameraOffIcon
- CashIcon
- CastIcon
- CheckCircle2Icon
- CheckCircleIcon
- CheckIcon
- CheckSquareIcon
- ChevronDownIcon
- ChevronLeftIcon
- ChevronRightIcon
- ChevronUpIcon
- ChevronsDownIcon
- ChevronsLeftIcon
- ChevronsRightIcon
- ChevronsUpIcon
- ChromeIcon
- CircleIcon
- ClipboardIcon
- ClockIcon
- CloseIcon
- ClosedCaptioningIcon
- CloudDrizzleIcon
- CloudIcon
- CloudLightningIcon
- CloudOffIcon
- CloudRainIcon
- CloudSnowIcon
- CodeSnippetIcon
- CodepenIcon
- CoinIcon
- CoinsIcon
- CommandIcon
- CompanyRegistrationIcon
- CompassIcon
- ConfettiIcon
- ContactlessPaymentIcon
- CookieIcon
- CopyIcon
- CopyrightIcon
- CornerDownLeftIcon
- CornerDownRightIcon
- CornerLeftDownIcon
- CornerLeftUpIcon
- CornerRightDownIcon
- CornerRightUpIcon
- CornerUpLeftIcon
- CornerUpRightIcon
- CpuIcon
- CreditCardIcon
- CreditsAndLoansIcon
- CropIcon
- CrosshairIcon
- CurrentAccountIcon
- CustomersIcon
- CutIcon
- DashboardIcon
- DeleteIcon
- DigitalLendingIcon
- DisbursePaymentsIcon
- DiscIcon
- DollarIcon
- DollarsIcon
- DotIcon
- DownloadCloudIcon
- DownloadIcon
- DragHandleIcon
- DropletIcon
- EcommerceIcon
- EditComposeIcon
- EditIcon
- EditInlineIcon
- EducationIcon
- EngageIcon
- EqualsIcon
- EscrowAccountIcon
- ExportIcon
- ExternalLinkIcon
- EyeIcon
- EyeOffIcon
- FacebookIcon
- FastForwardIcon
- FeatherIcon
- FigmaIcon
- FileIcon
- FileMinusIcon
- FilePlusIcon
- FileTextIcon
- FileZipIcon
- FilmIcon
- FilterIcon
- FlagIcon
- FlaskIcon
- FolderIcon
- ForexManagementIcon
- FreelanceIcon
- FullScreenEnterIcon
- FullScreenExitIcon
- GithubIcon
- GitlabIcon
- GlobeIcon
- GridIcon
- HashIcon
- HeadphoneIcon
- HeadphonesIcon
- HeadsetIcon
- HeartIcon
- HelpCircleIcon
- HistoryIcon
- HomeIcon
- ImageIcon
- InboxIcon
- IndiaFlagIcon
- InfoIcon
- InstagramIcon
- InstantSettlementIcon
- InternationalPaymentsIcon
- InvoicesIcon
- ItalicIcon
- KeyIcon
- KeyboardIcon
- LayersIcon
- LayoutIcon
- LeftCircularCornerIcon
- LifeBuoyIcon
- LinkIcon
- ListIcon
- ListSearchIcon
- LoaderIcon
- LoansForBusinessesIcon
- LockIcon
- LogInIcon
- LogOutIcon
- MagicCheckoutIcon
- MagicKonnectIcon
- MailIcon
- MailOpenIcon
- MapIcon
- MapPinIcon
- MaximizeIcon
- MenuDotsIcon
- MenuIcon
- MessageCircleIcon
- MessageSquareIcon
- MicIcon
- MicOffIcon
- MinimizeIcon
- MinusCircleIcon
- MinusIcon
- MinusSquareIcon
- MobileAppIcon
- MonitorIcon
- MoonIcon
- MoreHorizontalIcon
- MoreIcon
- MoreVerticalIcon
- MoveIcon
- MusicIcon
- MyAccountIcon
- NavigationIcon
- NoSignalIcon
- OctagonIcon
- OffersIcon
- OptimizerIcon
- PackageIcon
- PaperclipIcon
- PauseCircleIcon
- PauseIcon
- PaymentButtonIcon
- PaymentButtonsIcon
- PaymentGatewayIcon
- PaymentLinkIcon
- PaymentLinksIcon
- PaymentPagesIcon
- PayoutLinkIcon
- PayrollAddonsIcon
- PayrollForCaIcon
- PayrollForStartupOrSmeIcon
- PercentIcon
- PettyCashBudgetIcon
- PhoneCallIcon
- PhoneForwardedIcon
- PhoneIcon
- PhoneIncomingIcon
- PhoneMissedIcon
- PhoneOffIcon
- PhoneOutgoingIcon
- PictureInPictureIcon
- PieChartIcon
- PinIcon
- PlayCircleIcon
- PlayIcon
- PlusCircleIcon
- PlusIcon
- PlusSquareIcon
- PocketIcon
- PosIcon
- PowerIcon
- PrinterIcon
- PromptIcon
- QRCodeIcon
- RadioIcon
- RayIcon
- RazorpayIcon
- RazorpayXIcon
- RazorpayxPayrollIcon
- RefreshIcon
- RepeatIcon
- ReportsIcon
- ResizerIcon
- RewindIcon
- RotateClockWiseIcon
- RotateCounterClockWiseIcon
- RouteIcon
- RoutesIcon
- RupeeIcon
- RupeesIcon
- SaasIcon
- SaveIcon
- ScissorsIcon
- SearchIcon
- SendIcon
- ServerIcon
- SettingsIcon
- SettlementsIcon
- ShareIcon
- ShieldIcon
- ShoppingBagIcon
- ShoppingCartIcon
- ShuffleIcon
- SidebarIcon
- Signal1BarIcon
- Signal2BarIcon
- Signal3BarIcon
- Signal4BarIcon
- SignalIcon
- SimCardIcon
- SkipBackIcon
- SkipForwardIcon
- SlackIcon
- SlashIcon
- SlidersIcon
- SmartCollectIcon
- SmartphoneIcon
- SolutionsIcon
- SortIcon
- SourceToPayIcon
- SparklesIcon
- SpeakerIcon
- SquareIcon
- StampIcon
- StarIcon
- StopCircleIcon
- StorefrontIcon
- SubscriptionsIcon
- SunIcon
- SunriseIcon
- SunsetIcon
- TabletIcon
- TagIcon
- TargetIcon
- TaxPaymentsIcon
- TestIcon
- ThermometerIcon
- ThumbsDownIcon
- ThumbsUpIcon
- TicketIcon
- ToggleLeftIcon
- ToggleRightIcon
- TokenHqIcon
- TopLeftRoundedCornerIcon
- TopLeftSharpCornerIcon
- TrademarkIcon
- TrademarkRegisteredIcon
- TransactionsIcon
- TranslateIcon
- TrashIcon
- TrendingDownIcon
- TrendingUpIcon
- TriangleIcon
- TvIcon
- TwitterIcon
- TypeIcon
- UmbrellaIcon
- UnderlineIcon
- UnlockIcon
- UpiAutopayIcon
- UpiIcon
- UploadCloudIcon
- UploadIcon
- UserCheckIcon
- UserIcon
- UserMinusIcon
- UserPlusIcon
- UserXIcon
- UsersIcon
- VendorPaymentsIcon
- VideoIcon
- VideoOffIcon
- ViewLiveDemoIcon
- VoicemailIcon
- VolumeHighIcon
- VolumeIcon
- VolumeLowIcon
- VolumeMuteIcon
- WalletIcon
- WatchIcon
- WifiIcon
- WifiOffIcon
- WindIcon
- WorldwideIcon
- XCircleIcon
- XSquareIcon
- YoutubeIcon
- ZapIcon
- ZoomInIcon
- ZoomOutIcon

---

## ChartColorSystem

# Chart Color Tokens

## Overview

Blade's chart components use a sophisticated color theming system that automatically assigns colors to data series based on chart type, data indicators, and predefined color sequences. The system provides consistent, accessible colors across all chart types with automatic color assignment and different intensity levels for optimal visual hierarchy.

## Color System Architecture

### Color Categories

Blade supports 9 color categories for charts:

- **blue** - Primary blue
- **green** - Success/positive green  
- **red** - Error/negative red
- **orange** - Warning orange
- **skyBlue** - Light blue variant
- **purple** - Purple accent
- **pink** - Pink accent
- **gold** - Gold/yellow accent
- **gray** - Neutral gray

### Color Intensities

Each color category supports 5 intensity levels:

- **faint** - Lightest intensity
- **subtle** - Light intensity  
- **moderate** - Medium intensity
- **intense** - High intensity
- **strong** - Highest intensity

## Color Sequences

### Base Color Sequence

The primary color sequence used across all charts (in priority order):

1. blue
2. green
3. gold
4. purple
5. orange
6. pink
7. skyBlue
8. red
9. gray

### Intensity Sequences by Chart Type

**Bar Charts & Donut Charts:**
- Default sequence: faint â†’ strong
- `['faint', 'subtle', 'moderate', 'intense', 'strong']`

**Line Charts & Area Charts:**
- Reverse sequence: strong â†’ faint
- `['strong', 'intense', 'moderate', 'subtle', 'faint']`

## Color Token Format

All chart colors follow this token format:

```
data.background.categorical.{colorName}.{intensity}
```

**Examples:**
- `data.background.categorical.blue.faint`
- `data.background.categorical.green.strong`  
- `data.background.categorical.purple.moderate`

## Special Cases

### Single Data Point
When a chart has only one data indicator (except donut charts), it automatically uses:
```
data.background.categorical.gray.moderate
```

### Donut Charts
Donut charts follow the same color sequence but use different intensity mapping logic for optimal visual distinction between segments.

## Color Generation Algorithm

1. For each intensity level in the sequence
2. For each color in the color sequence  
3. Generate a color token in the format: `data.background.categorical.{colorName}.{intensity}`

This creates a comprehensive palette ensuring:
- Consistent color assignment across chart types
- Optimal contrast and accessibility
- Visual hierarchy through intensity variations

## Usage Examples

### Basic Chart with Automatic Colors

```tsx
import { ChartBarWrapper, ChartBar, ChartXAxis, ChartYAxis } from '@razorpay/blade/components';

function MyChart() {
  const data = [
    { name: 'Jan', sales: 4000, profit: 2400 },
    { name: 'Feb', sales: 3000, profit: 1398 },
    { name: 'Mar', sales: 2000, profit: 9800 },
  ];

  return (
    <ChartBarWrapper data={data}>
      <ChartXAxis dataKey="name" />
      <ChartYAxis />
      <ChartBar dataKey="sales" name="Sales" />
      <ChartBar dataKey="profit" name="Profit" />
    </ChartBarWrapper>
  );
}
```

### Explicit Color Theme

```jsx
<ChartBarWrapper data={data} colorTheme="categorical">
  <ChartXAxis dataKey="name" />
  <ChartYAxis />
  <ChartBar dataKey="sales" name="Sales" />
  <ChartBar dataKey="profit" name="Profit" />
</ChartBarWrapper>
```

## Best Practices

1. **Let Blade Handle Color Assignment** - Don't manually assign colors unless you have specific branding requirements
2. **Use Appropriate Chart Types** - Different chart types are optimized for different data visualizations
3. **Consider Data Density** - For charts with many data series, the color system will cycle through the sequence

## Troubleshooting

- **Colors Not Appearing**: Ensure you're using the latest version of Blade and check that your chart data is properly formatted
- **Inconsistent Colors**: Blade automatically manages color consistency; avoid manually setting colors unless necessary
- **Single Data Point Issues**: Single data points automatically use gray color for visual clarity

## Future Enhancements

Future versions may include:
- Sequential color themes for data with inherent ordering
- Diverging color themes for data with meaningful center points
- Custom color palette support for brand-specific requirements

---

## index

# When to use General Documentation

General documentation contains fundamental guides and references for using Blade design system effectively.

## Usage

The Usage guide covers the core fundamentals of implementing Blade in your application. It includes setup instructions for `BladeProvider` and how to do initial setup of blade in your app.

## AvailableIcons

A reference of which all icons are available in the blade design system. This includes usage examples showing how to import icons, use them in components with icon props, and implement them as standalone components.

## WhiteLabelling

Documentation for customizing Blade's theme to match different brands using the `createTheme` function. This guide explains how to create custom branded themes with your own brand colors while maintaining support for both light and dark color schemes. You don't need to follow this unless explicitly asked.

---

## Usage

import { Meta } from '@storybook/addon-docs';
import figmaComponent from '../images/figma-component.png';
import figmaToken from '../images/figma-token.png';

<Meta title="Guides/How to use?" />

# ðŸ‘€ How to use blade?

<br />
<br />

> Before starting to use Blade make sure you have followed the [installation guide](?path=/docs/guides-how-to-use--docs) and installed all the dependencies like `styled-components`, `fonts` etc.

<br />

## Wrap your App with `BladeProvider`

Make sure if `BladeProvider` is not already present in your app, add it to your app entry point.

In some cases, if section of the page is using dark theme while rest of the page is using light theme, you can wrap the section in `BladeProvider` with `colorScheme` set to `dark`. Although avoid unnecessary usage of BladeProvider when its not needed.

```jsx
// index.js
import App from './App';
import { BladeProvider } from '@razorpay/blade/components';
import { bladeTheme } from '@razorpay/blade/tokens';

function AppWrapper(): JSX.Element {
  return (
    <BladeProvider themeTokens={bladeTheme} colorScheme="light">
      <App />
    </BladeProvider>
  );
}

export default AppWrapper;
```

## Mapping Components from Figma to Blade in your code

Blade is built with **"What you see in Figma is what you get on Code" ** philosophy.

Whenever you get a UI mockup handed over by your designer select the component you want to build. for eg: let's say I want to implement the Export button component from the below mockup.

<img src={figmaComponent} alt="Figma mockup showing how to pick component and it's properties" />

So to know the blade component's name and properties

1. Select the component on Figma
2. Click on the `locator` icon that will take you to component's properties
3. Look at the component properties and copy it in code because the same properties exists on the components shipped.

```jsx
// in your file where you want to implement this
import { Button, DownloadIcon } from '@razorpay/blade/components';

<Button variant="secondary" size="medium" icon={DownloadIcon} iconPosition="left">
  Export
</Button>;
```

## Mapping Tokens from Figma to Blade in your code

> Tokens are an integral part of design system and are used to store design decisions behind a token(variable) name. That also make things easier to update without you making any change. For this reason **never hardcode** token values in your code but rather use the token name.

Everything that you see on Figma built using Blade you'll always find that in code as well.

Let's see how you can spot a token name from figma and write it in your code

<img src={figmaToken} alt="Figma mockup showing how to pick token" />

Whenever you get a UI mockup handed over by your designer

1. Select the component whose color token you want to use in code up
2. Click on the inspect panel on the left and click on the token name `surface.background.gray.moderate` to copy it and paste it into your code.
   > Remember, don't select the hardcoded `hsla` color value.

```jsx
const StyledCard = styled.div(
  ({ theme }: { theme: Theme }) => `
    width: 368px;
    background-color: ${theme.colors.surface.background.gray.moderate};
`,
);
```

---

## WhiteLabelling

# White Labelling - createTheme

You may want to use Blade with brands other than Razorpay.

To make this possible, Blade allows you to customize the theme of the components to match your brand with the `createTheme` function.

## API Reference

### `createTheme()`:

> Returns a `ThemeTokens` object that can be passed to `themeTokens` prop of `BladeProvider` to customize the branding of all components.

`createTheme()` accepts an object with the following keys:

#### `brandColor`:

- This is the primary color of your brand.
- `createTheme` will generate a color palatte using this brand color which will then be used across Blade components to match your brand.
- You can pass any valid CSS color value (rgb, hex or hsl) format to this key.

## Usage

If your application has multiple `BladeProvider` components, you can pass the `brandColor` to each of them to customize the branding of the components inside them.

```jsx
import { createTheme } from '@razorpay/blade/tokens';

const { theme: customThemeTokens } = createTheme({
  brandColor: '#83003D', // 'rgba(131, 0, 61)', 'hsl(332, 100%, 26%)' are also valid values
});

const Wrapper = () => {
  return (
    <BladeProvider themeTokens={customThemeTokens}>
      <App />
    </BladeProvider>
  );
};
```

### Light & Dark theme support

Custom branded themes also contain support for light and dark color schemes. You can pass the `colorScheme` prop to `BladeProvider` to switch between light and dark color schemes.

```jsx
// or colorScheme="light"
<BladeProvider themeTokens={customThemeTokens} colorScheme="dark">
  <App />
</BladeProvider>
```

---

# PATTERNS

> Design patterns and best practices for building UIs with Blade.

---

## Confirmation

## Confirmation

## Description
The Confirmation pattern provides a standardized way to seek user confirmation before proceeding with important or irreversible actions. It supports different emotional states (neutral, negative, positive) to match the action's impact and includes visual indicators through icons or images. This pattern is essential for actions that need explicit user acknowledgment, ensuring users understand the consequences of their actions.

## Components Used
- Modal
- BottomSheet
- Box
- Button
- Icons
- Typography (Text)

## Example

### Confirmation Dialog with Multiple States
This example demonstrates a comprehensive confirmation dialog that adapts between modal and bottom sheet based on device type. It uses the `ConformationalModalBody` component to maintain consistent layout and styling across different confirmation types.

```tsx 
import React from 'react';
import {
  Modal,
  ModalHeader,
  ModalBody,
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  Box,
  Button,
  Text,
  MapIcon,
  TrashIcon,
} from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';
import type { IconColors, IconComponent, BoxProps } from '@razorpay/blade/components';

// Types for our confirmation components
type ConfirmationType = 'neutral' | 'negative' | 'positive';

// ConformationalModalBody component
const ConformationalModalBody = ({
  type = 'neutral',
  icon: Icon,
  title,
  description,
  image,
}: {
  type: ConfirmationType;
  icon?: IconComponent;
  title: string;
  description: string;
  image?: string;
}): React.ReactNode => {
  const getIconColor = (): IconColors => {
    if (type === 'neutral') {
      return 'surface.icon.gray.subtle';
    }
    return 'feedback.icon.negative.intense';
  };

  const getBackgroundColor = (): BoxProps['backgroundColor'] => {
    if (type === 'neutral') {
      return 'feedback.background.neutral.subtle';
    }
    return 'feedback.background.negative.subtle';
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.5">
      {image ? (
        <Box
          paddingX="spacing.1"
          paddingY="10px"
          borderColor="surface.border.gray.muted"
          borderRadius="medium"
          width="48px"
          height="48px"
        >
          <img src={image} width={42} height={28} alt="logo" />
        </Box>
      ) : Icon ? (
        <Box
          backgroundColor={getBackgroundColor()}
          display="flex"
          justifyContent="center"
          alignItems="center"
          borderRadius="medium"
          padding="spacing.4"
          height="48px"
          width="48px"
        >
          <Icon color={getIconColor()} size="xlarge" />
        </Box>
      ) : null}
      <Box display="flex" flexDirection="column" gap="spacing.1">
        <Text size="large" weight="semibold">
          {title}
        </Text>
        <Text size="medium" weight="regular" color="surface.text.gray.muted">
          {description}
        </Text>
      </Box>
    </Box>
  );
};

// Reusable confirmation dialog component
const ConfirmationDialog: React.FC<{
  isOpen: boolean;
  onDismiss: () => void;
  type: ConfirmationType;
  icon?: IconComponent;
  image?: string;
  title: string;
  description: string;
  primaryButtonText: string;
  secondaryButtonText?: string;
  onConfirm: () => void;
  isLoading?: boolean;
}> = ({
  isOpen,
  onDismiss,
  type,
  icon,
  image,
  title,
  description,
  primaryButtonText,
  secondaryButtonText,
  onConfirm,
  isLoading,
}) => {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  const DialogContent = (
    <>
      <ConformationalModalBody
        type={type}
        icon={icon}
        title={title}
        description={description}
        image={image}
      />
      <Box
        display="flex"
        flexDirection={isMobile ? 'column' : 'row'}
        gap="spacing.5"
        justifyContent="flex-end"
        marginTop="spacing.6"
      >
        {secondaryButtonText && (
          <Button
            variant="tertiary"
            isFullWidth={isMobile}
            onClick={onDismiss}
            aria-describedby="confirmation-description"
          >
            {secondaryButtonText}
          </Button>
        )}
        <Button
          color={type === 'neutral' ? 'primary' : 'negative'}
          isFullWidth={isMobile}
          onClick={onConfirm}
          isLoading={isLoading}
          aria-describedby="confirmation-description"
        >
          {primaryButtonText}
        </Button>
      </Box>
    </>
  );

  if (isMobile) {
    return (
      <BottomSheet
        isOpen={isOpen}
        onDismiss={onDismiss}
        snapPoints={[0.4, 0.6, 0.8]}
        aria-labelledby="confirmation-title"
      >
        <BottomSheetHeader />
        <BottomSheetBody padding="spacing.5">{DialogContent}</BottomSheetBody>
      </BottomSheet>
    );
  }

  return (
    <Modal isOpen={isOpen} onDismiss={onDismiss} size="small" aria-labelledby="confirmation-title">
      <ModalHeader />
      <ModalBody padding="spacing.6">{DialogContent}</ModalBody>
    </Modal>
  );
};

// Usage Example
const ConfirmationExample: React.FC = () => {
  const [isDeleteOpen, setIsDeleteOpen] = React.useState(false);
  const [isDeleteLoading, setIsDeleteLoading] = React.useState(false);
  const [isSwitchOpen, setIsSwitchOpen] = React.useState(false);
  const [isTourOpen, setIsTourOpen] = React.useState(false);

  const handleDelete = async () => {
    setIsDeleteLoading(true);
    try {
      // Simulate API call
      await new Promise((resolve) => setTimeout(resolve, 1000));
      setIsDeleteOpen(false);
    } finally {
      setIsDeleteLoading(false);
    }
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.4">
      <Button
        color="negative"
        onClick={() => setIsDeleteOpen(true)}
        icon={TrashIcon}
        iconPosition="left"
      >
        Delete Account
      </Button>
      <ConfirmationDialog
        isOpen={isDeleteOpen}
        onDismiss={() => setIsDeleteOpen(false)}
        type="negative"
        icon={TrashIcon}
        title="Delete Account?"
        description="This action cannot be undone. All of your data will be permanently deleted. This includes your profile, settings, and all associated information."
        primaryButtonText="Delete Account"
        secondaryButtonText="Cancel"
        onConfirm={handleDelete}
        isLoading={isDeleteLoading}
      />

      <Button onClick={() => setIsSwitchOpen(true)}>Switch Platform</Button>
      <ConfirmationDialog
        isOpen={isSwitchOpen}
        onDismiss={() => setIsSwitchOpen(false)}
        type="neutral"
        image="https://logo.svgcdn.com/d/woocommerce-plain-wordmark.svg"
        title="Switch to WooCommerce?"
        description="Switching platforms will reset your current settings. Your existing data will be preserved but you'll need to reconfigure your platform-specific settings."
        primaryButtonText="Switch Platform"
        secondaryButtonText="Stay Here"
        onConfirm={() => setIsSwitchOpen(false)}
      />

      <Button onClick={() => setIsTourOpen(true)} icon={MapIcon} iconPosition="left">
        Start Product Tour
      </Button>
      <ConfirmationDialog
        isOpen={isTourOpen}
        onDismiss={() => setIsTourOpen(false)}
        type="positive"
        icon={MapIcon}
        title="Start Product Tour?"
        description="Take a guided tour of our platform's key features. Learn how to make the most of our tools and improve your workflow."
        primaryButtonText="Start Tour"
        secondaryButtonText="Maybe Later"
        onConfirm={() => setIsTourOpen(false)}
      />
    </Box>
  );
};

export default ConfirmationExample;
```

This example showcases:
- Usage of `ConformationalModalBody` component for consistent confirmation dialogs
- Support for different confirmation types (neutral, negative, positive) with appropriate styling
- Both icon and image-based confirmations
- Loading states for async operations
- Responsive design that adapts between modal and bottom sheet
- Proper accessibility implementation with ARIA labels
- Consistent button placement and styling
- Clear visual hierarchy with title and description

---

## CreationView

# CreationView

## Pattern Name

CreationView

## Description

CreationView is a pattern used in creation flows to guide users through the process of creating new entities like QR codes, GRNs, or other business objects. It provides a structured approach with form inputs, validation, preview capabilities, and step-by-step guidance. The pattern adapts to different screen sizes, using modals on desktop and full-screen overlays on mobile, ensuring optimal user experience across devices.

## Components Used

- Modal
- BottomSheet
- Box
- Button
- RadioGroup
- Radio
- TextInput
- TextArea
- Alert
- Preview
- StepGroup
- Table
- DatePicker
- Card
- Badge
- Heading
- Text
- Divider
- ProgressBar
- ChipGroup
- Chip

## Example

### Single Step Creation Flow with Form and Preview

This example demonstrates a simple creation flow with form inputs and real-time preview functionality.

```tsx
import React from 'react';
import {
  Box,
  Button,
  RadioGroup,
  Radio,
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter,
  Preview,
  PreviewHeader,
  PreviewBody,
  PreviewFooter,
  Heading,
  Alert,
  TextInput,
  Text,
} from '@razorpay/blade/components';

function SingleStepCreationView() {
  const [isOpen, setIsOpen] = React.useState(false);
  const [formData, setFormData] = React.useState({
    qrUsage: '',
    acceptFixedAmount: '',
    description: '',
  });
  const [errors, setErrors] = React.useState<Record<string, string>>({});
  const [alert, setAlert] = React.useState<{
    type: 'positive' | 'negative';
    title: string;
    description: string;
  } | null>(null);
  const [isQrGenerated, setIsQrGenerated] = React.useState(false);

  const handleChange = (name: string, value: string | undefined): void => {
    setFormData((prev) => ({ ...prev, [name]: value ?? '' }));
    if (errors[name]) setErrors((prev) => ({ ...prev, [name]: '' }));
  };

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.qrUsage) {
      newErrors.qrUsage = 'Please select QR usage type';
    }

    if (!formData.acceptFixedAmount) {
      newErrors.acceptFixedAmount = 'Please select if you want to accept fixed amount';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e?: React.FormEvent<HTMLFormElement>): void => {
    e?.preventDefault();
    if (validateForm()) {
      setAlert({
        type: 'positive',
        title: 'Success!',
        description: 'Your QR code has been created successfully.',
      });
      setIsQrGenerated(true);
    } else {
      setAlert({
        type: 'negative',
        title: 'QR Generation Failed',
        description: 'Please fill all the fields correctly',
      });
      setIsQrGenerated(false);
    }
  };

  const renderContent = (): React.ReactElement => (
    <Box display="flex" gap="spacing.4" justifyContent="space-between">
      <Box>
        <form onSubmit={handleSubmit}>
          <Box padding="spacing.4" display="flex" flexDirection="column" gap="spacing.4">
            <Box>
              <Heading size="medium" weight="regular">
                Configure your QR code settings
              </Heading>
            </Box>

            {alert && (
              <Alert
                color={alert.type}
                title={alert.title}
                description={alert.description}
                emphasis="subtle"
                isDismissible
                onDismiss={() => setAlert(null)}
                isFullWidth
              />
            )}

            <Box display="flex" flexDirection="column" gap="spacing.4">
              <RadioGroup
                label="QR Usage"
                name="qrUsage"
                value={formData.qrUsage}
                onChange={({ value }) => handleChange('qrUsage', value)}
                validationState={errors.qrUsage ? 'error' : 'none'}
                errorText={errors.qrUsage}
              >
                <Radio value="single">Single Payment</Radio>
                <Radio value="multiple">Multiple Payments</Radio>
              </RadioGroup>

              <RadioGroup
                label="Accept Fixed Amount"
                name="acceptFixedAmount"
                value={formData.acceptFixedAmount}
                onChange={({ value }) => handleChange('acceptFixedAmount', value)}
                validationState={errors.acceptFixedAmount ? 'error' : 'none'}
                errorText={errors.acceptFixedAmount}
              >
                <Radio value="yes">Yes</Radio>
                <Radio value="no">No</Radio>
              </RadioGroup>

              <TextInput
                label="Description"
                name="description"
                value={formData.description}
                onChange={({ value }) => handleChange('description', value)}
                placeholder="Enter description (optional)"
                helpText="Add a description to identify this QR code"
              />

              <Button isFullWidth type="submit" iconPosition="right">
                Create QR Code
              </Button>
            </Box>
          </Box>
        </form>
      </Box>
      <Box width="500px">
        <Preview>
          <PreviewHeader />
          <PreviewBody>
            {isQrGenerated ? (
              <Box>
                <img
                  src="https://blog.razorpay.in/blog-content/uploads/2021/11/QR-codes-blog-header.png"
                  alt="QR Code"
                  height="400px"
                />
              </Box>
            ) : (
              <Box>
                <Text>QR Code Preview</Text>
              </Box>
            )}
          </PreviewBody>
          <PreviewFooter />
        </Preview>
      </Box>
    </Box>
  );

  const renderFooter = (): React.ReactElement => (
    <Box display="flex" flexDirection="column" gap="spacing.3" width="100%">
      <Box display="flex" gap="spacing.3" justifyContent="space-between" width="100%">
        <Box display="flex" width="100%" justifyContent="flex-end" gap="spacing.3">
          <Button variant="tertiary" onClick={() => setIsOpen(false)}>
            Cancel
          </Button>
        </Box>
      </Box>
    </Box>
  );

  return (
    <Box>
      <Button onClick={() => setIsOpen(!isOpen)}>Create QR Code</Button>
      <Modal isOpen={isOpen} onDismiss={() => setIsOpen(false)} size="large">
        <ModalHeader title="Create QR Code" />
        <ModalBody>{renderContent()}</ModalBody>
        <ModalFooter>{renderFooter()}</ModalFooter>
      </Modal>
    </Box>
  );
}

export default SingleStepCreationView;
```

### Multi-Step Creation Flow with Responsive Design

This example shows a comprehensive multi-step creation flow that adapts to mobile and desktop screens with step navigation, validation, and preview capabilities.

```tsx
import React from 'react';
import dayjs from 'dayjs';
import styled from 'styled-components';
import { useTheme, useBreakpoint } from '@razorpay/blade/utils';
import {
  Box,
  Button,
  RadioGroup,
  Radio,
  Modal,
  ModalHeader,
  ModalBody,
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  Preview,
  PreviewHeader,
  PreviewBody,
  PreviewFooter,
  Heading,
  Alert,
  TextInput,
  TextArea,
  Text,
  StepGroup,
  StepItem,
  StepItemIcon,
  Card,
  CardBody,
  Badge,
  Table,
  TableHeader,
  TableHeaderRow,
  TableHeaderCell,
  TableBody,
  TableRow,
  TableCell,
  TableFooter,
  TableFooterRow,
  TableFooterCell,
  DatePicker,
  Divider,
  ProgressBar,
  Slide,
  Fade,
  CheckIcon,
  FileIcon,
  LockIcon,
  InfoIcon,
  MailIcon,
  PhoneIcon,
  CalendarIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from '@razorpay/blade/components';

const steps = [
  { title: 'Select Vendor', description: 'Choose a vendor for the GRN', stepNumber: 1 },
  { title: 'Link PO', description: 'Link Purchase Order to GRN', stepNumber: 2 },
  { title: 'GRN Details', description: 'Add GRN details and notes', stepNumber: 3 },
  { title: 'Line Item Details', description: 'Add line items and quantities', stepNumber: 4 },
  { title: 'Review GRN Details', description: 'Review and confirm GRN details', stepNumber: 5 },
];

const vendors = [
  {
    id: '1',
    name: 'ABC Suppliers',
    email: 'contact@abcsuppliers.com',
    phone: '+91 9876543210',
    address: '123 Business Park, Mumbai',
  },
  {
    id: '2',
    name: 'XYZ Trading Co.',
    email: 'info@xyztrading.com',
    phone: '+91 9876543211',
    address: '456 Corporate Hub, Delhi',
  },
];

const purchaseOrders = [
  {
    id: 'PO-001',
    number: 'PO-2024-001',
    date: '2024-03-15',
    amount: 15000,
    status: 'Pending',
    items: 5,
    vendor: 'ABC Suppliers',
  },
  {
    id: 'PO-002',
    number: 'PO-2024-002',
    date: '2024-03-14',
    amount: 25000,
    status: 'Approved',
    items: 8,
    vendor: 'XYZ Trading Co.',
  },
];

const tableData = {
  nodes: [
    { id: '1', name: 'Laptop Dell XPS 13', quantity: 2, unitPrice: 85000 },
    { id: '2', name: 'Wireless Mouse', quantity: 5, unitPrice: 1200 },
    { id: '3', name: 'Mechanical Keyboard', quantity: 3, unitPrice: 4500 },
  ],
};

function MultiStepCreationView({
  withProgressBar = false,
  modalSize = 'full',
}: {
  withProgressBar?: boolean;
  modalSize?: 'small' | 'medium' | 'large' | 'full';
}) {
  const [isOpen, setIsOpen] = React.useState(false);
  const [isPreviewOpen, setIsPreviewOpen] = React.useState(false);
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';
  const [currentStep, setCurrentStep] = React.useState(1);
  const [showStepGroup, setShowStepGroup] = React.useState(false);
  const [selectedVendor, setSelectedVendor] = React.useState<string | null>(null);
  const [selectedPO, setSelectedPO] = React.useState<string | null>(null);
  const [completedSteps, setCompletedSteps] = React.useState<number[]>([]);
  const [isDatePickerOpen, setIsDatePickerOpen] = React.useState<boolean>(false);
  const [errors, setErrors] = React.useState<{
    vendor?: string;
    purchaseOrder?: string;
    grnDetails?: string;
    date?: string;
  }>({});
  const [grnDetails, setGrnDetails] = React.useState({
    grnNumber: `GRN-${new Date().getFullYear()}-${Math.floor(Math.random() * 1000)
      .toString()
      .padStart(3, '0')}`,
    date: '',
    notes: '',
  });
  const [alert, setAlert] = React.useState<{
    type: 'positive' | 'negative';
    title: string;
    description: string;
  } | null>(null);

  const onStepGroupChange = (): void => {
    setAlert(null);
    setErrors({});
  };

  const handleStepClick = (stepNumber: number): void => {
    // Allow clicking on any previous step or the current step
    if (stepNumber <= currentStep) {
      setCurrentStep(stepNumber);
    }
    setShowStepGroup(false);
    onStepGroupChange();
  };

  const validateStep = (step: number): boolean => {
    const newErrors: typeof errors = {};

    if (step === 1 && !selectedVendor) {
      newErrors.vendor = 'Please select a vendor to proceed';
    }
    if (step === 2 && !selectedPO) {
      newErrors.purchaseOrder = 'Please select a purchase order to proceed';
    }

    if (step === 3) {
      if (!grnDetails.date) {
        newErrors.date = 'Date is required';
      } else {
        // Check date format and validity using dayjs
        const date = dayjs(grnDetails.date, 'YYYY-MM-DD', true);

        if (!date.isValid()) {
          newErrors.date = 'Please enter a valid date in YYYY-MM-DD format';
        } else {
          // Check if date is in the past
          const today = dayjs().startOf('day');
          if (date.isBefore(today)) {
            newErrors.date = 'Date cannot be in the past';
          }
        }
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleNextStep = (): void => {
    if (currentStep < steps.length) {
      if (validateStep(currentStep)) {
        setCompletedSteps((prev) => [...prev, currentStep]);
        setCurrentStep(currentStep + 1);
        if (currentStep === 3) {
          setAlert({
            type: 'positive',
            title: 'Success!',
            description: 'GRN details have been saved successfully.',
          });
        }
      } else if (currentStep === 3) {
        setAlert({
          type: 'negative',
          title: 'Validation Failed',
          description: 'Please fix the errors in the form and try again.',
        });
      }
    }
  };

  const handlePreviousStep = (): void => {
    if (currentStep > 1) {
      setCurrentStep(currentStep - 1);
      onStepGroupChange();
    }
  };

  const getStepIcon = (stepNumber: number): React.ReactElement => {
    if (alert?.type === 'negative' && stepNumber === currentStep) {
      return <StepItemIcon icon={InfoIcon} color="negative" />;
    }
    if (completedSteps.includes(stepNumber)) {
      return <StepItemIcon icon={CheckIcon} color="positive" />;
    }
    if (stepNumber === currentStep) {
      return <StepItemIcon icon={FileIcon} color="primary" />;
    }
    return <StepItemIcon icon={LockIcon} color="primary" />;
  };

  // Dynamically filter steps for mobile (remove review step)
  const visibleSteps = isMobile ? steps.filter((s) => s.stepNumber !== 5) : steps;
  const lastStep = visibleSteps[visibleSteps.length - 1].stepNumber;
  const currentStepObj = visibleSteps.find((s) => s.stepNumber === currentStep);

  const resetState = (): void => {
    setCurrentStep(1);
    setSelectedVendor(null);
    setSelectedPO(null);
    setCompletedSteps([]);
    setErrors({});
    setAlert(null);
    setGrnDetails({
      grnNumber: `GRN-${new Date().getFullYear()}-${Math.floor(Math.random() * 1000)
        .toString()
        .padStart(3, '0')}`,
      date: '',
      notes: '',
    });
  };

  const handleDateChange = (value: Date | undefined): void => {
    setGrnDetails((prev) => ({
      ...prev,
      date: value ? dayjs(value).format('YYYY-MM-DD') : '',
    }));
    if (errors.date) {
      setErrors((prev) => ({ ...prev, date: undefined }));
    }
  };

  const deskTopFooter = ({ isLastStep }: { isLastStep?: boolean }): React.ReactElement => {
    return (
      <Box
        display="flex"
        justifyContent="space-between"
        marginTop="spacing.4"
        padding="spacing.4"
        borderTopColor="surface.border.gray.muted"
      >
        <Button variant="tertiary" onClick={() => setIsOpen(!isOpen)}>
          Save and Close
        </Button>
        <Box display="flex" gap="spacing.4">
          <Button variant="tertiary" onClick={handlePreviousStep}>
            Previous
          </Button>
          <Button
            variant="primary"
            onClick={
              isLastStep
                ? () => {
                    resetState();
                    setIsOpen(false);
                  }
                : handleNextStep
            }
          >
            {isLastStep ? 'Submit' : 'Next'}
          </Button>
        </Box>
      </Box>
    );
  };

  // Move user from step 5 to step 4 when switching to mobile (mobile doesn't show review step)
  React.useEffect(() => {
    if (isMobile && currentStep === 5) {
      setCurrentStep(4);
    }
  }, [isMobile]);

  const RadioCard = ({
    value,
    label,
    children,
  }: {
    value: string;
    label: string;
    children?: React.ReactNode;
  }): React.ReactElement => {
    return (
      <Box display="flex" flexDirection="row" gap="spacing.3" alignItems="flex-start">
        <Radio value={value} />
        <Box display="flex" flexDirection="column" gap="spacing.3">
          <Box display="flex" flexDirection="row" gap="spacing.4">
            <Text weight="medium" color="surface.text.gray.subtle">
              {label}
            </Text>
          </Box>
          {children}
        </Box>
      </Box>
    );
  };

  const renderReviewContent = (): React.ReactElement => (
    <Box
      display="flex"
      flexDirection="column"
      gap="spacing.4"
      width="100%"
      height="100%"
      justifyContent="space-between"
    >
      <Box
        display="flex"
        flexDirection={isMobile ? 'column' : 'row'}
        padding="spacing.7"
        gap="spacing.4"
        width="100%"
        height="100%"
        justifyContent="space-between"
      >
        <Divider />
        <Box width="100%" height={isMobile ? '400px' : '600px'}>
          <Preview defaultZoom={0.5}>
            <PreviewHeader />
            <PreviewBody>
              <Box
                padding="spacing.4"
                display="flex"
                flexDirection="column"
                gap="spacing.6"
                backgroundColor="surface.background.gray.intense"
              >
                {/* GRN Details Section */}
                <Box
                  padding="spacing.4"
                  borderBottomWidth="thin"
                  borderBottomColor="surface.border.gray.muted"
                >
                  <Heading size="large">Goods Receipt Note</Heading>
                  <Text size="small" color="surface.text.gray.muted">
                    {grnDetails.grnNumber}
                  </Text>
                  <Text size="small" color="surface.text.gray.muted">
                    Date: {grnDetails.date}
                  </Text>
                </Box>
                {/* Vendor Details Section */}
                <Box>
                  <Heading size="medium">Vendor Details</Heading>
                  <Box
                    marginTop="spacing.3"
                    padding="spacing.4"
                    backgroundColor="surface.background.gray.intense"
                    borderRadius="medium"
                  >
                    {selectedVendor && (
                      <>
                        <Box display="flex" justifyContent="space-between">
                          <Box>
                            <Text weight="semibold" size="large">
                              {vendors.find((v) => v.id === selectedVendor)?.name}
                            </Text>
                            <Text size="small" color="surface.text.gray.muted">
                              {vendors.find((v) => v.id === selectedVendor)?.email}
                            </Text>
                          </Box>
                        </Box>
                        <Box
                          marginTop="spacing.3"
                          display="flex"
                          flexDirection="column"
                          gap="spacing.2"
                        >
                          <Text size="small">
                            Phone: {vendors.find((v) => v.id === selectedVendor)?.phone}
                          </Text>
                          <Text size="small">
                            Address: {vendors.find((v) => v.id === selectedVendor)?.address}
                          </Text>
                        </Box>
                      </>
                    )}
                  </Box>
                </Box>
                {/* PO Details Section */}
                <Box>
                  <Heading size="medium">Purchase Order Details</Heading>
                  <Box
                    marginTop="spacing.3"
                    padding="spacing.4"
                    backgroundColor="surface.background.gray.moderate"
                    borderRadius="medium"
                  >
                    {selectedPO && (
                      <>
                        <Box display="flex" justifyContent="space-between" alignItems="center">
                          <Box>
                            <Text weight="semibold" size="large">
                              {purchaseOrders.find((p) => p.id === selectedPO)?.number}
                            </Text>
                            <Text size="small" color="surface.text.gray.muted">
                              Date: {purchaseOrders.find((p) => p.id === selectedPO)?.date}
                            </Text>
                          </Box>
                          <Badge
                            size="medium"
                            color={
                              purchaseOrders.find((p) => p.id === selectedPO)?.status === 'Approved'
                                ? 'positive'
                                : 'notice'
                            }
                          >
                            {purchaseOrders.find((p) => p.id === selectedPO)?.status ?? ''}
                          </Badge>
                        </Box>
                      </>
                    )}
                  </Box>
                </Box>
                {/* Notes Section */}
                {grnDetails.notes && (
                  <Box>
                    <Heading size="medium">Notes</Heading>
                    <Box
                      marginTop="spacing.3"
                      padding="spacing.4"
                      backgroundColor="surface.background.gray.moderate"
                      borderRadius="medium"
                    >
                      <Text>{grnDetails.notes}</Text>
                    </Box>
                  </Box>
                )}
                {/* Line Items Section */}
                <Box>
                  <Heading size="medium">Line Items</Heading>
                  <Box marginTop="spacing.3">
                    <Table data={tableData}>
                      {(tableData) => (
                        <>
                          <TableHeader>
                            <TableHeaderRow>
                              <TableHeaderCell>Item Name</TableHeaderCell>
                              <TableHeaderCell>Quantity</TableHeaderCell>
                              <TableHeaderCell>Unit Price</TableHeaderCell>
                              <TableHeaderCell>Total Amount</TableHeaderCell>
                            </TableHeaderRow>
                          </TableHeader>
                          <TableBody>
                            {tableData.map((item) => (
                              <TableRow key={item.id} item={item}>
                                <TableCell>{item.name}</TableCell>
                                <TableCell>{item.quantity}</TableCell>
                                <TableCell>â‚¹{item.unitPrice.toLocaleString()}</TableCell>
                                <TableCell>
                                  â‚¹{(item.quantity * item.unitPrice).toLocaleString()}
                                </TableCell>
                              </TableRow>
                            ))}
                          </TableBody>
                          <TableFooter>
                            <TableFooterRow>
                              <TableFooterCell>Total Amount</TableFooterCell>
                              <TableFooterCell>-</TableFooterCell>
                              <TableFooterCell>-</TableFooterCell>
                              <TableFooterCell>
                                â‚¹
                                {tableData
                                  // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
                                  .reduce((sum, item) => sum + item.quantity * item.unitPrice, 0)
                                  .toLocaleString()}
                              </TableFooterCell>
                            </TableFooterRow>
                          </TableFooter>
                        </>
                      )}
                    </Table>
                  </Box>
                </Box>
              </Box>
            </PreviewBody>
            <PreviewFooter />
          </Preview>
        </Box>
      </Box>
      {!isMobile && deskTopFooter({ isLastStep: true })}
    </Box>
  );

  // In renderStepContent, do not show step 5 on mobile
  const renderStepContent = (isMobile: boolean): React.ReactElement | null => {
    if (isMobile && currentStep === 5) return null;
    switch (currentStep) {
      case 1:
        return (
          <Box
            display="flex"
            flexDirection="column"
            gap="spacing.4"
            width="100%"
            height="100%"
            justifyContent="space-between"
          >
            <Box
              display="flex"
              flexDirection="column"
              padding="spacing.7"
              justifyContent="center"
              alignItems="center"
            >
              <Box display="flex" flexDirection="column" gap="spacing.4">
                <Box>
                  <Heading size="medium">Select Vendor</Heading>
                  <Text>Choose a vendor from the list below to proceed with GRN creation.</Text>
                </Box>
                <Divider />
                <RadioGroup
                  label="Vendors"
                  name="vendor"
                  value={selectedVendor ?? ''}
                  onChange={({ value }) => {
                    setSelectedVendor(value);
                    if (errors.vendor) {
                      setErrors((prev) => ({ ...prev, vendor: undefined }));
                    }
                  }}
                  validationState={errors.vendor ? 'error' : 'none'}
                  errorText={errors.vendor}
                >
                  {vendors.map((vendor) => (
                    <Card
                      key={vendor.id}
                      padding="spacing.4"
                      borderRadius="medium"
                      elevation="none"
                      as="label"
                      accessibilityLabel={vendor.name}
                      marginBottom="spacing.2"
                    >
                      <CardBody>
                        <RadioCard value={vendor.id} label={vendor.name}>
                          <Box
                            display="flex"
                            gap="spacing.2"
                            flexDirection={isMobile ? 'column' : 'row'}
                          >
                            <Box display="flex" gap="spacing.2">
                              <MailIcon color="interactive.icon.gray.muted" />
                              <Text size="small" color="surface.text.gray.muted">
                                {vendor.email}
                              </Text>
                              {!isMobile && (
                                <Text size="small" color="surface.text.gray.muted">
                                  â€¢
                                </Text>
                              )}
                            </Box>
                            <Box display="flex" gap="spacing.2">
                              <PhoneIcon color="interactive.icon.gray.muted" />
                              <Text size="small" color="surface.text.gray.muted">
                                {vendor.phone}
                              </Text>
                            </Box>
                          </Box>
                        </RadioCard>
                      </CardBody>
                    </Card>
                  ))}
                </RadioGroup>
              </Box>
            </Box>
            {!isMobile && deskTopFooter({})}
          </Box>
        );
      case 2:
        return (
          <Box display="flex" width="100%" height="100%">
            <Box display="flex" flexDirection="column" width="100%" justifyContent="space-between">
              <Box display="flex" width="100%" justifyContent="space-between" height="100%">
                <Box
                  flex={6}
                  display="flex"
                  flexDirection="column"
                  height="100%"
                  justifyContent="space-between"
                  width="100%"
                >
                  <Box display="flex" alignItems="center" justifyContent="center" width="100%">
                    <Box padding="spacing.5" width="500px">
                      <Box display="flex" flexDirection="column" gap="spacing.2">
                        <Heading size="medium">Link PO</Heading>
                        <Text>Select a Purchase Order to link with this GRN.</Text>
                      </Box>

                      <Box flex={1} gap="spacing.2" marginTop="spacing.2">
                        <RadioGroup
                          label="Purchase Orders"
                          name="purchaseOrder"
                          value={selectedPO ?? ''}
                          onChange={({ value }) => {
                            setSelectedPO(value);
                            if (errors.purchaseOrder) {
                              setErrors((prev) => ({ ...prev, purchaseOrder: undefined }));
                            }
                          }}
                          validationState={errors.purchaseOrder ? 'error' : 'none'}
                          errorText={errors.purchaseOrder}
                        >
                          {purchaseOrders.map((po) => (
                            <Card
                              as="label"
                              accessibilityLabel={po.number}
                              isSelected={selectedPO === po.id}
                              marginBottom="spacing.2"
                              key={po.id}
                              elevation="none"
                            >
                              <CardBody>
                                <RadioCard value={po.id} label={po.number}>
                                  <Box display="flex" flexDirection="column" gap="spacing.2">
                                    <Box display="flex" gap="spacing.2" alignItems="center">
                                      <Text size="small" color="surface.text.gray.muted">
                                        {po.vendor}
                                      </Text>
                                      <Badge
                                        size="medium"
                                        color={po.status === 'Approved' ? 'positive' : 'notice'}
                                      >
                                        {po.status || ''}
                                      </Badge>
                                    </Box>
                                    <Box display="flex" gap="spacing.2">
                                      <Box display="flex" gap="spacing.2">
                                        <CalendarIcon color="interactive.icon.gray.muted" />
                                        <Text size="small" color="surface.text.gray.muted">
                                          {po.date}
                                        </Text>
                                      </Box>
                                      <Text size="small" color="surface.text.gray.muted">
                                        â€¢
                                      </Text>

                                      <Text size="small" color="surface.text.gray.muted">
                                        {po.items} Items
                                      </Text>
                                      <Text size="small" color="surface.text.gray.muted">
                                        â€¢
                                      </Text>
                                      <Text size="small" color="surface.text.gray.muted">
                                        â‚¹ {po.amount.toLocaleString()}
                                      </Text>
                                    </Box>
                                  </Box>
                                </RadioCard>
                              </CardBody>
                            </Card>
                          ))}
                        </RadioGroup>
                      </Box>
                    </Box>
                  </Box>
                </Box>
                {!isMobile && (
                  <Box flex={4}>
                    <Preview isDragAndZoomDisabled>
                      <PreviewBody>
                        <Box
                          padding="spacing.4"
                          display="flex"
                          flexDirection="column"
                          gap="spacing.4"
                          backgroundColor="surface.background.gray.moderate"
                        >
                          {selectedVendor && (
                            <>
                              <Box>
                                <Text weight="semibold" size="large">
                                  {vendors.find((v) => v.id === selectedVendor)?.name}
                                </Text>
                                <Text size="small" color="surface.text.gray.muted">
                                  {vendors.find((v) => v.id === selectedVendor)?.email}
                                </Text>
                              </Box>
                              <Box display="flex" flexDirection="column" gap="spacing.2">
                                <Text size="small">
                                  Phone: {vendors.find((v) => v.id === selectedVendor)?.phone}
                                </Text>
                                <Text size="small">
                                  Address: {vendors.find((v) => v.id === selectedVendor)?.address}
                                </Text>
                              </Box>
                            </>
                          )}
                          {selectedPO && (
                            <Box
                              marginTop="spacing.4"
                              paddingTop="spacing.4"
                              borderTopWidth="thin"
                              borderTopColor="surface.border.gray.muted"
                            >
                              <Text weight="semibold" size="medium">
                                Selected PO
                              </Text>
                              <Box marginTop="spacing.2">
                                <Text size="small">
                                  PO Number:{' '}
                                  {purchaseOrders.find((p) => p.id === selectedPO)?.number}
                                </Text>
                                <Text size="small">
                                  Amount: â‚¹
                                  {purchaseOrders
                                    .find((p) => p.id === selectedPO)
                                    ?.amount.toLocaleString()}
                                </Text>
                              </Box>
                            </Box>
                          )}
                        </Box>
                      </PreviewBody>
                    </Preview>
                  </Box>
                )}
              </Box>
              {!isMobile && deskTopFooter({})}
            </Box>
          </Box>
        );
      case 3:
        return (
          <Box
            display="flex"
            flexDirection="column"
            gap="spacing.4"
            width="100%"
            height="100%"
            justifyContent="space-between"
          >
            <Box padding="spacing.7" display="flex" flexDirection="column" gap="spacing.4">
              <Box>
                <Heading size="medium">GRN Details</Heading>
                <Text>Add additional details for this GRN.</Text>
              </Box>
              <Divider />
              {!isMobile && alert && (
                <Alert
                  color={alert.type}
                  title={alert.title}
                  description={alert.description}
                  emphasis="subtle"
                  isDismissible
                  onDismiss={() => setAlert(null)}
                  isFullWidth
                />
              )}
              <Box display="flex" flexDirection="column" gap="spacing.4">
                <TextInput
                  label="GRN Number"
                  name="grnNumber"
                  value={grnDetails.grnNumber}
                  onChange={({ value }) =>
                    setGrnDetails((prev) => ({ ...prev, grnNumber: value ?? '' }))
                  }
                  isDisabled
                  helpText="Auto-generated GRN number"
                />
                <DatePicker
                  label="Date"
                  name="date"
                  value={grnDetails.date ? dayjs(grnDetails.date).toDate() : undefined}
                  onApply={(value) => {
                    handleDateChange(value);
                  }}
                  onChange={(value) => {
                    handleDateChange(value);
                  }}
                  onOpenChange={() => {
                    setIsDatePickerOpen((prev) => !prev);
                  }}
                  validationState={errors.date ? 'error' : 'none'}
                  errorText={errors.date}
                  helpText="Select the GRN date"
                  isRequired
                  necessityIndicator="required"
                  minDate={new Date()} // Prevents selecting past dates
                />
                <TextArea
                  label="Notes"
                  name="notes"
                  value={grnDetails.notes}
                  onChange={({ value }) =>
                    setGrnDetails((prev) => ({ ...prev, notes: value ?? '' }))
                  }
                  numberOfLines={4}
                  placeholder="Add any additional notes or comments"
                />
              </Box>
            </Box>
            {!isMobile && deskTopFooter({})}
          </Box>
        );
      case 4:
        return (
          <Box
            display="flex"
            flexDirection="column"
            justifyContent="space-between"
            gap="spacing.4"
            height="100%"
          >
            <Box padding="spacing.7" display="flex" flexDirection="column" gap="spacing.4">
              <Box>
                <Heading size="medium">Line Item Details</Heading>
                <Text>Add line items and quantities for this GRN.</Text>
              </Box>
              <Divider />
              <Table data={tableData}>
                {(tableData) => (
                  <>
                    <TableHeader>
                      <TableHeaderRow>
                        <TableHeaderCell>Item Name</TableHeaderCell>
                        <TableHeaderCell>Quantity</TableHeaderCell>
                        <TableHeaderCell>Unit Price</TableHeaderCell>
                        <TableHeaderCell>Total Amount</TableHeaderCell>
                      </TableHeaderRow>
                    </TableHeader>
                    <TableBody>
                      {tableData.map((item) => (
                        <TableRow key={item.id} item={item}>
                          <TableCell>{item.name}</TableCell>
                          <TableCell>{item.quantity}</TableCell>
                          <TableCell>â‚¹{item.unitPrice.toLocaleString()}</TableCell>
                          <TableCell>
                            â‚¹{(item.quantity * item.unitPrice).toLocaleString()}
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                    <TableFooter>
                      <TableFooterRow>
                        <TableFooterCell>Total Amount</TableFooterCell>
                        <TableFooterCell>-</TableFooterCell>
                        <TableFooterCell>-</TableFooterCell>
                        <TableFooterCell>
                          â‚¹
                          {tableData
                            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
                            .reduce((sum, item) => sum + item.quantity * item.unitPrice, 0)
                            .toLocaleString()}
                        </TableFooterCell>
                      </TableFooterRow>
                    </TableFooter>
                  </>
                )}
              </Table>
            </Box>
            {!isMobile && deskTopFooter({})}
          </Box>
        );
      case 5:
        // Only show on desktop
        if (!isMobile) {
          return renderReviewContent();
        }
        return null;
      default:
        return null;
    }
  };
  const renderFooter = (): React.ReactElement => {
    const showPreview = isMobile && currentStep === lastStep;
    return (
      <Box
        display="flex"
        flexDirection="column"
        gap="spacing.4"
        padding="spacing.4"
        backgroundColor="surface.background.gray.subtle"
        borderTopWidth="thin"
        borderTopColor="surface.border.gray.muted"
        position="fixed"
        bottom="spacing.0"
        zIndex={1001}
        width="100%"
      >
        {isMobile && alert && (
          <Alert
            color={alert.type}
            title={alert.title}
            description={alert.description}
            emphasis="subtle"
            isDismissible
            onDismiss={() => setAlert(null)}
            isFullWidth
          />
        )}
        <Box display="flex" gap="spacing.4" justifyContent="space-between">
          <Box display="flex" gap="spacing.2">
            {showPreview && (
              <Button
                variant="tertiary"
                icon={FileIcon}
                onClick={() => setIsPreviewOpen(true)}
                iconPosition="left"
              >
                Preview
              </Button>
            )}
            <Button variant="tertiary" onClick={handlePreviousStep} isDisabled={currentStep === 1}>
              Previous
            </Button>
          </Box>
          <Button
            variant="primary"
            onClick={
              currentStep === lastStep
                ? () => {
                    resetState();
                    setIsOpen(false);
                  }
                : handleNextStep
            }
          >
            {currentStep === lastStep ? 'Submit' : 'Next'}
          </Button>
        </Box>
      </Box>
    );
  };

  const renderStepGroup = (): React.ReactElement => {
    return (
      <StepGroup orientation="vertical" size="medium">
        {visibleSteps.map((step) => (
          <StepItem
            key={step.stepNumber}
            title={step.title}
            description={step.description}
            titleColor={
              alert?.type === 'negative' && step.stepNumber === currentStep
                ? 'feedback.text.negative.intense'
                : undefined
            }
            marker={getStepIcon(step.stepNumber)}
            isSelected={alert?.type === 'negative' ? false : currentStep === step.stepNumber}
            isDisabled={step.stepNumber > currentStep}
            onClick={() => handleStepClick(step.stepNumber)}
            stepProgress={
              completedSteps.includes(step.stepNumber)
                ? 'full'
                : currentStep === step.stepNumber
                ? 'start'
                : 'none'
            }
          />
        ))}
      </StepGroup>
    );
  };

  const BackdropContainer = styled.div`
    position: fixed;
    width: 100%;
    height: 100%;
    background-color: ${({ theme }) => theme.colors.overlay.background.subtle};
    z-index: 1004;
  `;
  return (
    <Box>
      <Button onClick={() => setIsOpen(!isOpen)}>Create GNR Details</Button>
      {isMobile ? (
        isOpen && (
          <Box
            width="100%"
            minHeight="100%"
            backgroundColor="surface.background.gray.moderate"
            display="flex"
            flexDirection="column"
            position="fixed"
            top="spacing.0"
            left="spacing.0"
            zIndex={1000}
          >
            {/* Header with current step name */}
            <div
              role="button"
              tabIndex={0}
              onClick={() => {
                if (!withProgressBar) {
                  setShowStepGroup((prev: boolean) => !prev);
                }
              }}
              // eslint-disable-next-line @typescript-eslint/no-empty-function
              onKeyDown={() => {}}
              style={{
                zIndex: 1006,
              }}
            >
              <Box
                display="flex"
                alignItems="center"
                justifyContent="center"
                padding="spacing.4"
                backgroundColor="surface.background.gray.subtle"
                borderBottomWidth="thin"
                borderBottomColor="surface.border.gray.muted"
                position="relative"
              >
                <Box display="flex" alignItems="center" gap="spacing.4">
                  {alert?.type === 'negative' && (
                    <InfoIcon color="feedback.icon.negative.intense" />
                  )}
                  {withProgressBar ? (
                    <Heading
                      as="h2"
                      size="medium"
                      weight="semibold"
                      color="surface.text.gray.normal"
                      wordBreak="break-word"
                    >
                      New GRN
                    </Heading>
                  ) : (
                    <>
                      <Badge color={alert?.type === 'negative' ? 'negative' : undefined}>
                        {' '}
                        {currentStep} / {lastStep}{' '}
                      </Badge>
                      <Heading size="small">{currentStepObj?.title}</Heading>
                      {showStepGroup ? <ChevronUpIcon /> : <ChevronDownIcon />}
                    </>
                  )}
                </Box>
              </Box>
            </div>
            <ProgressBar
              value={(currentStep / lastStep) * 100}
              showPercentage={false}
              size="medium"
              color={alert?.type === 'negative' ? 'negative' : undefined}
            />

            <Box>
              <Slide
                direction="top"
                fromOffset="100%"
                motionTriggers={['mount']}
                isVisible={showStepGroup}
              >
                <Box
                  position="fixed"
                  top="51px"
                  left="spacing.0"
                  backgroundColor="surface.background.gray.intense"
                  zIndex={1005}
                  width="100%"
                  height="272px"
                  borderBottomLeftRadius="2xlarge"
                  borderBottomRightRadius="2xlarge"
                  padding="spacing.7"
                  paddingTop="spacing.0"
                >
                  {renderStepGroup()}
                </Box>
              </Slide>
              <Fade motionTriggers={['mount']} isVisible={showStepGroup} shouldUnmountWhenHidden>
                <BackdropContainer onClick={() => setShowStepGroup((prev: boolean) => !prev)} />
              </Fade>
            </Box>
            {/* Step content */}
            <Box
              overflow="auto"
              height="calc(100vh - 100px)"
              padding="spacing.4"
              paddingBottom="spacing.8"
            >
              {renderStepContent(isMobile)}
            </Box>
            {!isDatePickerOpen && !isPreviewOpen && renderFooter()}
            {/* Preview BottomSheet for mobile */}
            {isPreviewOpen && isMobile && (
              <BottomSheet
                isOpen={isPreviewOpen}
                onDismiss={() => setIsPreviewOpen(false)}
                snapPoints={[0.9, 0.9, 0.9]}
              >
                <BottomSheetHeader title="Review GRN Details" />
                <BottomSheetBody padding="spacing.0">{renderReviewContent()}</BottomSheetBody>
              </BottomSheet>
            )}
          </Box>
        )
      ) : (
        <Modal isOpen={isOpen} onDismiss={() => setIsOpen(false)} size={modalSize}>
          <ModalHeader title="New GRN" />
          {withProgressBar && (
            <ProgressBar
              value={(currentStep / lastStep) * 100}
              showPercentage={false}
              size="medium"
              color={alert?.type === 'negative' ? 'negative' : undefined}
            />
          )}
          <ModalBody height="100%" padding="spacing.0">
            <Box width="100%" height="100%" display="flex" flexDirection="column">
              <Box display="flex" flex={1}>
                {!withProgressBar && (
                  <Box
                    width="300px"
                    padding="spacing.7"
                    backgroundColor="surface.background.gray.moderate"
                  >
                    {renderStepGroup()}
                  </Box>
                )}

                <Box width="100%" display="flex" flexDirection="column">
                  <Box flex={1} overflow="auto">
                    {renderStepContent(isMobile)}
                  </Box>
                </Box>
              </Box>
            </Box>
          </ModalBody>
        </Modal>
      )}
    </Box>
  );
}

export default MultiStepCreationView;

// With StepGroup + full size modal
const MultiStepCreationViewStepGroup = () => {
  return <MultiStepCreationView />;
};

// With ProgressBar + full size modal
const MultiStepCreationViewProgressBar = () => {
  return <MultiStepCreationView withProgressBar />;
};

// With StepGroup + medium size modal
const MultiStepCreationViewMediumSizeModal = () => {
  return <MultiStepCreationView modalSize="medium" />;
};
```

### Edit and Add Modal Example

This example demonstrates a simple edit and add modal with responsive design that adapts to mobile and desktop screens.

```tsx
import React from 'react';
import {
  Box,
  Button,
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter,
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Text,
  TextInput,
} from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';

function ResponsiveModalWrapper({
  children,
  footer,
  isOpen,
  onDismiss,
  modalBodyPadding,
  modalSize = 'small',
  wrapInBottomSheetFooter = false,
  customSnapPoints = [0.35, 0.5, 0.85],
}: {
  children: React.ReactElement | React.ReactElement[];
  footer?: React.ReactElement;
  isOpen: boolean;
  onDismiss: () => void;
  modalBodyPadding?: 'spacing.0' | 'spacing.6' | undefined;
  modalSize?: 'small' | 'medium' | 'large' | 'full';
  wrapInBottomSheetFooter?: boolean;
  customSnapPoints?: [number, number, number];
}): React.ReactNode {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  if (isMobile) {
    return (
      <BottomSheet isOpen={isOpen} onDismiss={onDismiss} snapPoints={customSnapPoints}>
        <BottomSheetHeader />
        <BottomSheetBody padding="spacing.5">
          {children}
          {footer && !wrapInBottomSheetFooter && <Box marginTop="spacing.6">{footer}</Box>}
        </BottomSheetBody>
        {footer && wrapInBottomSheetFooter && <BottomSheetFooter>{footer}</BottomSheetFooter>}
      </BottomSheet>
    );
  }

  return (
    <Modal isOpen={isOpen} onDismiss={onDismiss} size={modalSize}>
      <ModalHeader />
      <ModalBody padding={modalBodyPadding}>{children}</ModalBody>
      {footer && <ModalFooter>{footer}</ModalFooter>}
    </Modal>
  );
}

function EditAndAddModal() {
  const [isOpen, setIsOpen] = React.useState(false);
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  return (
    <Box>
      <Button onClick={() => setIsOpen(true)}>Open Modal</Button>
      <ResponsiveModalWrapper
        isOpen={isOpen}
        onDismiss={() => setIsOpen(false)}
        footer={
          <Box display="flex" gap="spacing.5" justifyContent="flex-end" width="100%">
            <Button variant="tertiary" isFullWidth={isMobile}>
              Cancel
            </Button>
            <Button isFullWidth={isMobile}>Update</Button>
          </Box>
        }
      >
        <Box display="flex" flexDirection="column" gap="spacing.2">
          <Text size="large" weight="semibold">
            Edit display name
          </Text>
          <Text size="medium" weight="regular" color="surface.text.gray.muted">
            The new display name will reflect immediately on your dashboard after you update it. It
            will be visible to you and your team on the Razorpay dashboard.
          </Text>
        </Box>
        <Box marginTop="spacing.5">
          <TextInput label="Enter new display name" placeholder="Enter your display name" />
        </Box>
      </ResponsiveModalWrapper>
    </Box>
  );
}

export default EditAndAddModal;
```

### Flow Selection Modal Example

This example demonstrates how to create flow selection modals with varying card counts and corresponding modal sizes:.

```tsx
import React from 'react';
import {
  Box,
  Button,
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter,
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Card,
  CardBody,
  Text,
  Heading,
  ZapIcon,
} from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';

function ResponsiveModalWrapper({
  children,
  footer,
  isOpen,
  onDismiss,
  modalBodyPadding,
  modalSize = 'small',
  wrapInBottomSheetFooter = false,
  customSnapPoints = [0.35, 0.5, 0.85],
}: {
  children: React.ReactElement | React.ReactElement[];
  footer?: React.ReactElement;
  isOpen: boolean;
  onDismiss: () => void;
  modalBodyPadding?: 'spacing.0' | 'spacing.6' | undefined;
  modalSize?: 'small' | 'medium' | 'large' | 'full';
  wrapInBottomSheetFooter?: boolean;
  customSnapPoints?: [number, number, number];
}): React.ReactNode {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  if (isMobile) {
    return (
      <BottomSheet isOpen={isOpen} onDismiss={onDismiss} snapPoints={customSnapPoints}>
        <BottomSheetHeader />
        <BottomSheetBody padding="spacing.5">
          {children}
          {footer && !wrapInBottomSheetFooter && <Box marginTop="spacing.6">{footer}</Box>}
        </BottomSheetBody>
        {footer && wrapInBottomSheetFooter && <BottomSheetFooter>{footer}</BottomSheetFooter>}
      </BottomSheet>
    );
  }

  return (
    <Modal isOpen={isOpen} onDismiss={onDismiss} size={modalSize}>
      <ModalHeader />
      <ModalBody padding={modalBodyPadding}>{children}</ModalBody>
      {footer && <ModalFooter>{footer}</ModalFooter>}
    </Modal>
  );
}

function FlowSelectionModal({ cardCount = 3 }) {
  const [isOpen, setIsOpen] = React.useState(false);
  const [selectedMethod, setSelectedMethod] = React.useState('');

  // Dynamic modal size and grid layout based on card count
  const getModalSize = () => {
    if (cardCount === 2) return 'small';
    if (cardCount === 3) return 'medium';
    return 'large';
  };

  const getGridLayout = () => {
    if (cardCount === 2) return { base: '1fr 1fr', m: '1fr 1fr' };
    if (cardCount === 3) return { base: '1fr 1fr', m: '1fr 1fr 1fr' };
    return { base: '1fr 1fr', m: '1fr 1fr 1fr 1fr' };
  };

  const getCardWidth = () => {
    if (cardCount === 2) return isMobile ? '165px' : '160px';
    if (cardCount === 3) return isMobile ? '165px' : '230px';
    return isMobile ? '165px' : '220px';
  };

  const paymentMethods = [
    {
      value: 'quickpay',
      title: 'Quick Pay Button',
      subtitle:
        'Accepting fixed price payments? Customers make quick payments of fixed price through this button',
      icon: ZapIcon,
    },
    {
      value: 'buynow',
      title: 'Buy Now Button',
      subtitle:
        'Selling products or event tickets? Sell multiple items with support for quantity using this button.',
      icon: ZapIcon,
    },
    {
      value: 'custom',
      title: 'Custom Button',
      subtitle:
        'Build your own button with your own design and branding or use our pre-built templates.',
      icon: ZapIcon,
      isDisabled: true,
    },
  ].slice(0, cardCount); // Dynamic content based on cardCount

  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  return (
    <Box>
      <Button onClick={() => setIsOpen(true)}>Open Modal</Button>
      <ResponsiveModalWrapper
        isOpen={isOpen}
        onDismiss={() => setIsOpen(false)}
        modalSize={getModalSize()}
        footer={
          <Box display="flex" gap="spacing.5" justifyContent="flex-end" width="100%">
            <Button variant="tertiary" isFullWidth={isMobile} onClick={() => setIsOpen(false)}>
              Cancel
            </Button>
            <Button
              isDisabled={!selectedMethod}
              onClick={() => {
                console.log('Selected payment method:', selectedMethod);
                setIsOpen(false);
              }}
              isFullWidth={isMobile}
            >
              Proceed
            </Button>
          </Box>
        }
        modalBodyPadding="spacing.0"
        wrapInBottomSheetFooter
        customSnapPoints={[0.8, 0.9, 0.95]}
      >
        <Box
          paddingX="spacing.6"
          paddingTop="spacing.6"
          display="flex"
          flexDirection="column"
          gap="spacing.1"
        >
          <Heading size="small" weight="semibold">
            Pick a Button Type
          </Heading>
          <Text color="surface.text.gray.muted" size="small" weight="regular">
            Pick a button which meets your requirements and get a head start on collecting payments
            or you could build your own
          </Text>
        </Box>
        <Box padding="spacing.6">
          <Box
            display="grid"
            gridTemplateColumns={getGridLayout()}
            justifyItems="center"
            gap="spacing.5"
            width="100%"
          >
            {paymentMethods.map((method, index) => (
              <Card
                key={`${method.value}-${index}`}
                isSelected={selectedMethod === method.value}
                onClick={method.isDisabled ? undefined : () => setSelectedMethod(method.value)}
                padding="spacing.0"
                accessibilityLabel={`Select ${method.title}`}
                width={getCardWidth()}
                height={isMobile ? '184px' : undefined}
                borderRadius="medium"
                elevation="none"
                cursor={method.isDisabled ? 'not-allowed' : 'pointer'}
              >
                <CardBody>
                  <Box
                    display="flex"
                    justifyContent="center"
                    alignItems="center"
                    marginTop="spacing.6"
                    marginX="spacing.5"
                  >
                    <Box
                      padding="10px"
                      backgroundColor={
                        method.isDisabled
                          ? 'surface.background.gray.subtle'
                          : 'surface.background.primary.subtle'
                      }
                      width="40px"
                      height="40px"
                      display="flex"
                      justifyContent="center"
                      alignItems="center"
                      borderRadius="medium"
                    >
                      <method.icon
                        color={
                          method.isDisabled
                            ? 'surface.icon.gray.muted'
                            : 'surface.icon.primary.normal'
                        }
                        size="large"
                      />
                    </Box>
                  </Box>
                  <Box
                    display="flex"
                    flexDirection="row"
                    gap="spacing.4"
                    alignItems="center"
                    paddingX="spacing.5"
                    paddingY="spacing.4"
                  >
                    <Box
                      display="flex"
                      flexDirection="column"
                      justifyContent="center"
                      alignItems="center"
                      maxHeight="95px"
                      gap="spacing.2"
                    >
                      <Text
                        size="medium"
                        weight="semibold"
                        color={
                          method.isDisabled ? 'surface.text.gray.muted' : 'surface.text.gray.normal'
                        }
                      >
                        {method.title}
                      </Text>
                      <Text size="small" color="surface.text.gray.muted" textAlign="center">
                        {method.subtitle}
                      </Text>
                    </Box>
                  </Box>
                </CardBody>
              </Card>
            ))}
          </Box>
        </Box>
      </ResponsiveModalWrapper>
    </Box>
  );
}

export default FlowSelectionModal;

// 2 Cards - Small Modal
const FlowSelection2Cards = () => {
  return <FlowSelectionModal cardCount={2} />;
};

// 3 Cards - Medium Modal
const FlowSelection3Cards = () => {
  return <FlowSelectionModal cardCount={3} />;
};

// 4+ Cards - Large Modal
const FlowSelection4Cards = () => {
  return <FlowSelectionModal cardCount={4} />;
};
```

### Single Step Form Modal Example

This example demonstrates a single step form with chip groups and responsive layout.

```tsx
import React from 'react';
import {
  Box,
  Button,
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter,
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Text,
  Heading,
  ChipGroup,
  Chip,
  TextInput,
} from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';

function ResponsiveModalWrapper({
  children,
  footer,
  isOpen,
  onDismiss,
  modalBodyPadding,
  modalSize = 'small',
  wrapInBottomSheetFooter = false,
  customSnapPoints = [0.35, 0.5, 0.85],
}: {
  children: React.ReactElement | React.ReactElement[];
  footer?: React.ReactElement;
  isOpen: boolean;
  onDismiss: () => void;
  modalBodyPadding?: 'spacing.0' | 'spacing.6' | undefined;
  modalSize?: 'small' | 'medium' | 'large' | 'full';
  wrapInBottomSheetFooter?: boolean;
  customSnapPoints?: [number, number, number];
}): React.ReactNode {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  if (isMobile) {
    return (
      <BottomSheet isOpen={isOpen} onDismiss={onDismiss} snapPoints={customSnapPoints}>
        <BottomSheetHeader />
        <BottomSheetBody padding="spacing.0">
          {children}
          {footer && !wrapInBottomSheetFooter && <Box marginTop="spacing.6">{footer}</Box>}
        </BottomSheetBody>
        {footer && wrapInBottomSheetFooter && <BottomSheetFooter>{footer}</BottomSheetFooter>}
      </BottomSheet>
    );
  }

  return (
    <Modal isOpen={isOpen} onDismiss={onDismiss} size={modalSize}>
      <ModalHeader />
      <ModalBody padding={modalBodyPadding}>{children}</ModalBody>
      {footer && <ModalFooter>{footer}</ModalFooter>}
    </Modal>
  );
}

function SingleStepFormModal() {
  const [isOpen, setIsOpen] = React.useState(false);
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  const shippingTime = [
    { value: '1-2 days', label: '1-2 days' },
    { value: '3-5 days', label: '3-5 days' },
    { value: '6-8 days', label: '6-8 days' },
    { value: '9-15 days', label: '9-15 days' },
    { value: 'not applicable', label: 'Not Applicable' },
  ];

  return (
    <Box>
      <Button onClick={() => setIsOpen(true)}>Open Modal</Button>
      <ResponsiveModalWrapper
        isOpen={isOpen}
        onDismiss={() => setIsOpen(false)}
        modalSize="large"
        modalBodyPadding="spacing.0"
        customSnapPoints={[0.8, 0.9, 0.95]}
        wrapInBottomSheetFooter
        footer={
          isMobile ? (
            <Box display="flex" justifyContent="flex-end" gap="spacing.5">
              <Button variant="tertiary" isFullWidth={isMobile} onClick={() => setIsOpen(false)}>
                Back
              </Button>
              <Button variant="primary" isFullWidth={isMobile} onClick={() => setIsOpen(false)}>
                Continue
              </Button>
            </Box>
          ) : undefined
        }
      >
        <Box
          display="grid"
          gridTemplateColumns={isMobile ? '1fr' : 'auto 1fr'}
          gridTemplateRows={isMobile ? '1fr' : 'auto 1fr'}
          width="100%"
          height="100%"
        >
          {!isMobile && (
            <Box
              backgroundColor="surface.background.gray.subtle"
              height="596px"
              width="400px"
              display="flex"
              flexDirection="column"
              justifyContent="flex-end"
              overflow="hidden"
              gridRow="span 2"
            >
              <img src="side-image.png" height="596px" width="100%" alt="Side illustration" />
            </Box>
          )}
          <Box
            height="596px"
            paddingTop="spacing.6"
            width="100%"
            overflow="auto"
            display="flex"
            flexDirection="column"
            justifyContent="space-between"
          >
            <Box paddingX="spacing.6">
              <Heading size="medium" weight="semibold">
                Create policy pages with Razorpay
              </Heading>
              <Text size="medium" weight="regular" color="surface.text.gray.muted">
                We need a few details to create the missing policy pages for you
              </Text>
              <Box
                marginTop="spacing.6"
                display="flex"
                gap="spacing.7"
                flexDirection="column"
                height="100%"
                width="100%"
              >
                <ChipGroup label="Shipping time">
                  {shippingTime.map((time) => (
                    <Chip key={time.value} value={time.value}>
                      {time.label}
                    </Chip>
                  ))}
                </ChipGroup>
                <ChipGroup label="Cancellation request time">
                  {shippingTime.map((time) => (
                    <Chip key={time.value} value={time.value}>
                      {time.label}
                    </Chip>
                  ))}
                </ChipGroup>
                <ChipGroup label="Refund processing time">
                  {shippingTime.map((time) => (
                    <Chip key={time.value} value={time.value}>
                      {time.label}
                    </Chip>
                  ))}
                </ChipGroup>
                <TextInput label="Support contact number" prefix="+91" placeholder="9XXXXXXXXX" />
                <TextInput label="Support Email ID" placeholder="support@razorpay.com" />
              </Box>
            </Box>
            {!isMobile && (
              <Box>
                <ModalFooter>
                  <Box display="flex" justifyContent="flex-end" gap="spacing.5">
                    <Button variant="tertiary" onClick={() => setIsOpen(false)}>
                      Back
                    </Button>
                    <Button variant="primary" onClick={() => setIsOpen(false)}>
                      Continue
                    </Button>
                  </Box>
                </ModalFooter>
              </Box>
            )}
          </Box>
        </Box>
      </ResponsiveModalWrapper>
    </Box>
  );
}

export default SingleStepFormModal;
```

---

## Dashboard

# Dashboard Template

## Pattern Name

Dashboard Template

## Description

Dashboard Template is a full dashboard template with SideNav, TopNav and main workspace area. It also includes a navigation structure with sections and items implemented via react-router-dom.

## Components Used

- SideNav
- TopNav

Note: Main route entry points are inside `SideNavComponent` - If you need to add more routes, add them here.

## Example

```js
// file: navigation/NavItems.tsx
import React from 'react';
import { InfoIcon, LayoutIcon, LogInIcon } from '@razorpay/blade/components';

type NavItem = {
  icon: React.ComponentType;
  title: string;
  href: string;
  trailing?: React.ReactNode;
  items?: NavItem[];
};

type NavSection = {
  type: 'section';
  title?: string;
  maxItemsVisible: number;
  items: NavItem[];
};

export const navItemsJSON: NavSection[] = [
  {
    type: 'section',
    title: 'Layout Complexity',
    maxItemsVisible: 5,
    items: [
      {
        icon: LayoutIcon,
        title: 'Login (low)',
        href: '/app/layout-complexity/login',
      },
      {
        icon: LayoutIcon,
        title: 'Account Settings (medium)',
        href: '/app/layout-complexity/account-settings',
      },
      {
        icon: LayoutIcon,
        title: 'Insights (high)',
        href: '/app/layout-complexity/insights',
      },
    ],
  },
];


// file: navigation/TopNav.tsx
import React from 'react';
import styled from 'styled-components';
import { Link, useLocation, useNavigate } from 'react-router-dom';
import {
  Box,
  Text,
  Heading,
  TopNav,
  TopNavBrand,
  TopNavContent,
  TopNavActions,
  TabNav,
  TabNavItem,
  TabNavItems,
  Menu,
  MenuItem,
  MenuOverlay,
  MenuHeader,
  MenuFooter,
  Badge,
  useTheme,
  HomeIcon,
  Button,
  Link as BladeLink,
  SearchInput,
  Avatar,
  Tooltip,
  ActivityIcon,
  AnnouncementIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  RazorpayxPayrollIcon,
  AcceptPaymentsIcon,
  MagicCheckoutIcon,
  AwardIcon,
  RazorpayXIcon,
} from '@razorpay/blade/components';
import SideNav from './SideNav';
import { isItemActive, RazorpayLogo } from './utils';

interface TabNavItemLinkProps {
  href?: string;
  title: string;
  icon?: React.ComponentType<React.SVGProps<SVGSVGElement>>;
  activeOnLinks?: string[];
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [key: string]: any;
}

const TabNavItemLink = React.forwardRef<HTMLAnchorElement, TabNavItemLinkProps>((props, ref) => {
  const location = useLocation();
  return (
    <TabNavItem
      ref={ref}
      {...props}
      as={Link}
      isActive={isItemActive(location, {
        href: props.href,
        activeOnLinks: props.activeOnLinks,
      })}
    />
  );
});

TabNavItemLink.displayName = 'TabNavItemLink';

interface ExploreItemProps {
  icon: React.ComponentType<{ color: string; size: string }>;
  title: string;
  description: string;
}

const ExploreItem = ({ icon: Icon, title, description }: ExploreItemProps) => {
  return (
    <Box display="flex" gap="spacing.4">
      <Box
        borderRadius="medium"
        padding="spacing.5"
        backgroundColor="surface.background.gray.subtle"
      >
        <Icon color="interactive.icon.neutral.subtle" size="medium" />
      </Box>
      <Box>
        <Text color="surface.text.gray.subtle" size="medium" weight="semibold">
          {title}
        </Text>
        <Text size="small" color="surface.text.gray.muted">
          {description}
        </Text>
      </Box>
    </Box>
  );
};

const DashboardBackground = styled.div(() => {
  return {
    height: '100vh',
    background: 'radial-gradient(94.74% 64.44% at 29.03% 15.17%, #FFFFFF 0%, #90A5BB 100%)',
  };
});

const TopNavComponent = () => {
  const { platform } = useTheme();
  const navigate = useNavigate();
  const isMobile = platform === 'onMobile';
  const [isSideBarOpen, setIsSideBarOpen] = React.useState(false);
  const [selectedProduct, setSelectedProduct] = React.useState<string | null>(null);

  const activeUrl = useLocation().pathname;
  React.useEffect(() => {
    setSelectedProduct(activeUrl);
  }, [activeUrl]);

  return (
    <DashboardBackground>
      <TopNav position="relative">
        {isMobile ? (
          <>
            <BladeLink icon={HomeIcon} size="medium" href="/home">
              Home
            </BladeLink>
            <Heading textAlign="center" size="small" weight="semibold">
              Payments
            </Heading>
            <Menu openInteraction="click">
              <Avatar size="medium" name="Anurag Hazra" />
              <MenuOverlay>
                <MenuHeader title="Profile" />
                <Box display="flex" gap="spacing.4" padding="spacing.4" alignItems="center">
                  <Avatar size="medium" name="John Doe" />
                  <Box display="flex" flexDirection="column" gap="spacing.2">
                    <Text size="medium" weight="semibold">
                      John Doe
                    </Text>
                    <Text size="xsmall" color="surface.text.gray.muted">
                      Razorpay Trusted Merchant
                    </Text>
                  </Box>
                </Box>
                <MenuItem>
                  <Text color="surface.text.gray.subtle">Settings</Text>
                </MenuItem>
                <MenuItem color="negative">
                  <Text color="feedback.text.negative.intense">Logout</Text>
                </MenuItem>
              </MenuOverlay>
            </Menu>
          </>
        ) : (
          <>
            <TopNavBrand>
              <RazorpayLogo />
            </TopNavBrand>
            <TopNavContent>
              <TabNav
                items={[
                  {
                    href: '/app',
                    title: 'Payments',
                    icon: AcceptPaymentsIcon,
                    description: 'Manage payments effortlessly.',
                  },
                  {
                    href: '/banking',
                    title: 'Banking',
                    icon: RazorpayXIcon,
                    description: 'Manage your banking needs.',
                  },
                  {
                    href: '/payroll',
                    title: 'Payroll',
                    icon: RazorpayxPayrollIcon,
                    description: 'Automate payroll with ease.',
                  },
                  {
                    href: '/magic-checkout',
                    title: 'Magic Checkout',
                    icon: MagicCheckoutIcon,
                    isAlwaysOverflowing: true,
                    description: 'Fast, one-click checkout.',
                  },
                  {
                    href: '/rize',
                    title: 'Rize',
                    icon: AwardIcon,
                    isAlwaysOverflowing: true,
                    description: 'Boost your business growth.',
                  },
                ]}
              >
                {({ items, overflowingItems }) => {
                  const activeProduct = overflowingItems.find(
                    (item) => item.href === selectedProduct,
                  );
                  return (
                    <>
                      <TabNavItems>
                        {items.map((item) => {
                          return (
                            <TabNavItemLink
                              key={item.title}
                              title={item.title}
                              href={item.href}
                              icon={item.icon}
                            />
                          );
                        })}
                      </TabNavItems>
                      {overflowingItems.length > 0 ? (
                        <Menu openInteraction="hover">
                          <TabNavItem
                            title={activeProduct ? `More: ${activeProduct.title}` : 'More'}
                            trailing={<ChevronDownIcon />}
                            isActive={Boolean(activeProduct)}
                          />
                          <MenuOverlay>
                            <MenuHeader
                              title="Products for you"
                              trailing={
                                <Badge emphasis="subtle" color="notice">
                                  Recommended
                                </Badge>
                              }
                            />
                            {overflowingItems.map((item) => {
                              return (
                                <MenuItem
                                  key={item.href}
                                  onClick={() => {
                                    navigate(item.href);
                                    setSelectedProduct(item.href);
                                  }}
                                >
                                  <ExploreItem
                                    icon={item.icon}
                                    title={item.title}
                                    description={item.description}
                                  />
                                </MenuItem>
                              );
                            })}
                            <MenuFooter>
                              <BladeLink href="" icon={ChevronRightIcon} iconPosition="right">
                                View all products
                              </BladeLink>
                            </MenuFooter>
                          </MenuOverlay>
                        </Menu>
                      ) : null}
                    </>
                  );
                }}
              </TabNav>
            </TopNavContent>
            <TopNavActions>
              <SearchInput
                placeholder="Search in payments"
                accessibilityLabel="Search Across Razorpay"
              />
              <Tooltip content="View Ecosystem Health">
                <Button size="medium" variant="tertiary" icon={ActivityIcon} />
              </Tooltip>
              <Tooltip content="View Announcements">
                <Button size="medium" variant="tertiary" icon={AnnouncementIcon} />
              </Tooltip>
              <Menu openInteraction="click">
                <Avatar size="medium" name="Anurag Hazra" />
                <MenuOverlay>
                  <MenuHeader title="Profile" />
                  <Box display="flex" gap="spacing.4" padding="spacing.4" alignItems="center">
                    <Avatar size="medium" name="John Doe" />
                    <Box display="flex" flexDirection="column" gap="spacing.2">
                      <Text size="medium" weight="semibold">
                        John Doe
                      </Text>
                      <Text size="xsmall" color="surface.text.gray.muted">
                        Razorpay Trusted Merchant
                      </Text>
                    </Box>
                  </Box>
                  <MenuItem>
                    <Text color="surface.text.gray.subtle">Settings</Text>
                  </MenuItem>
                  <MenuItem color="negative">
                    <Text color="feedback.text.negative.intense">Logout</Text>
                  </MenuItem>
                </MenuOverlay>
              </Menu>
            </TopNavActions>
          </>
        )}
      </TopNav>
      <Box
        overflow="hidden"
        position="relative"
        borderRadius="large"
        borderTopRightRadius="none"
        borderBottomLeftRadius="none"
        borderBottomRightRadius="none"
        height="calc(100vh - 56px)"
        marginX={{
          base: 'spacing.0',
          m: 'spacing.3',
        }}
      >
        <SideNav
          isOpen={isSideBarOpen}
          onDismiss={() => {
            setIsSideBarOpen(false);
          }}
        />
      </Box>
    </DashboardBackground>
  );
};

export default TopNavComponent;

// file: navigation/SideNav.tsx
import React from 'react';
import { matchPath, useLocation, Link, Routes, Route } from 'react-router-dom';
import {
  SideNavBody,
  SideNav,
  SideNavLink,
  SideNavLevel,
  SideNavSection,
  SideNavFooter,
  SideNavItem,
  Box,
  Indicator,
  Switch as BladeSwitch,
  BoxIcon,
  SettingsIcon,
  UserIcon,
  SIDE_NAV_EXPANDED_L1_WIDTH_BASE,
  SIDE_NAV_EXPANDED_L1_WIDTH_XL,
} from '@razorpay/blade/components';
import Example from '../pages/Example';
import { navItemsJSON } from './NavItems';

// Define interfaces for navigation items (used only for type checking)
interface NavItem {
  icon?: React.ComponentType;
  title: string;
  href?: string;
  items?: NavItem[];
  trailing?: React.ReactNode;
  activeOnLinks?: string[];
}

/**
 * Returns all hrefs in child tree for given item
 */
const getAllChildHrefs = (items: NavItem[]): string[] => {
  const hrefs: string[] = [];

  items.forEach((item) => {
    if (item.href) {
      hrefs.push(item.href);
    }
    if (item.items) {
      hrefs.push(...getAllChildHrefs(item.items));
    }
  });

  return hrefs;
};

/**
 * Returns if the given href or one of the items from activeOnLinks are active
 */
const isItemActive = (
  location: { pathname: string },
  { href, activeOnLinks }: { href?: string; activeOnLinks?: string[] },
) => {
  const isCurrentPathActive = Boolean(matchPath(location.pathname, href ?? ''));

  const isSubItemActive = Boolean(
    activeOnLinks?.find((link) => matchPath(location.pathname, link)),
  );

  return isCurrentPathActive || isSubItemActive;
};

/**
 * React Router v6 Wrapper around Blade's SideNavLink that passes active state of item based on react router state
 */
const NavLink = (props: {
  icon?: React.ComponentType;
  title: string;
  href?: string;
  items?: unknown[];
  activeOnLinks?: string[];
  children?: React.ReactNode;
  as?: React.ElementType;
  [key: string]: unknown;
}) => {
  const location = useLocation();

  return (
    // @ts-expect-error - SideNavLink has strict type requirements for trailing prop that we need to bypass. Will figure this out later if needed.
    <SideNavLink
      {...props}
      as={Link}
      isActive={isItemActive(location, {
        href: props.href,
        activeOnLinks: props.activeOnLinks,
      })}
    />
  );
};

const SideNavComponent = ({ isOpen, onDismiss }) => {
  const [isMobileOpen, setIsMobileOpen] = React.useState(isOpen);
  const [isTestModeActive, setIsTestModeActive] = React.useState(false);
  const location = useLocation();

  /**
   * Keeps the section expanded on load if one if the items are active
   */
  const getDefaultSectionExpanded = (items: NavItem[]) => {
    const activeItem = items.find((l1Item) =>
      isItemActive(location, {
        href: l1Item.href,
        activeOnLinks: l1Item.items ? getAllChildHrefs(l1Item.items) : undefined,
      }),
    );

    return Boolean(activeItem);
  };

  return (
    <>
      <SideNav
        isOpen={isMobileOpen}
        onDismiss={() => {
          onDismiss();
          setIsMobileOpen(false);
        }}
        position="absolute"
      >
        <SideNavBody>
          {navItemsJSON.map((l1Sections) => {
            return (
              <SideNavSection
                key={l1Sections.title}
                title={l1Sections.title}
                maxVisibleItems={l1Sections.maxItemsVisible}
                defaultIsExpanded={getDefaultSectionExpanded(
                  l1Sections.items.slice(l1Sections.maxItemsVisible),
                )}
              >
                {l1Sections.items.map((l1Item) => {
                  if (!l1Item.items) {
                    return <NavLink key={l1Item.title} {...l1Item} />;
                  }

                  return (
                    <NavLink
                      key={l1Item.title}
                      {...l1Item}
                      activeOnLinks={getAllChildHrefs(l1Item.items)}
                      href={l1Item.items[0].href}
                    >
                      <SideNavLevel key={l1Item.title}>
                        {l1Item.items.map((l2Item) => {
                          if (!l2Item.items) {
                            return <NavLink key={l2Item.title} {...l2Item} />;
                          }

                          return (
                            <NavLink
                              key={l2Item.title}
                              {...l2Item}
                              activeOnLinks={getAllChildHrefs(l2Item.items)}
                              href={undefined}
                            >
                              <SideNavLevel key={l2Item.title}>
                                {l2Item.items.map((l3Item) => {
                                  return <NavLink key={l3Item.title} {...l3Item} />;
                                })}
                              </SideNavLevel>
                            </NavLink>
                          );
                        })}
                      </SideNavLevel>
                    </NavLink>
                  );
                })}
              </SideNavSection>
            );
          })}
        </SideNavBody>
        <SideNavFooter>
          <SideNavItem
            as="label"
            title="Test Mode"
            leading={
              <Indicator
                color={isTestModeActive ? 'notice' : 'positive'}
                emphasis="intense"
                accessibilityLabel=""
              />
            }
            backgroundColor={isTestModeActive ? 'feedback.background.notice.subtle' : undefined}
            trailing={
              <BladeSwitch
                accessibilityLabel=""
                size="small"
                isChecked={isTestModeActive}
                onChange={({ isChecked }) => {
                  setIsTestModeActive(isChecked);
                }}
              />
            }
          />
          <NavLink
            title="Settings"
            icon={SettingsIcon}
            href="/settings/user"
            activeOnLinks={['/settings/user', '/settings/account']}
          >
            <SideNavLevel>
              <NavLink icon={UserIcon} title="User Settings" href="/settings/user" />
              <NavLink icon={BoxIcon} title="Account Settings" href="/settings/account" />
            </SideNavLevel>
          </NavLink>
        </SideNavFooter>
      </SideNav>
      <Box
        marginLeft={{
          base: '100%',
          m: `${SIDE_NAV_EXPANDED_L1_WIDTH_BASE}px`,
          xl: `${SIDE_NAV_EXPANDED_L1_WIDTH_XL}px`,
        }}
        height="calc(100vh - 58px)"
      >
        <Box
          height="100%"
          overflowY="scroll"
          backgroundColor="surface.background.gray.intense"
        >
          {/* Main route entry points are here, add more routes here if needed */}
          <Routes>
            <Route path="/app/home" element={<Home />} />
          </Routes>
        </Box>
      </Box>
    </>
  );
};

export default SideNavComponent;

// file: navigation/utils.tsx
import React from 'react';
import { matchPath } from 'react-router-dom';

const isItemActive = (
  location: { pathname: string },
  { href, activeOnLinks }: { href?: string; activeOnLinks?: string[] },
) => {
  const isCurrentPathActive = Boolean(matchPath(location.pathname, href ?? ''));

  const isSubItemActive = Boolean(
    activeOnLinks?.find((link) => matchPath(location.pathname, link)),
  );

  return isCurrentPathActive || isSubItemActive;
};

const RazorpayLogo = () => {
  return (
    <img width="116" height="24" src="https://razorpay.com/newsroom-content/uploads/2020/12/output-onlinepngtools-1-1.png" />
  );
};

export { isItemActive, RazorpayLogo };

// file: index.tsx
// Index entry point
import React from 'react';
import { BladeProvider } from '@razorpay/blade/components';
import { bladeTheme } from '@razorpay/blade/tokens';
import { BrowserRouter } from 'react-router-dom';
import { createGlobalStyle } from 'styled-components';
import TopNav from '../navigation/TopNav';

const GlobalStyles = createGlobalStyle`
* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
  font-family: ${(props) => props.theme.typography.fonts.family.text}
}

h1, h2, h3, h4, h5, h6 {
  font-family: ${(props) => props.theme.typography.fonts.family.heading};
}
`;

function AppWrapper() {
  return (
    <BladeProvider themeTokens={bladeTheme} colorScheme="light">
      <GlobalStyles />
      <BrowserRouter>
        <TopNav />
      </BrowserRouter>
    </BladeProvider>
  );
}

export default AppWrapper;
```

---

## DetailedView

# DetailedView

## Pattern Name

DetailedView

## Description

A DetailedView is a pattern that displays comprehensive details of a transaction, user, or entity in a drawer format. It provides a structured layout for showing key information, timelines, transaction breakdowns, and related actions. This pattern is commonly used when users need to view detailed information about a selected item from a table, list, or card without navigating away from the current page.

## Components Used

- Drawer
- DrawerFooter
- Table
- Card
- Box
- Amount
- Badge
- Button
- IconButton
- Text
- Heading
- Code
- Link
- Divider
- StepGroup
- Collapsible
- Alert

## Example

### Transaction Details with Table Integration

This example shows a DetailedView pattern integrated with a Table component, displaying transaction details in a drawer when a table row is clicked.

```tsx
import React, { useState } from 'react';
import {
  Table,
  TableHeader,
  TableHeaderRow,
  TableHeaderCell,
  TableBody,
  TableRow,
  TableCell,
  TableToolbar,
  TableToolbarActions,
  TablePagination,
  Drawer,
  DrawerHeader,
  DrawerBody,
  DrawerFooter,
  Box,
  Amount,
  Badge,
  Button,
  IconButton,
  Text,
  Code,
  Link,
  Divider,
  StepGroup,
  StepItem,
  StepItemIndicator,
  Collapsible,
  CollapsibleBody,
  CollapsibleLink,
  MoreHorizontalIcon,
  DownloadIcon,
  CloseIcon,
  ArrowRightIcon,
  CopyIcon,
  CheckIcon,
  ClockIcon,
} from '@razorpay/blade/components';
type Transaction = {
  id: string;
  paymentId: string;
  amount: number;
  status: 'Completed' | 'Pending' | 'Failed';
  date: Date;
  type: string;
  method: string;
  name: string;
  bank: string;
  account: string;
};

const KeyValueItem = ({ label, children }: { label: string; children: React.ReactNode }) => (
  <>
    <Text variant="body" size="small" color="surface.text.gray.muted">
      {label}
    </Text>
    <Box>{children}</Box>
  </>
);

const KeyValueGrid = ({ children }: { children: React.ReactNode }) => (
  <Box display="grid" gridTemplateColumns="160px 1fr" gap="spacing.3">
    {children}
  </Box>
);

const Timeline = ({ status }: { status: string }) => (
  <StepGroup orientation="vertical" size="medium">
    <StepItem
      title="Payment Initiated"
      stepProgress={['Completed', 'Pending', 'Failed'].includes(status) ? 'full' : 'none'}
      marker={
        <StepItemIndicator
          color={['Completed', 'Pending', 'Failed'].includes(status) ? 'positive' : 'neutral'}
        />
      }
    />
    <Collapsible direction="top">
      <CollapsibleLink>Show More</CollapsibleLink>
      <CollapsibleBody>
        <StepItem
          title="Payment Processing"
          stepProgress={['Completed', 'Failed'].includes(status) ? 'full' : 'start'}
          marker={
            <StepItemIndicator
              color={['Completed', 'Failed'].includes(status) ? 'positive' : 'notice'}
            />
          }
        />
        <StepItem
          title={status === 'Failed' ? 'Payment Failed' : 'Payment Completed'}
          stepProgress={['Completed', 'Failed'].includes(status) ? 'full' : 'none'}
          marker={
            <StepItemIndicator
              color={
                status === 'Failed' ? 'negative' : status === 'Completed' ? 'positive' : 'neutral'
              }
            />
          }
        />
      </CollapsibleBody>
    </Collapsible>
  </StepGroup>
);

const TransactionDetailedView = () => {
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  const [selectedTransaction, setSelectedTransaction] = useState<Transaction | null>(null);

  const transactions: Transaction[] = [
    {
      id: '1',
      paymentId: 'rzp_123456',
      amount: 5000,
      status: 'Completed',
      date: new Date('2024-01-15'),
      type: 'Settlement',
      method: 'Bank Transfer',
      name: 'John Doe',
      bank: 'HDFC',
      account: '1234567890',
    },
    {
      id: '2',
      paymentId: 'rzp_789012',
      amount: 2500,
      status: 'Pending',
      date: new Date('2024-01-16'),
      type: 'Refund',
      method: 'UPI',
      name: 'Jane Smith',
      bank: 'ICICI',
      account: '0987654321',
    },
  ];

  const tableData = { nodes: transactions };

  return (
    <Box overflow="auto" minHeight="400px">
      <Table
        data={tableData}
        selectionType="none"
        toolbar={
          <TableToolbar title="Transactions">
            <TableToolbarActions>
              <Button variant="secondary" marginRight="spacing.2">
                Export
              </Button>
              <Button>Refund</Button>
            </TableToolbarActions>
          </TableToolbar>
        }
        pagination={
          <TablePagination defaultPageSize={10} showPageSizePicker showPageNumberSelector />
        }
      >
        {(tableData) => (
          <>
            <TableHeader>
              <TableHeaderRow>
                <TableHeaderCell>Payment ID</TableHeaderCell>
                <TableHeaderCell>Account Holder</TableHeaderCell>
                <TableHeaderCell>Amount</TableHeaderCell>
                <TableHeaderCell>Date</TableHeaderCell>
                <TableHeaderCell>Method</TableHeaderCell>
                <TableHeaderCell>Status</TableHeaderCell>
              </TableHeaderRow>
            </TableHeader>
            <TableBody>
              {tableData.map((transaction, index) => (
                <TableRow
                  key={index}
                  item={transaction}
                  onClick={() => {
                    setSelectedTransaction(transaction);
                    setIsDrawerOpen(true);
                  }}
                >
                  <TableCell>
                    <Code size="medium">{transaction.paymentId}</Code>
                  </TableCell>
                  <TableCell>{transaction.name}</TableCell>
                  <TableCell>
                    <Amount value={transaction.amount} currency="INR" />
                  </TableCell>
                  <TableCell>
                    {transaction.date.toLocaleDateString('en-IN', {
                      year: 'numeric',
                      month: '2-digit',
                      day: '2-digit',
                    })}
                  </TableCell>
                  <TableCell>{transaction.method}</TableCell>
                  <TableCell>
                    <Badge
                      size="medium"
                      color={
                        transaction.status === 'Completed'
                          ? 'positive'
                          : transaction.status === 'Pending'
                          ? 'notice'
                          : 'negative'
                      }
                    >
                      {transaction.status}
                    </Badge>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </>
        )}
      </Table>

      <Drawer
        isOpen={isDrawerOpen}
        onDismiss={() => setIsDrawerOpen(false)}
        onUnmount={() => setSelectedTransaction(null)}
      >
        <DrawerHeader
          color={
            selectedTransaction?.status === 'Completed'
              ? 'positive'
              : selectedTransaction?.status === 'Pending'
              ? 'notice'
              : 'negative'
          }
          title="Transaction Details"
          trailing={
            <IconButton
              icon={MoreHorizontalIcon}
              accessibilityLabel="More options"
              onClick={() => console.log('Options clicked')}
              size="large"
            />
          }
          showDivider={false}
        >
          <Box marginTop="spacing.6" textAlign="center">
            <Amount
              value={selectedTransaction?.amount ?? 0}
              currency="INR"
              size="2xlarge"
              type="heading"
              weight="semibold"
              suffix="decimals"
            />
          </Box>
          <Box display="flex" justifyContent="center" gap="spacing.4" marginTop="spacing.4">
            <Badge
              size="medium"
              color={
                selectedTransaction?.status === 'Completed'
                  ? 'positive'
                  : selectedTransaction?.status === 'Pending'
                  ? 'notice'
                  : 'negative'
              }
              emphasis="intense"
              icon={
                selectedTransaction?.status === 'Completed'
                  ? CheckIcon
                  : selectedTransaction?.status === 'Pending'
                  ? ClockIcon
                  : undefined
              }
            >
              {selectedTransaction?.status ?? 'Pending'}
            </Badge>
          </Box>
          <Box
            display="flex"
            alignItems="center"
            justifyContent="center"
            gap="spacing.4"
            marginTop="spacing.6"
            paddingX="spacing.4"
          >
            <Box display="flex">
              <Divider thickness="thicker" orientation="vertical" />
              <Box paddingX="spacing.3">
                <Text size="xsmall" color="surface.text.gray.muted" weight="semibold">
                  Payment ID
                </Text>
                <Text size="medium">{selectedTransaction?.paymentId}</Text>
              </Box>
            </Box>
            <Box display="flex">
              <Divider thickness="thicker" orientation="vertical" />
              <Box paddingX="spacing.3">
                <Text size="xsmall" color="surface.text.gray.muted" weight="semibold">
                  Date
                </Text>
                <Text size="medium">
                  {selectedTransaction?.date?.toLocaleDateString('en-IN', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                  })}
                </Text>
              </Box>
            </Box>
          </Box>
          <Box marginTop="spacing.6" textAlign="center">
            <Button
              variant="secondary"
              color="primary"
              size="small"
              icon={DownloadIcon}
              isFullWidth
            >
              Download Report
            </Button>
          </Box>
        </DrawerHeader>
        <DrawerBody>
          <Box display="flex" flexDirection="column" gap="spacing.6">
            <Box>
              <Text variant="body" size="medium" weight="semibold" marginBottom="spacing.4">
                Timeline
              </Text>
              <Timeline status={selectedTransaction?.status ?? 'Pending'} />
            </Box>
            <Divider />
            <Box>
              <Text variant="body" size="medium" weight="semibold" marginBottom="spacing.4">
                Transaction Details
              </Text>
              <KeyValueGrid>
                <KeyValueItem label="Amount">
                  <Amount value={selectedTransaction?.amount ?? 0} currency="INR" />
                </KeyValueItem>
                <KeyValueItem label="Payment ID">
                  <Box display="flex" gap="spacing.2" alignItems="center">
                    <Code size="small">{selectedTransaction?.paymentId ?? 'NA'}</Code>
                    <Link variant="button" size="small" icon={CopyIcon} />
                  </Box>
                </KeyValueItem>
                <KeyValueItem label="Payment Type">
                  <Text variant="body" size="medium">
                    {selectedTransaction?.type}
                  </Text>
                </KeyValueItem>
                <KeyValueItem label="Payment Method">
                  <Text variant="body" size="medium">
                    {selectedTransaction?.method}
                  </Text>
                </KeyValueItem>
                <KeyValueItem label="Account Holder">
                  <Text variant="body" size="medium">
                    {selectedTransaction?.name}
                  </Text>
                </KeyValueItem>
                <KeyValueItem label="Bank">
                  <Text variant="body" size="medium">
                    {selectedTransaction?.bank}
                  </Text>
                </KeyValueItem>
                <KeyValueItem label="Account Number">
                  <Text variant="body" size="medium">
                    {selectedTransaction?.account}
                  </Text>
                </KeyValueItem>
              </KeyValueGrid>
            </Box>
          </Box>
        </DrawerBody>
      </Drawer>
    </Box>
  );
};

export default TransactionDetailedView;
```

### Settlement Details with Card Integration

This example demonstrates a DetailedView pattern triggered from a Card component, showing settlement breakdown and transaction details.

```tsx
import React, { useState } from 'react';
import {
  Card,
  CardBody,
  CardHeader,
  CardHeaderLeading,
  CardHeaderTrailing,
  CardHeaderIcon,
  CardHeaderLink,
  Drawer,
  DrawerHeader,
  DrawerBody,
  DrawerFooter,
  Box,
  Amount,
  Badge,
  Button,
  Text,
  Heading,
  Divider,
  Code,
  Link,
  RazorpayIcon,
  ExternalLinkIcon,
  DownloadIcon,
  CheckIcon,
  CopyIcon,
  CloseIcon,
  ArrowRightIcon,
} from '@razorpay/blade/components';

const KeyValueItem = ({ label, children }: { label: string; children: React.ReactNode }) => (
  <>
    <Text variant="body" size="small" color="surface.text.gray.muted">
      {label}
    </Text>
    <Box>{children}</Box>
  </>
);

const KeyValueGrid = ({ children }: { children: React.ReactNode }) => (
  <Box display="grid" gridTemplateColumns="160px 1fr" gap="spacing.3">
    {children}
  </Box>
);

const SettlementDetailedView = () => {
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  const [showFooter, setShowFooter] = useState(true);

  const settlementData = {
    amount: 3120,
    amountPaid: 3120,
    paymentId: 'pay_MK7DGqwYXEwx9Q',
    referenceId: 'ref_MK7DGqwYXEwx9Q',
    type: 'Settlement',
    utr: 'UTR123456789',
    bankAccount: '1234567890',
    ifsc: 'HDFC0001234',
    status: 'Completed',
    tax: 260,
    fee: 260,
    netAmount: 2600,
  };

  return (
    <Box>
      <Box display="flex" gap="spacing.4" marginBottom="spacing.4">
        <Button variant="secondary" onClick={() => setShowFooter(!showFooter)}>
          {showFooter ? 'Hide Footer' : 'Show Footer'}
        </Button>
      </Box>

      <Card width={{ base: '100%', m: '500px' }}>
        <CardHeader>
          <CardHeaderLeading
            prefix={<CardHeaderIcon icon={RazorpayIcon} />}
            title="Settlement Summary"
          />
          <CardHeaderTrailing
            visual={
              <CardHeaderLink
                variant="button"
                onClick={() => setIsDrawerOpen(true)}
                icon={ExternalLinkIcon}
                iconPosition="right"
              >
                View Details
              </CardHeaderLink>
            }
          />
        </CardHeader>
        <CardBody>
          <Box
            display="grid"
            gridTemplateColumns="1fr auto"
            columnGap="spacing.4"
            rowGap="spacing.3"
          >
            <Text variant="body" size="medium" color="surface.text.gray.muted" gridColumn="1 / -1">
              Gross Settlements
            </Text>
            <Text variant="body" size="medium">
              Payment
            </Text>
            <Box>
              <Amount value={settlementData.amount} currency="INR" />
            </Box>

            <Text
              variant="body"
              size="medium"
              color="surface.text.gray.muted"
              gridColumn="1 / -1"
              marginTop="spacing.4"
            >
              Deductions
            </Text>
            <Text variant="body" size="medium">
              Tax
            </Text>
            <Box>
              <Amount value={settlementData.tax} currency="INR" />
            </Box>
            <Text variant="body" size="medium">
              Fee
            </Text>
            <Box>
              <Amount value={settlementData.fee} currency="INR" />
            </Box>

            <Box gridColumn="1 / -1" marginTop="spacing.4">
              <Divider marginBottom="spacing.4" />
              <Box display="grid" gridTemplateColumns="1fr auto">
                <Text variant="body" size="medium" weight="semibold">
                  Net Settlement Amount
                </Text>
                <Box>
                  <Amount value={settlementData.netAmount} currency="INR" weight="semibold" />
                </Box>
              </Box>
            </Box>
          </Box>
        </CardBody>
      </Card>

      <Drawer isOpen={isDrawerOpen} onDismiss={() => setIsDrawerOpen(false)}>
        <DrawerHeader
          color="positive"
          title="Settlement Details"
          trailing={<Button size="medium" icon={DownloadIcon} />}
          showDivider={false}
        >
          <Box marginTop="spacing.6" textAlign="center">
            <Amount
              value={settlementData.amount}
              currency="INR"
              size="2xlarge"
              type="heading"
              weight="semibold"
              suffix="decimals"
            />
          </Box>
          <Box display="flex" justifyContent="center" gap="spacing.4" marginTop="spacing.4">
            <Badge icon={CheckIcon} size="medium" color="positive" emphasis="intense">
              {settlementData.status}
            </Badge>
          </Box>
          <Box
            display="flex"
            alignItems="center"
            justifyContent="center"
            gap="spacing.4"
            marginTop="spacing.6"
            paddingX="spacing.4"
          >
            <Box display="flex">
              <Divider thickness="thicker" orientation="vertical" />
              <Box paddingX="spacing.3">
                <Text size="xsmall" color="surface.text.gray.muted" weight="semibold">
                  Payment ID
                </Text>
                <Text size="medium">{settlementData.paymentId}</Text>
              </Box>
            </Box>
          </Box>
          <Text
            size="small"
            marginTop="spacing.6"
            textAlign="center"
            color="surface.text.gray.muted"
          >
            Settlement was completed on 24th April 2025
          </Text>
        </DrawerHeader>
        <DrawerBody>
          <Heading size="small" weight="semibold" marginBottom="spacing.4">
            Settlement Breakdown
          </Heading>
          <KeyValueGrid>
            <KeyValueItem label="Gross Amount">
              <Amount value={settlementData.amount} currency="INR" />
            </KeyValueItem>
            <KeyValueItem label="Tax Deducted">
              <Amount value={settlementData.tax} currency="INR" />
            </KeyValueItem>
            <KeyValueItem label="Processing Fee">
              <Amount value={settlementData.fee} currency="INR" />
            </KeyValueItem>
            <KeyValueItem label="Net Amount">
              <Amount value={settlementData.netAmount} currency="INR" weight="semibold" />
            </KeyValueItem>
          </KeyValueGrid>

          <Heading marginTop="spacing.6" marginBottom="spacing.4" size="small" weight="semibold">
            Transaction Information
          </Heading>
          <KeyValueGrid>
            <KeyValueItem label="Payment ID">
              <Box display="flex" gap="spacing.2" alignItems="center">
                <Code size="small">{settlementData.paymentId}</Code>
                <Link variant="button" size="small" icon={CopyIcon} />
              </Box>
            </KeyValueItem>
            <KeyValueItem label="Reference ID">
              <Text variant="body" size="medium">
                {settlementData.referenceId}
              </Text>
            </KeyValueItem>
            <KeyValueItem label="UTR Number">
              <Box display="flex" gap="spacing.2" alignItems="center">
                <Code size="small">{settlementData.utr}</Code>
                <Link variant="button" size="small" icon={CopyIcon} />
              </Box>
            </KeyValueItem>
            <KeyValueItem label="Bank Account">
              <Text variant="body" size="medium">
                {settlementData.bankAccount}
              </Text>
            </KeyValueItem>
            <KeyValueItem label="IFSC Code">
              <Text variant="body" size="medium">
                {settlementData.ifsc}
              </Text>
            </KeyValueItem>
            <KeyValueItem label="Settlement Type">
              <Text variant="body" size="medium">
                {settlementData.type}
              </Text>
            </KeyValueItem>
          </KeyValueGrid>
        </DrawerBody>

        {showFooter && (
          <DrawerFooter>
            <Box display="flex" gap="spacing.5">
              <Button
                variant="tertiary"
                icon={CloseIcon}
                iconPosition="left"
                isFullWidth
                onClick={() => setIsDrawerOpen(false)}
              >
                Cancel
              </Button>
              <Button variant="primary" icon={ArrowRightIcon} iconPosition="right" isFullWidth>
                Process Settlement
              </Button>
            </Box>
          </DrawerFooter>
        )}
      </Drawer>
    </Box>
  );
};

export default SettlementDetailedView;
```

---

## FormGroup

# FormGroup

## Description

FormGroup is a pattern that provides a consistent way to build forms using Blade components. It offers structured layouts for form sections, proper spacing, validation handling, and responsive design. Use this pattern when you need to create forms with multiple input fields, validation states, different layouts (horizontal/vertical sections), and consistent spacing between form elements.

## Components Used

- Box
- TextInput
- TextArea
- PasswordInput
- SelectInput
- Dropdown
- DropdownOverlay
- ActionList
- ActionListItem
- Button
- Alert
- Toast
- ToastContainer
- Heading
- Text

## Example

### Simple Contact Form

A basic form with email and message fields, demonstrating the fundamental FormGroup structure with proper spacing and submission handling.

```tsx
import React, { useState } from 'react';
import {
  Box,
  TextInput,
  TextArea,
  Button,
  Heading,
  useToast,
  ToastContainer,
  ArrowRightIcon,
} from '@razorpay/blade/components';

const SimpleContactForm = () => {
  const [formData, setFormData] = useState({
    email: '',
    message: '',
  });
  const toast = useToast();

  const handleSubmit = (e: React.FormEvent): void => {
    e.preventDefault();

    toast.show({
      content: `Thanks for reaching out! Your message has been sent.`,
      color: 'positive',
      type: 'informational',
    });
    setFormData({ email: '', message: '' });
  };

  return (
    <form onSubmit={handleSubmit}>
      <Box padding="spacing.6" display="flex" flexDirection="column" gap="spacing.7">
        <ToastContainer />
        <Box>
          <Heading size="large">Contact Us</Heading>
          <Heading size="medium" weight="regular">
            We'd love to hear from you
          </Heading>
        </Box>

        <Box display="flex" flexDirection="column" gap="spacing.4">
          <TextInput
            label="Email"
            name="email"
            value={formData.email}
            onChange={({ value }) => setFormData({ ...formData, email: value ?? '' })}
            placeholder="Enter your email"
          />

          <TextArea
            label="Message"
            name="message"
            value={formData.message}
            onChange={({ value }) => setFormData({ ...formData, message: value ?? '' })}
            numberOfLines={4}
            placeholder="Enter your message"
          />

          <Button isFullWidth type="submit" icon={ArrowRightIcon} iconPosition="right">
            Send Message
          </Button>
        </Box>
      </Box>
    </form>
  );
};
```

### Form with Validation and Error Handling

A comprehensive form demonstrating validation states, error messages, required fields, and both individual and grouped error handling approaches.

```tsx
import React, { useState } from 'react';
import { Box, TextInput, PasswordInput, Button, Alert, Heading , ArrowRightIcon} from '@razorpay/blade/components';

const ValidationForm = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
  });

  const [errors, setErrors] = useState<Record<string, string>>({});
  const [alert, setAlert] = useState<{
    type: 'positive' | 'negative';
    title: string;
    description: string;
  } | null>(null);

  const handleChange = (name: string, value: string | undefined): void => {
    setFormData((prev) => ({ ...prev, [name]: value ?? '' }));
    // Clear error when typing
    if (errors[name]) setErrors((prev) => ({ ...prev, [name]: '' }));
  };

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Invalid email format';
    }

    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e: React.FormEvent): void => {
    e.preventDefault();
    if (validateForm()) {
      setAlert({
        type: 'positive',
        title: 'Success!',
        description: 'Your form has been submitted successfully.',
      });
    } else {
      setAlert({
        type: 'negative',
        title: 'Form Submission Failed',
        description: 'Please fix the errors in the form and try again.',
      });
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <Box padding="spacing.4" display="flex" flexDirection="column" gap="spacing.4">
        <Box>
          <Heading size="large">Welcome to Blade Example</Heading>
          <Heading size="medium" weight="regular">
            This is an example form built with Blade
          </Heading>
        </Box>

        {alert && (
          <Alert
            color={alert.type}
            title={alert.title}
            description={alert.description}
            emphasis="subtle"
            isDismissible
            onDismiss={() => setAlert(null)}
            isFullWidth
          />
        )}

        <Box display="flex" flexDirection="column" gap="spacing.4">
          <TextInput
            necessityIndicator="required"
            label="Email"
            name="email"
            value={formData.email}
            onChange={({ value }) => handleChange('email', value)}
            validationState={errors.email ? 'error' : 'none'}
            errorText={errors.email}
            placeholder="Enter your email"
          />
          <PasswordInput
            necessityIndicator="required"
            label="Password"
            name="password"
            value={formData.password}
            onChange={({ value }) => handleChange('password', value)}
            helpText="Should be more than 8 characters"
            validationState={errors.password ? 'error' : 'none'}
            errorText={errors.password}
            placeholder="Enter your password"
          />
          <Button isFullWidth type="submit" icon={ArrowRightIcon} iconPosition="right">
            Sign In
          </Button>
        </Box>
      </Box>
    </form>
  );
};
```

### Multi-Section Form with Layout Variants

A comprehensive form demonstrating horizontal and vertical section layouts, different label positions, density options, grid layouts, and dropdown integration.

```tsx
import React, { useState } from 'react';
import {
  Box,
  TextInput,
  TextArea,
  SelectInput,
  Dropdown,
  DropdownOverlay,
  ActionList,
  ActionListItem,
  Button,
  Heading,
  Text,
  useToast,
  ToastContainer,
} from '@razorpay/blade/components';

const CITY_OPTIONS = [
  { title: 'Mumbai', value: 'mumbai' },
  { title: 'Pune', value: 'pune' },
  { title: 'Bangalore', value: 'bangalore' },
  { title: 'Mysore', value: 'mysore' },
];

const MultiSectionForm = () => {
  const [bankData, setBankData] = useState({
    bankName: '',
    branchName: '',
    branchNumber: '',
    addressLine1: '',
    addressLine2: '',
    pinCode: '',
    city: '',
    additionalInformation: '',
  });

  const toast = useToast();

  const handleChange = (field: string, value: string): void => {
    setBankData((prev) => ({ ...prev, [field]: value }));
  };

  const handleSubmit = (e: React.FormEvent): void => {
    e.preventDefault();
    toast.show({
      content: 'Thanks for reaching out! Your form has been submitted successfully.',
      color: 'positive',
      type: 'informational',
    });
    setBankData({
      bankName: '',
      branchName: '',
      branchNumber: '',
      addressLine1: '',
      addressLine2: '',
      pinCode: '',
      city: '',
      additionalInformation: '',
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <Box display="flex" flexDirection="column" gap="spacing.8">
        <ToastContainer />
        <Box>
          <Heading size="large" weight="semibold">
            Bank Branch Form
          </Heading>
          <Text weight="regular" color="surface.text.gray.muted">
            Fill the following information to add a new branch of the bank
          </Text>
        </Box>

        <Box display="flex" flexDirection="column" gap="spacing.8">
          {/* General Details Section */}
          <Box display="flex" flexDirection="row" gap="spacing.5">
            <Box>
              <Heading size="medium">General Details</Heading>
              <Text weight="regular" color="surface.text.gray.muted">
                This is general subtext for a section
              </Text>
            </Box>

            <Box width="100%" display="flex" flexDirection="column" gap="spacing.5">
              <TextInput
                label="Bank Name"
                name="bankName"
                value={bankData.bankName}
                onChange={({ value }) => handleChange('bankName', value ?? '')}
                labelPosition="top"
                helpText="Full name of the registered national bank"
                placeholder="State Bank of India"
              />
              <Box width="100%" display="grid" gridTemplateColumns="1fr 1fr" gap="spacing.5">
                <TextInput
                  label="Branch Name"
                  name="branchName"
                  value={bankData.branchName}
                  onChange={({ value }) => handleChange('branchName', value ?? '')}
                  labelPosition="top"
                  helpText="Generally, it is location of your branch"
                  placeholder="A1 Block, Janakpuri"
                />

                <TextInput
                  label="Branch Number"
                  name="branchNumber"
                  value={bankData.branchNumber}
                  onChange={({ value }) => handleChange('branchNumber', value ?? '')}
                  labelPosition="top"
                  helpText="The 5-digit number, you can find it on your bank's cheque book"
                  placeholder="SBIN0011315"
                />
              </Box>
            </Box>
          </Box>

          {/* Address Details Section */}
          <Box display="flex" flexDirection="row" gap="spacing.5">
            <Box>
              <Heading size="medium">Address Details</Heading>
              <Text weight="regular" color="surface.text.gray.muted">
                This is general subtext for a section
              </Text>
            </Box>
            <Box width="100%" display="flex" flexDirection="column" gap="spacing.5">
              <TextInput
                label="Address Line 1"
                name="addressLine1"
                value={bankData.addressLine1}
                onChange={({ value }) => handleChange('addressLine1', value ?? '')}
                labelPosition="top"
                placeholder="A1-240, Titan Towers, State Bank of India"
              />

              <TextInput
                label="Address Line 2"
                name="addressLine2"
                value={bankData.addressLine2}
                onChange={({ value }) => handleChange('addressLine2', value ?? '')}
                labelPosition="top"
                placeholder="A1 Janakpuri, Opposite Community Hall"
              />

              <Box width="100%" display="grid" gridTemplateColumns="1fr 1fr" gap="spacing.5">
                <TextInput
                  label="Pin Code"
                  name="pinCode"
                  value={bankData.pinCode}
                  onChange={({ value }) => handleChange('pinCode', value ?? '')}
                  labelPosition="top"
                  placeholder="110018"
                />

                <Dropdown selectionType="single">
                  <SelectInput
                    label="City"
                    placeholder="Select City"
                    name="city"
                    onChange={({ values }) => handleChange('city', values[0] ?? '')}
                    labelPosition="top"
                  />
                  <DropdownOverlay>
                    <ActionList>
                      {CITY_OPTIONS.map((city) => (
                        <ActionListItem key={city.value} title={city.title} value={city.value} />
                      ))}
                    </ActionList>
                  </DropdownOverlay>
                </Dropdown>
              </Box>
            </Box>
          </Box>

          <TextArea
            label="Additional Information"
            name="additionalInformation"
            value={bankData.additionalInformation}
            onChange={({ value }) => handleChange('additionalInformation', value ?? '')}
            numberOfLines={4}
            placeholder="Enter any additional information"
          />
        </Box>

        <Box display="flex" gap="spacing.4" justifyContent="flex-end">
          <Button variant="tertiary" color="primary" size="medium">
            Discard
          </Button>
          <Button type="submit" variant="primary" color="primary" size="medium">
            Save
          </Button>
        </Box>
      </Box>
    </form>
  );
};
```

### Form with Fixed Footer

A long form demonstrating fixed footer positioning with action buttons that remain visible during scrolling.

```tsx
import React, { useState } from 'react';
import {
  Box,
  TextInput,
  TextArea,
  Button,
  Heading,
  Text,
  useToast,
  ToastContainer,
} from '@razorpay/blade/components';

const LongFormWithFixedFooter = () => {
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    content: '',
  });

  const toast = useToast();

  const handleChange = (field: string, value: string): void => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  const handleSubmit = (e: React.FormEvent): void => {
    e.preventDefault();
    toast.show({
      content: 'Document has been saved successfully.',
      color: 'positive',
      type: 'informational',
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <Box display="flex" flexDirection="column" gap="spacing.8" paddingBottom="spacing.11">
        <ToastContainer />
        <Box>
          <Heading size="large" weight="semibold">
            Create Document
          </Heading>
          <Text weight="regular" color="surface.text.gray.muted">
            Fill out the form below to create a new document
          </Text>
        </Box>

        <Box display="flex" flexDirection="column" gap="spacing.5">
          <TextInput
            label="Document Title"
            name="title"
            value={formData.title}
            onChange={({ value }) => handleChange('title', value ?? '')}
            placeholder="Enter document title"
          />

          <TextInput
            label="Description"
            name="description"
            value={formData.description}
            onChange={({ value }) => handleChange('description', value ?? '')}
            placeholder="Enter a brief description"
          />

          <TextArea
            label="Content"
            name="content"
            value={formData.content}
            onChange={({ value }) => handleChange('content', value ?? '')}
            numberOfLines={5}
            placeholder="Enter the main content of your document"
          />
        </Box>

        <Box
          display="flex"
          gap="spacing.4"
          justifyContent="flex-end"
          backgroundColor="surface.background.gray.moderate"
          padding="spacing.4"
          position="fixed"
          bottom="spacing.0"
          right="spacing.4"
          width="100%"
          borderColor="surface.border.gray.muted"
          borderWidth="thin"
        >
          <Button variant="tertiary" color="primary" size="medium">
            Discard
          </Button>
          <Button type="submit" variant="primary" color="primary" size="medium">
            Save
          </Button>
        </Box>
      </Box>
    </form>
  );
};
```

---

## index

# When to Use Patterns

## Confirmation
A pattern for seeking user confirmation before proceeding with important or irreversible actions. Use this pattern when you need to get explicit user acknowledgment for critical actions like deletions, platform switches, or important changes, with support for different emotional states (neutral, negative, positive) to match the action's impact.

## CreationView

CreationView is a pattern used in creation flows to guide users through the process of creating new entities like QR codes, GRNs, or other business objects. Use this pattern when you need structured form flows with validation, preview capabilities, and step-by-step guidance that adapts to different screen sizes.

## DetailedView

A DetailedView is a pattern that is used to show details of a transaction, user, or entity in a drawer in a defined format. It can open on click of table row or any button and link on page.

## FormGroup

FormGroup is a pattern that provides a consistent way to build forms using Blade components. Use this pattern when you need to create forms with multiple input fields, validation states, different layouts, and consistent spacing between form elements.

## ListView

ListView is a pattern that has tables with filters, search, pagination, etc. It uses table component to show the list of items and uses QuickFilter and other ListView components for filtering over the table.

## Settings

Settings is a pattern that provides a structured way to organize application configuration options and user preferences. Use this pattern when you need to create a settings interface with navigation, categorized settings cards, and detailed settings pages. The pattern includes both overview and detail views with responsive layouts and accessibility features.

## Dashboard Template

Dashboard Template is a full dashboard template with SideNav, TopNav and main workspace area. It also includes a navigation structure with sections and items implemented via react-router-dom.

---

## ListView

# ListView

## Description

ListView is a comprehensive data presentation pattern that combines tables with advanced filtering, searching, and data management capabilities. It provides a complete solution for displaying large datasets with interactive filters including quick filters, search functionality, date range selection, and dropdown filters. This pattern is ideal for dashboards, admin panels, and any interface that needs to display and filter tabular data efficiently with a consistent user experience.

## Components Used

- ListView
- Table
- QuickFilter
- Dropdown
- ActionList
- Counter
- Badge
- Button
- IconButton
- Code
- Amount
- Box
- SearchInput
- ButtonGroup
- Tooltip

## Example

### Basic ListView with Comprehensive Filtering

This example demonstrates a complete ListView implementation with quick filters, search functionality, dropdown filters, date range selection, and table interactions including row selection and hover actions.

```tsx
import React, { useState } from 'react';
import {
  ListView,
  ListViewFilters,
  Table,
  TableHeader,
  TableHeaderRow,
  TableHeaderCell,
  TableBody,
  TableRow,
  TableCell,
  TableEditableCell,
  TableFooter,
  TableFooterRow,
  TableFooterCell,
  TablePagination,
  QuickFilterGroup,
  QuickFilter,
  FilterChipGroup,
  FilterChipSelectInput,
  FilterChipDatePicker,
  Dropdown,
  DropdownOverlay,
  ActionList,
  ActionListItem,
  Counter,
  Badge,
  Button,
  IconButton,
  Code,
  Amount,
  Box,
  SearchInput,
  ButtonGroup,
  Tooltip,
  CheckIcon,
  CloseIcon,
  Link,
} from '@razorpay/blade/components';
import type { TableData, DatesRangeValue } from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';

type PaymentItem = {
  id: string;
  paymentId: string;
  amount: number;
  status: string;
  date: Date;
  type: string;
  method: {
    key: string;
    title: string;
  };
  bank: string;
  account: string;
  name: string;
};

const MethodFilterValues = [
  { key: 'bank-transfer', title: 'Bank Transfer' },
  { key: 'credit-card', title: 'Credit Card' },
  { key: 'paypal', title: 'PayPal' },
];

const nodes: PaymentItem[] = [
  ...Array.from({ length: 30 }, (_, i) => ({
    id: (i + 1).toString(),
    paymentId: `rzp${Math.floor(Math.random() * 1000000)}`,
    amount: Number((Math.random() * 10000).toFixed(2)),
    status: ['Completed', 'Pending', 'Failed'][Math.floor(Math.random() * 3)],
    date: new Date(2025, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1),
    type: ['Payout', 'Refund'][Math.floor(Math.random() * 2)],
    method: MethodFilterValues[Math.floor(Math.random() * 3)],
    bank: ['HDFC', 'ICICI', 'SBI'][Math.floor(Math.random() * 3)],
    account: Math.floor(Math.random() * 1000000000).toString(),
    name: ['John Doe', 'Jane Doe', 'Bob Smith', 'Alice Smith'][Math.floor(Math.random() * 4)],
  })),
];

const quickFilters = ['All', 'Pending', 'Failed', 'Completed'];
const filterChipQuickFilters = ['Pending', 'Failed', 'Completed'];

const data: TableData<PaymentItem> = { nodes };

function BasicListViewExample() {
  const [listViewTableData, setListViewTableData] = useState(data);
  const [selectedQuickFilter, setSelectedQuickFilter] = useState<string>('All');
  const [searchValue, setSearchValue] = useState<string | undefined>('');
  const [methodFilter, setMethodFilter] = useState<string | undefined>('');
  const [filterDateRange, setFilterDateRange] = useState<DatesRangeValue | undefined>(undefined);

  const getQuickFilterValueCount = (value: string): number => {
    if (value === 'All') {
      return data.nodes.length;
    }
    return data.nodes.filter((node) => node.status === value).length;
  };

  const getQuickFilterData = (
    data: TableData<PaymentItem>,
    value?: string,
  ): TableData<PaymentItem> => {
    if (!value || value === 'All') {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => node.status === value) };
  };

  const getSearchedData = (
    data: TableData<PaymentItem>,
    value?: string,
  ): TableData<PaymentItem> => {
    if (!value) {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => node.paymentId.includes(value)) };
  };

  const getMethodFilterData = (
    data: TableData<PaymentItem>,
    value?: string,
  ): TableData<PaymentItem> => {
    if (!value) {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => node.method.key === value) };
  };

  const getFilterRangeData = (
    data: TableData<PaymentItem>,
    value?: DatesRangeValue,
  ): TableData<PaymentItem> => {
    if (!value?.[0]) {
      return { nodes: data.nodes };
    }
    return {
      nodes: data.nodes.filter((node) => {
        if (!value?.[0] || !value?.[1]) return false;
        return node.date >= value[0] && node.date <= value[1];
      }),
    };
  };

  const applyAllFilters = (
    quickFilter: string,
    search: string | undefined,
    method: string | undefined,
    dateRange: DatesRangeValue | undefined,
  ) => {
    const quickFilterData = getQuickFilterData(data, quickFilter);
    const searchValueData = getSearchedData(quickFilterData, search);
    const methodFilterData = getMethodFilterData(searchValueData, method);
    const dateRangeFilterData = getFilterRangeData(methodFilterData, dateRange);
    setListViewTableData(dateRangeFilterData);
  };

  const handleSearchChange = (value?: string): void => {
    setSearchValue(value);
    applyAllFilters(selectedQuickFilter, value, methodFilter, filterDateRange);
  };

  const handleSearchClear = (): void => {
    setSearchValue('');
    applyAllFilters(selectedQuickFilter, '', methodFilter, filterDateRange);
  };

  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint({
    breakpoints: theme.breakpoints,
  });
  const isMobile = matchedDeviceType === 'mobile';

  return (
    <Box height="100%">
      {isMobile && (
        <SearchInput
          label=""
          value={searchValue}
          placeholder="Search for Payment ID"
          onChange={({ value }) => handleSearchChange(value)}
          onClearButtonClick={handleSearchClear}
        />
      )}
      <ListView>
        <ListViewFilters
          quickFilters={
            <QuickFilterGroup
              selectionType="single"
              onChange={({ values }) => {
                const value = values[0];
                setSelectedQuickFilter(value);
                applyAllFilters(value, searchValue, methodFilter, filterDateRange);
              }}
              defaultValue="All"
              value={selectedQuickFilter}
            >
              {quickFilters.map((status) => (
                <QuickFilter
                  key={status}
                  title={status}
                  value={status}
                  trailing={<Counter value={getQuickFilterValueCount(status)} color="neutral" />}
                />
              ))}
            </QuickFilterGroup>
          }
          selectedFiltersCount={
            (methodFilter ? 1 : 0) +
            (Array.isArray(filterDateRange) && filterDateRange[0] ? 1 : 0) +
            (selectedQuickFilter !== 'All' ? 1 : 0)
          }
          actions={
            !isMobile && (
              <Box width="208px">
                <SearchInput
                  label=""
                  value={searchValue}
                  placeholder="Search for Payment ID"
                  onChange={({ value }) => handleSearchChange(value)}
                  onClearButtonClick={handleSearchClear}
                />
              </Box>
            )
          }
        >
          <FilterChipGroup
            onClearButtonClick={() => {
              setMethodFilter(undefined);
              setFilterDateRange(undefined);
              setSelectedQuickFilter('All');
              applyAllFilters('All', searchValue, undefined, undefined);
            }}
          >
            <Dropdown selectionType="single">
              <FilterChipSelectInput
                label="Method"
                value={methodFilter}
                onChange={({ values }) => {
                  const value = values[0];
                  setMethodFilter(value);
                  applyAllFilters(selectedQuickFilter, searchValue, value, filterDateRange);
                }}
                onClearButtonClick={() => {
                  setMethodFilter(undefined);
                  applyAllFilters(selectedQuickFilter, searchValue, undefined, filterDateRange);
                }}
              />
              <DropdownOverlay>
                <ActionList>
                  {MethodFilterValues.map((method) => (
                    <ActionListItem key={method.key} title={method.title} value={method.key} />
                  ))}
                </ActionList>
              </DropdownOverlay>
            </Dropdown>

            <FilterChipDatePicker
              label="Date Range"
              selectionType="range"
              value={filterDateRange}
              onChange={(value) => {
                const dateRange = Array.isArray(value) ? value : undefined;
                setFilterDateRange(dateRange);
                applyAllFilters(selectedQuickFilter, searchValue, methodFilter, dateRange);
              }}
              onClearButtonClick={() => {
                setFilterDateRange(undefined);
                applyAllFilters(selectedQuickFilter, searchValue, methodFilter, undefined);
              }}
            />

            <Dropdown selectionType="single">
              <FilterChipSelectInput
                label="Status"
                value={selectedQuickFilter !== 'All' ? selectedQuickFilter : undefined}
                onChange={({ values }) => {
                  const value = values[0] || 'All';
                  setSelectedQuickFilter(value);
                  applyAllFilters(value, searchValue, methodFilter, filterDateRange);
                }}
                onClearButtonClick={() => {
                  setSelectedQuickFilter('All');
                  applyAllFilters('All', searchValue, methodFilter, filterDateRange);
                }}
              />
              <DropdownOverlay>
                <ActionList>
                  {filterChipQuickFilters.map((status) => (
                    <ActionListItem
                      key={status}
                      title={status}
                      value={status}
                      isSelected={selectedQuickFilter === status}
                    />
                  ))}
                </ActionList>
              </DropdownOverlay>
            </Dropdown>
          </FilterChipGroup>
        </ListViewFilters>

        <Table
          data={listViewTableData}
          defaultSelectedIds={['1', '3']}
          onSelectionChange={(selectedItems) => {
            console.log('Selected items:', selectedItems);
          }}
          isFirstColumnSticky
          selectionType="multiple"
          pagination={
            <TablePagination
              onPageChange={console.log}
              defaultPageSize={10}
              onPageSizeChange={console.log}
              showPageSizePicker
              showPageNumberSelector
            />
          }
        >
          {(tableData) => (
            <>
              <TableHeader>
                <TableHeaderRow>
                  <TableHeaderCell headerKey="PAYMENT_ID">Payment ID</TableHeaderCell>
                  <TableHeaderCell headerKey="AMOUNT">Amount</TableHeaderCell>
                  <TableHeaderCell headerKey="ACCOUNT">Account</TableHeaderCell>
                  <TableHeaderCell headerKey="DATE">Date</TableHeaderCell>
                  <TableHeaderCell headerKey="METHOD">Method</TableHeaderCell>
                  <TableHeaderCell headerKey="STATUS">Status</TableHeaderCell>
                </TableHeaderRow>
              </TableHeader>
              <TableBody>
                {tableData.map((tableItem, index) => (
                  <TableRow
                    key={tableItem.id}
                    item={tableItem}
                    hoverActions={
                      <>
                        <Button
                          variant="tertiary"
                          size="xsmall"
                          onClick={() => console.log('View details:', tableItem.id)}
                        >
                          View Details
                        </Button>
                        <IconButton
                          icon={CheckIcon}
                          isHighlighted
                          accessibilityLabel={`Approve payment ${tableItem.paymentId}`}
                          onClick={() => console.log('Approved:', tableItem.id)}
                        />
                        <IconButton
                          icon={CloseIcon}
                          isHighlighted
                          accessibilityLabel={`Reject payment ${tableItem.paymentId}`}
                          onClick={() => console.log('Rejected:', tableItem.id)}
                        />
                      </>
                    }
                    onClick={() => console.log('Row clicked:', tableItem.id)}
                  >
                    <TableCell>
                      <Code size="small">{tableItem.paymentId}</Code>
                    </TableCell>
                    <TableEditableCell
                      accessibilityLabel={`Edit amount for payment ${tableItem.paymentId}`}
                      placeholder="Enter amount"
                      successText="Amount updated successfully"
                      defaultValue={tableItem.amount.toString()}
                    />
                    <TableCell>
                      <Link size="small" color="neutral" target="_blank" href={`/`}>
                        {tableItem.account}
                      </Link>
                    </TableCell>
                    <TableCell>
                      {tableItem.date?.toLocaleDateString('en-IN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                      })}
                    </TableCell>
                    <TableCell>{tableItem.method.title}</TableCell>
                    <TableCell>
                      <Badge
                        size="xsmall"
                        color={
                          tableItem.status === 'Completed'
                            ? 'positive'
                            : tableItem.status === 'Pending'
                            ? 'notice'
                            : tableItem.status === 'Failed'
                            ? 'negative'
                            : 'primary'
                        }
                      >
                        {tableItem.status}
                      </Badge>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
              <TableFooter>
                <TableFooterRow>
                  <TableFooterCell>Total</TableFooterCell>
                  <TableFooterCell>
                    <Amount
                      value={listViewTableData.nodes.reduce((sum, item) => sum + item.amount, 0)}
                    />
                  </TableFooterCell>
                  <TableFooterCell>-</TableFooterCell>
                  <TableFooterCell>-</TableFooterCell>
                  <TableFooterCell>-</TableFooterCell>
                  <TableFooterCell>{listViewTableData.nodes.length} items</TableFooterCell>
                </TableFooterRow>
              </TableFooter>
            </>
          )}
        </Table>
      </ListView>
    </Box>
  );
}

export default BasicListViewExample;
```

### Multi-Select Quick Filters with Bulk Actions and Advanced Date Filtering

This comprehensive example shows ListView with multi-select quick filters, bulk operations, action buttons with tooltips, and advanced date range functionality including preset date ranges.

```tsx
import React, { useState } from 'react';
import dayjs from 'dayjs';
import {
  ListView,
  ListViewFilters,
  Table,
  TableHeader,
  TableHeaderRow,
  TableHeaderCell,
  TableBody,
  TableRow,
  TableCell,
  TableToolbar,
  TableToolbarActions,
  TablePagination,
  QuickFilterGroup,
  QuickFilter,
  FilterChipGroup,
  FilterChipSelectInput,
  FilterChipDatePicker,
  Dropdown,
  DropdownOverlay,
  ActionList,
  ActionListItem,
  Counter,
  Badge,
  Button,
  IconButton,
  Code,
  Amount,
  Box,
  Link,
  SearchInput,
  ButtonGroup,
  Tooltip,
  MoreVerticalIcon,
  DownloadIcon,
  ShareIcon,
  CopyIcon,
  TrashIcon,
  SelectInput,
} from '@razorpay/blade/components';
import type { TableData, DatesRangeValue, Identifier } from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';

// Using the same PaymentItem type and data from previous example
// ... (PaymentItem type, MethodFilterValues, nodes, data definitions)

type PaymentItem = {
  id: string;
  paymentId: string;
  amount: number;
  status: string;
  date: Date;
  type: string;
  method: {
    key: string;
    title: string;
  };
  bank: string;
  account: string;
  name: string;
};

const MethodFilterValues = [
  { key: 'bank-transfer', title: 'Bank Transfer' },
  { key: 'credit-card', title: 'Credit Card' },
  { key: 'paypal', title: 'PayPal' },
];

const nodes: PaymentItem[] = [
  ...Array.from({ length: 30 }, (_, i) => ({
    id: (i + 1).toString(),
    paymentId: `rzp${Math.floor(Math.random() * 1000000)}`,
    amount: Number((Math.random() * 10000).toFixed(2)),
    label: `Payment ${i + 1}`,
    status: ['Completed', 'Pending', 'Failed'][Math.floor(Math.random() * 3)],
    date: new Date(2025, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1),
    type: ['Payout', 'Refund'][Math.floor(Math.random() * 2)],
    method: MethodFilterValues[Math.floor(Math.random() * 3)],
    bank: ['HDFC', 'ICICI', 'SBI'][Math.floor(Math.random() * 3)],
    account: Math.floor(Math.random() * 1000000000).toString(),
    name: ['John Doe', 'Jane Doe', 'Bob Smith', 'Alice Smith'][Math.floor(Math.random() * 4)],
  })),
];

const data: TableData<PaymentItem> = { nodes };

const filterChipQuickFilters = ['Pending', 'Failed', 'Completed'];

function ComprehensiveListViewExample() {
  const [listViewTableData, setListViewTableData] = useState(data);
  const [selectedQuickFilter, setSelectedQuickFilter] = useState<string[]>([]);
  const [searchValue, setSearchValue] = useState<string | undefined>('');
  const [methodFilter, setMethodFilter] = useState<string | undefined>('');
  const [filterDateRange, setFilterDateRange] = useState<DatesRangeValue | undefined>(undefined);
  const [selectedIds, setSelectedIds] = useState<Identifier[]>([]);

  const getQuickFilterValueCount = (value: string): number => {
    if (value === 'All') {
      return data.nodes.length;
    }
    return data.nodes.filter((node) => node.status === value).length;
  };

  const getQuickFilterData = (
    data: TableData<PaymentItem>,
    values?: string[],
  ): TableData<PaymentItem> => {
    if (!values?.length) {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => values.includes(node.status)) };
  };

  const getSearchedData = (
    data: TableData<PaymentItem>,
    value?: string,
  ): TableData<PaymentItem> => {
    if (!value) {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => node.paymentId.includes(value)) };
  };

  const getMethodFilterData = (
    data: TableData<PaymentItem>,
    value?: string,
  ): TableData<PaymentItem> => {
    if (!value) {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => node.method.key === value) };
  };

  const getFilterRangeData = (
    data: TableData<PaymentItem>,
    value?: DatesRangeValue,
  ): TableData<PaymentItem> => {
    if (!value?.[0]) {
      return { nodes: data.nodes };
    }
    return {
      nodes: data.nodes.filter((node) => {
        if (!value?.[0] || !value?.[1]) return false;
        return node.date >= value[0] && node.date <= value[1];
      }),
    };
  };

  const getLastWeekDateRange = (): DatesRangeValue => {
    const lastWeek = new Date();
    lastWeek.setDate(lastWeek.getDate() - 7);
    return [lastWeek, new Date()];
  };

  const compareDateRangeValues = (
    dateRange1: DatesRangeValue,
    dateRange2: DatesRangeValue,
  ): boolean => {
    if (!dateRange1?.[0] || !dateRange2?.[0]) {
      return false;
    }
    return (
      dayjs(dateRange1[0]).isSame(dayjs(dateRange2[0]), 'day') &&
      dayjs(dateRange1[1]).isSame(dayjs(dateRange2[1]), 'day')
    );
  };

  const applyAllFilters = (
    quickFilters: string[],
    search: string | undefined,
    method: string | undefined,
    dateRange: DatesRangeValue | undefined,
  ) => {
    const quickFilterData = getQuickFilterData(data, quickFilters);
    const searchValueData = getSearchedData(quickFilterData, search);
    const methodFilterData = getMethodFilterData(searchValueData, method);
    const dateRangeFilterData = getFilterRangeData(methodFilterData, dateRange);
    setListViewTableData(dateRangeFilterData);
  };

  const handleSearchChange = (value?: string): void => {
    setSearchValue(value);
    applyAllFilters(selectedQuickFilter, value, methodFilter, filterDateRange);
  };

  const handleSearchClear = (): void => {
    setSearchValue('');
    applyAllFilters(selectedQuickFilter, '', methodFilter, filterDateRange);
  };

  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint({
    breakpoints: theme.breakpoints,
  });
  const isMobile = matchedDeviceType === 'mobile';

  return (
    <Box height="100%">
      {isMobile && (
        <SearchInput
          label=""
          value={searchValue}
          placeholder="Search for Payment ID"
          onChange={({ value }) => handleSearchChange(value)}
          onClearButtonClick={handleSearchClear}
        />
      )}
      <ListView>
        <ListViewFilters
          selectedFiltersCount={
            (methodFilter ? 1 : 0) +
            (Array.isArray(filterDateRange) && filterDateRange[0] ? 1 : 0) +
            (selectedQuickFilter.filter((filter) => filter !== 'LastWeek').length !== 0 ? 1 : 0)
          }
          quickFilters={
            <QuickFilterGroup
              selectionType="multiple"
              onChange={({ values }) => {
                const lastWeekDateRange = getLastWeekDateRange();
                const shouldChangeValue = values.includes('LastWeek');

                if (!shouldChangeValue) {
                  const rangeToUse = compareDateRangeValues(lastWeekDateRange, filterDateRange!)
                    ? undefined
                    : filterDateRange;

                  setFilterDateRange(rangeToUse);
                  setSelectedQuickFilter(values.filter((value) => value !== 'LastWeek'));
                  applyAllFilters(
                    values.filter((value) => value !== 'LastWeek'),
                    searchValue,
                    methodFilter,
                    rangeToUse,
                  );
                } else {
                  setFilterDateRange(lastWeekDateRange);
                  setSelectedQuickFilter(values);
                  applyAllFilters(
                    values.filter((value) => value !== 'LastWeek'),
                    searchValue,
                    methodFilter,
                    lastWeekDateRange,
                  );
                }
              }}
              value={selectedQuickFilter}
            >
              {filterChipQuickFilters.map((status) => (
                <QuickFilter
                  key={status}
                  title={status}
                  value={status}
                  trailing={<Counter value={getQuickFilterValueCount(status)} color="neutral" />}
                />
              ))}
              <QuickFilter title="Last Week" value="LastWeek" />
            </QuickFilterGroup>
          }
          actions={
            <Box display="flex" gap="spacing.4" alignItems="center">
              {!isMobile && (
                <Box width="280px">
                  <SearchInput
                    label=""
                    value={searchValue}
                    placeholder="Search for Payment ID"
                    onChange={({ value }) => handleSearchChange(value)}
                    onClearButtonClick={handleSearchClear}
                    trailing={
                      <Dropdown selectionType="single">
                        <SelectInput label="" placeholder="Filter by method" labelPosition="top" />
                        <DropdownOverlay>
                          <ActionList>
                            <ActionListItem title="All Methods" value="all" />
                            <ActionListItem title="Bank Transfer" value="bank" />
                            <ActionListItem title="Credit Card" value="card" />
                            <ActionListItem title="UPI" value="upi" />
                          </ActionList>
                        </DropdownOverlay>
                      </Dropdown>
                    }
                  />
                </Box>
              )}
              <ButtonGroup variant="tertiary">
                <Tooltip content="More options">
                  <Button icon={MoreVerticalIcon} />
                </Tooltip>
                <Tooltip content="Download data">
                  <Button icon={DownloadIcon} />
                </Tooltip>
                <Tooltip content="Share">
                  <Button icon={ShareIcon} />
                </Tooltip>
              </ButtonGroup>
            </Box>
          }
        >
          <FilterChipGroup
            onClearButtonClick={() => {
              setMethodFilter(undefined);
              setFilterDateRange(undefined);
              setSelectedQuickFilter([]);
              const searchValueData = getSearchedData(data, searchValue);
              setListViewTableData(searchValueData);
            }}
          >
            <Dropdown selectionType="single">
              <FilterChipSelectInput
                label="Method"
                value={methodFilter}
                onChange={({ values }) => {
                  const value = values[0];
                  setMethodFilter(value);
                  applyAllFilters(selectedQuickFilter, searchValue, value, filterDateRange);
                }}
                onClearButtonClick={() => {
                  setMethodFilter(undefined);
                  applyAllFilters(selectedQuickFilter, searchValue, undefined, filterDateRange);
                }}
              />
              <DropdownOverlay>
                <ActionList>
                  {MethodFilterValues.map((method) => (
                    <ActionListItem key={method.key} title={method.title} value={method.key} />
                  ))}
                </ActionList>
              </DropdownOverlay>
            </Dropdown>

            <FilterChipDatePicker
              label="Date Range"
              selectionType="range"
              value={filterDateRange}
              onChange={(value) => {
                const dateRange = Array.isArray(value) ? value : undefined;
                setFilterDateRange(dateRange);
                applyAllFilters(selectedQuickFilter, searchValue, methodFilter, dateRange);
              }}
              onClearButtonClick={() => {
                const quickFilters = selectedQuickFilter.filter((value) => value !== 'LastWeek');
                setFilterDateRange(undefined);
                setSelectedQuickFilter(quickFilters);
                applyAllFilters(quickFilters, searchValue, methodFilter, undefined);
              }}
            />

            <Dropdown selectionType="multiple">
              <FilterChipSelectInput
                label="Status"
                value={selectedQuickFilter.filter((filters) => filters !== 'LastWeek')}
                onChange={({ values }) => {
                  setSelectedQuickFilter((prev) => [
                    ...prev.filter((filter) => filter === 'LastWeek'),
                    ...values,
                  ]);
                  applyAllFilters(values, searchValue, methodFilter, filterDateRange);
                }}
                onClearButtonClick={() => {
                  setSelectedQuickFilter((prev) => prev.filter((filter) => filter === 'LastWeek'));
                  applyAllFilters([], searchValue, methodFilter, filterDateRange);
                }}
              />
              <DropdownOverlay>
                <ActionList>
                  {filterChipQuickFilters.map((status) => (
                    <ActionListItem
                      key={status}
                      title={status}
                      value={status}
                      isSelected={selectedQuickFilter.includes(status)}
                    />
                  ))}
                </ActionList>
              </DropdownOverlay>
            </Dropdown>
          </FilterChipGroup>
        </ListViewFilters>

        <Table
          data={listViewTableData}
          onSelectionChange={({ selectedIds }) => {
            setSelectedIds(selectedIds);
          }}
          isFirstColumnSticky
          selectionType="multiple"
          rowDensity="compact"
          pagination={
            <TablePagination
              onPageChange={console.log}
              defaultPageSize={10}
              onPageSizeChange={console.log}
              showPageSizePicker
              showPageNumberSelector
            />
          }
          toolbar={
            selectedIds.length > 0 ? (
              <TableToolbar placement="overlay" title={`${selectedIds.length} selected`}>
                <TableToolbarActions>
                  <Box
                    width="100%"
                    justifyContent="end"
                    display="flex"
                    alignItems="center"
                    gap="spacing.4"
                  >
                    <Link size="small" icon={CopyIcon}>
                      Copy
                    </Link>
                    <Link size="small" icon={TrashIcon}>
                      Delete
                    </Link>
                  </Box>
                </TableToolbarActions>
              </TableToolbar>
            ) : undefined
          }
        >
          {(tableData) => (
            <>
              <TableHeader>
                <TableHeaderRow>
                  <TableHeaderCell headerKey="PAYMENT_ID">Payment ID</TableHeaderCell>
                  <TableHeaderCell headerKey="AMOUNT">Amount</TableHeaderCell>
                  <TableHeaderCell headerKey="DATE">Date</TableHeaderCell>
                  <TableHeaderCell headerKey="METHOD">Method</TableHeaderCell>
                  <TableHeaderCell headerKey="STATUS">Status</TableHeaderCell>
                </TableHeaderRow>
              </TableHeader>
              <TableBody>
                {tableData.map((tableItem) => (
                  <TableRow key={tableItem.id} item={tableItem}>
                    <TableCell>
                      <Code size="small">{tableItem.paymentId}</Code>
                    </TableCell>
                    <TableCell>
                      <Amount value={tableItem.amount} />
                    </TableCell>
                    <TableCell>
                      {tableItem.date?.toLocaleDateString('en-IN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                      })}
                    </TableCell>
                    <TableCell>{tableItem.method.title}</TableCell>
                    <TableCell>
                      <Badge
                        size="xsmall"
                        color={
                          tableItem.status === 'Completed'
                            ? 'positive'
                            : tableItem.status === 'Pending'
                            ? 'notice'
                            : tableItem.status === 'Failed'
                            ? 'negative'
                            : 'primary'
                        }
                      >
                        {tableItem.status}
                      </Badge>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </>
          )}
        </Table>
      </ListView>
    </Box>
  );
}

export default ComprehensiveListViewExample;
```

### Minimal ListView without Search

This example demonstrates a ListView implementation focused on filtering without search functionality, ideal for simpler data presentation needs.

```tsx
import React, { useState } from 'react';
import {
  ListView,
  ListViewFilters,
  Table,
  TableHeader,
  TableHeaderRow,
  TableHeaderCell,
  TableBody,
  TableRow,
  TableCell,
  TableFooter,
  TableFooterRow,
  TableFooterCell,
  TablePagination,
  QuickFilterGroup,
  QuickFilter,
  FilterChipGroup,
  FilterChipSelectInput,
  FilterChipDatePicker,
  Dropdown,
  DropdownOverlay,
  ActionList,
  ActionListItem,
  Counter,
  Badge,
  Code,
  Amount,
  Box,
} from '@razorpay/blade/components';
import type { TableData, DatesRangeValue } from '@razorpay/blade/components';

// Using the same PaymentItem type and data from previous examples
// ... (PaymentItem type, MethodFilterValues, nodes, data definitions)

type PaymentItem = {
  id: string;
  paymentId: string;
  amount: number;
  status: string;
  date: Date;
  type: string;
  method: {
    key: string;
    title: string;
  };
  bank: string;
  account: string;
  name: string;
};

const MethodFilterValues = [
  { key: 'bank-transfer', title: 'Bank Transfer' },
  { key: 'credit-card', title: 'Credit Card' },
  { key: 'paypal', title: 'PayPal' },
];

const quickFilters = ['All', 'Pending', 'Failed', 'Completed'];

const nodes: PaymentItem[] = [
  ...Array.from({ length: 30 }, (_, i) => ({
    id: (i + 1).toString(),
    paymentId: `rzp${Math.floor(Math.random() * 1000000)}`,
    amount: Number((Math.random() * 10000).toFixed(2)),
    label: `Payment ${i + 1}`,
    status: ['Completed', 'Pending', 'Failed'][Math.floor(Math.random() * 3)],
    date: new Date(2025, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1),
    type: ['Payout', 'Refund'][Math.floor(Math.random() * 2)],
    method: MethodFilterValues[Math.floor(Math.random() * 3)],
    bank: ['HDFC', 'ICICI', 'SBI'][Math.floor(Math.random() * 3)],
    account: Math.floor(Math.random() * 1000000000).toString(),
    name: ['John Doe', 'Jane Doe', 'Bob Smith', 'Alice Smith'][Math.floor(Math.random() * 4)],
  })),
];

const data: TableData<PaymentItem> = { nodes };

function MinimalListViewExample() {
  const [listViewTableData, setListViewTableData] = useState(data);
  const [selectedQuickFilter, setSelectedQuickFilter] = useState<string>('All');
  const [methodFilter, setMethodFilter] = useState<string | undefined>(undefined);
  const [filterDateRange, setFilterDateRange] = useState<DatesRangeValue | undefined>(undefined);

  const getQuickFilterValueCount = (value: string): number => {
    if (value === 'All') {
      return data.nodes.length;
    }
    return data.nodes.filter((node) => node.status === value).length;
  };

  const getQuickFilterData = (
    data: TableData<PaymentItem>,
    value?: string,
  ): TableData<PaymentItem> => {
    if (!value || value === 'All') {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => node.status === value) };
  };

  const getMethodFilterData = (
    data: TableData<PaymentItem>,
    value?: string,
  ): TableData<PaymentItem> => {
    if (!value) {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => node.method.key === value) };
  };

  const getFilterRangeData = (
    data: TableData<PaymentItem>,
    value?: DatesRangeValue,
  ): TableData<PaymentItem> => {
    if (!value?.[0]) {
      return { nodes: data.nodes };
    }
    return {
      nodes: data.nodes.filter((node) => {
        if (!value?.[0] || !value?.[1]) return false;
        return node.date >= value[0] && node.date <= value[1];
      }),
    };
  };

  const applyAllFilters = (
    quickFilter: string,
    method: string | undefined,
    dateRange: DatesRangeValue | undefined,
  ) => {
    const quickFilterData = getQuickFilterData(data, quickFilter);
    const methodFilterData = getMethodFilterData(quickFilterData, method);
    const dateRangeFilterData = getFilterRangeData(methodFilterData, dateRange);
    setListViewTableData(dateRangeFilterData);
  };

  return (
    <Box height="100%">
      <ListView>
        <ListViewFilters
          selectedFiltersCount={
            (methodFilter ? 1 : 0) +
            (Array.isArray(filterDateRange) && filterDateRange[0] ? 1 : 0) +
            (selectedQuickFilter !== 'All' ? 1 : 0)
          }
          quickFilters={
            <QuickFilterGroup
              selectionType="single"
              onChange={({ values }) => {
                const value = values[0];
                setSelectedQuickFilter(value);
                applyAllFilters(value, methodFilter, filterDateRange);
              }}
              defaultValue="All"
              value={selectedQuickFilter}
            >
              {quickFilters.map((status) => (
                <QuickFilter
                  key={status}
                  title={status}
                  value={status}
                  trailing={<Counter value={getQuickFilterValueCount(status)} color="neutral" />}
                />
              ))}
            </QuickFilterGroup>
          }
        >
          <FilterChipGroup
            onClearButtonClick={() => {
              setMethodFilter(undefined);
              setFilterDateRange(undefined);
              setSelectedQuickFilter('All');
              setListViewTableData(data);
            }}
          >
            <Dropdown selectionType="single">
              <FilterChipSelectInput
                label="Payment Method"
                value={methodFilter}
                onChange={({ values }) => {
                  const value = values[0];
                  setMethodFilter(value);
                  applyAllFilters(selectedQuickFilter, value, filterDateRange);
                }}
                onClearButtonClick={() => {
                  setMethodFilter(undefined);
                  applyAllFilters(selectedQuickFilter, undefined, filterDateRange);
                }}
              />
              <DropdownOverlay>
                <ActionList>
                  {MethodFilterValues.map((method) => (
                    <ActionListItem key={method.key} title={method.title} value={method.key} />
                  ))}
                </ActionList>
              </DropdownOverlay>
            </Dropdown>

            <FilterChipDatePicker
              label="Transaction Date"
              selectionType="range"
              value={filterDateRange}
              onChange={(value) => {
                const dateRange = Array.isArray(value) ? value : undefined;
                setFilterDateRange(dateRange);
                applyAllFilters(selectedQuickFilter, methodFilter, dateRange);
              }}
              onClearButtonClick={() => {
                setFilterDateRange(undefined);
                applyAllFilters(selectedQuickFilter, methodFilter, undefined);
              }}
            />
          </FilterChipGroup>
        </ListViewFilters>

        <Table
          data={listViewTableData}
          selectionType="single"
          onSelectionChange={(selectedItems) => {
            console.log('Selected item:', selectedItems);
          }}
          isFirstColumnSticky
        >
          {(tableData) => (
            <>
              <TableHeader>
                <TableHeaderRow>
                  <TableHeaderCell headerKey="PAYMENT_ID">Payment ID</TableHeaderCell>
                  <TableHeaderCell headerKey="AMOUNT">Amount</TableHeaderCell>
                  <TableHeaderCell headerKey="DATE">Date</TableHeaderCell>
                  <TableHeaderCell headerKey="METHOD">Method</TableHeaderCell>
                  <TableHeaderCell headerKey="STATUS">Status</TableHeaderCell>
                </TableHeaderRow>
              </TableHeader>
              <TableBody>
                {tableData.map((tableItem) => (
                  <TableRow
                    key={tableItem.id}
                    item={tableItem}
                    onClick={() => console.log('Row selected:', tableItem.id)}
                  >
                    <TableCell>
                      <Code size="small">{tableItem.paymentId}</Code>
                    </TableCell>
                    <TableCell>
                      <Amount value={tableItem.amount} />
                    </TableCell>
                    <TableCell>
                      {tableItem.date?.toLocaleDateString('en-IN', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                      })}
                    </TableCell>
                    <TableCell>{tableItem.method.title}</TableCell>
                    <TableCell>
                      <Badge
                        size="xsmall"
                        color={
                          tableItem.status === 'Completed'
                            ? 'positive'
                            : tableItem.status === 'Pending'
                            ? 'notice'
                            : tableItem.status === 'Failed'
                            ? 'negative'
                            : 'primary'
                        }
                      >
                        {tableItem.status}
                      </Badge>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
              <TableFooter>
                <TableFooterRow>
                  <TableFooterCell>Total Transactions</TableFooterCell>
                  <TableFooterCell>
                    <Amount
                      value={listViewTableData.nodes.reduce((sum, item) => sum + item.amount, 0)}
                    />
                  </TableFooterCell>
                  <TableFooterCell>-</TableFooterCell>
                  <TableFooterCell>-</TableFooterCell>
                  <TableFooterCell>{listViewTableData.nodes.length} items</TableFooterCell>
                </TableFooterRow>
              </TableFooter>
            </>
          )}
        </Table>
      </ListView>
    </Box>
  );
}

export default MinimalListViewExample;
```

---

## Settings

# Settings Pattern

## Description

The Settings pattern provides a comprehensive interface for managing application configurations and user preferences. It combines a responsive navigation system (TopNav + SideNav) with a grid-based overview page displaying categorized settings cards and detailed settings pages. This pattern is ideal for applications that need to manage multiple configuration areas while maintaining a consistent and accessible user experience across different screen sizes.

## Components Used

- Box
- Card
- SideNav
- TopNav
- TabNav
- Menu
- Button
- IconButton
- Link
- Text
- Heading
- Badge
- Avatar
- Switch
- SearchInput
- Indicator
- ProgressBar

## Settings Overview

The Settings Overview provides a comprehensive view of all configurable aspects of the application. It presents settings categories in a grid layout using cards, each with its own visual identity and quick access links.

### Features

1. **Grid Layout**
   - Responsive grid that adapts to different screen sizes
   - Cards for different setting categories
   - Visual hierarchy with icons and illustrations

2. **Category Cards**
   - Consistent card design with title and description
   - Quick access links to specific settings
   - Visual illustrations for each category
   - Background gradient effects for visual appeal

3. **Categories Covered** (these are examples, they may change based on the application)
   - User Profile
   - Business Profile
   - Integrations
   - Payments
   - Bank Account & Settlements
   - Team Management

### Example

```tsx
import React, { useState } from 'react';
import { BrowserRouter, Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Card,
  CardBody,
  SideNav,
  SideNavBody,
  SideNavFooter,
  SideNavLink,
  SideNavSection,
  TopNav,
  TopNavBrand,
  TopNavContent,
  TopNavActions,
  TabNav,
  TabNavItems,
  TabNavItem,
  Menu,
  MenuHeader,
  MenuItem,
  MenuOverlay,
  Link,
  Text,
  Heading,
  Button,
  Avatar,
  Switch,
  SearchInput,
  Indicator,
  ProgressBar,
  HomeIcon,
  WalletIcon,
  CreditCardIcon,
  BankIcon,
  BillIcon,
  ArrowUpRightIcon,
  PlusIcon,
  SettingsIcon,
  ChevronRightIcon,
} from '@razorpay/blade/components';
import { useTheme, useBreakpoint } from '@razorpay/blade/utils';

// Settings Card Component for Overview Page
const SettingCard = ({
  title,
  description,
  links,
  assetImage,
}: {
  title: string;
  description: string;
  links: Array<{ label: string; link: string }>;
  assetImage: string;
}): React.ReactElement => {
  return (
    <Card
      height="285px"
      backgroundColor="surface.background.gray.intense"
      padding="spacing.0"
      borderRadius="medium"
      elevation="none"
    >
      <CardBody>
        <Box position="relative" height="285px" overflow="hidden" padding="spacing.7">
          <Box position="relative" zIndex="1">
            <Box display="flex" flexDirection="column" gap="spacing.7">
              <Box>
                <Heading
                  size="medium"
                  weight="semibold"
                  marginBottom="spacing.3"
                  color="surface.text.gray.normal"
                >
                  {title}
                </Heading>
                <Box minHeight="40px">
                  <Text weight="regular" color="surface.text.gray.muted">
                    {description}
                  </Text>
                </Box>
              </Box>
              <Box display="flex" flexDirection="column" gap="spacing.3">
                {links.map((link, index) => (
                  <RouterLink key={index} to={link.link}>
                    <Link color="primary" size="medium">
                      {link.label}
                    </Link>
                  </RouterLink>
                ))}
              </Box>
            </Box>
          </Box>
          <div
            style={{
              position: 'absolute',
              right: '-100px',
              bottom: '-70px',
              width: '249px',
              height: '249px',
              borderRadius: '50%',
              background:
                'radial-gradient(circle at center, hsla(206, 93%, 95%, 0.9) 0%, hsla(206, 93%, 95%, 0.8) 20%, hsla(209, 95%, 97%, 0.6) 40%, hsla(209, 95%, 97%, 0.4) 60%, hsla(0, 0%, 100%, 0.2) 80%, hsla(0, 0%, 100%, 0) 100%)',
              display: 'flex',
              alignItems: 'flex-start',
              justifyContent: 'center',
              paddingTop: '40px',
              overflow: 'hidden',
            }}
          >
            <img
              src={assetImage}
              alt={`${title} illustration`}
              style={{
                width: '138px',
                height: '138px',
                objectFit: 'contain',
                transform: 'translateX(-30%)',
              }}
            />
          </div>
        </Box>
      </CardBody>
    </Card>
  );
};

// Settings Navigation Component
const SettingsNavigation = (): React.ReactElement => {
  const [isMobileOpen, setIsMobileOpen] = useState(false);
  const [isTestMode, setIsTestMode] = useState(false);

  return (
    <SideNav
      isOpen={isMobileOpen}
      onDismiss={() => setIsMobileOpen(false)}
      banner={
        <Card href="/" padding="spacing.4" elevation="none">
          <CardBody>
            <Box display="flex" justifyContent="space-between" marginBottom="spacing.2">
              <Text size="medium" weight="semibold">
                Activation Pending
              </Text>
              <ChevronRightIcon />
            </Box>
            <ProgressBar
              label="Progress"
              showPercentage={true}
              value={50}
              accessibilityLabel="Activation progress: 50% complete"
            />
          </CardBody>
        </Card>
      }
    >
      <SideNavBody>
        <SideNavSection title="Main">
          <SideNavLink icon={HomeIcon} title="Dashboard" href="/dashboard" as={RouterLink} />
          <SideNavLink
            icon={WalletIcon}
            title="Payments"
            href="/payments"
            as={RouterLink}
            trailing={
              <Button
                icon={PlusIcon}
                size="xsmall"
                variant="tertiary"
                accessibilityLabel="Create new payment"
              />
            }
          />
        </SideNavSection>

        <SideNavSection title="Banking" maxVisibleItems={3}>
          <SideNavLink
            icon={CreditCardIcon}
            title="Credit Cards"
            href="/banking/cards"
            as={RouterLink}
          />
          <SideNavLink
            icon={BankIcon}
            title="Bank Accounts"
            href="/banking/accounts"
            as={RouterLink}
          />
          <SideNavLink
            icon={BillIcon}
            title="Statements"
            href="/banking/statements"
            as={RouterLink}
          />
          <SideNavLink
            icon={ArrowUpRightIcon}
            title="Transfers"
            href="/banking/transfers"
            as={RouterLink}
          />
        </SideNavSection>
      </SideNavBody>

      <SideNavFooter>
        <Box
          as="label"
          display="flex"
          alignItems="center"
          justifyContent="space-between"
          padding="spacing.4"
        >
          <Box display="flex" alignItems="center" gap="spacing.3">
            <Indicator
              color={isTestMode ? 'notice' : 'positive'}
              emphasis="intense"
              accessibilityLabel={isTestMode ? 'Test mode enabled' : 'Test mode disabled'}
            />
            <Text>Test Mode</Text>
          </Box>
          <Switch
            size="small"
            isChecked={isTestMode}
            onChange={({ isChecked }) => setIsTestMode(isChecked)}
            accessibilityLabel="Toggle test mode"
          />
        </Box>
        <SideNavLink
          icon={SettingsIcon}
          title="Settings"
          href="/settings"
          as={RouterLink}
          isActive
        />
      </SideNavFooter>
    </SideNav>
  );
};

// Main Settings Component
export const SettingsPage = (): React.ReactElement => {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  const settingsData = [
    {
      title: 'User profile',
      description: 'Manage your personal profile and security settings',
      links: [
        { label: 'Email & password', link: '/settings/profile' },
        { label: 'Two factor authentication', link: '/settings/security' },
        { label: 'Notifications', link: '/settings/notifications' },
      ],
      assetImage: '/assets/user-profile.png',
    },
    {
      title: 'Business profile',
      description: 'Configure your business details and preferences',
      links: [
        { label: 'Business details', link: '/settings/business' },
        { label: 'Branding', link: '/settings/branding' },
      ],
      assetImage: '/assets/business-profile.png',
    },
    {
      title: 'Team management',
      description: 'Manage team members and their permissions',
      links: [
        { label: 'Team members', link: '/settings/team' },
        { label: 'Roles & permissions', link: '/settings/roles' },
      ],
      assetImage: '/assets/team-management.png',
    },
  ];

  return (
    <BrowserRouter>
      <Box height="100vh" display="flex" flexDirection="column">
        <TopNav>
          <TopNavBrand>
            <img src="/logo.svg" alt="Company Logo" height={32} />
          </TopNavBrand>
          <TopNavContent>
            <TabNav
              items={[
                { title: 'Dashboard', icon: HomeIcon },
                { title: 'Payments', icon: WalletIcon, isActive: true },
                { title: 'Settings', icon: SettingsIcon },
              ]}
            >
              {({ items }) => {
                return (
                  <TabNavItems>
                    {items.map((item) => {
                      return (
                        <TabNavItem
                          key={item.title}
                          title={item.title}
                          icon={item.icon}
                          isActive={item.isActive}
                        />
                      );
                    })}
                  </TabNavItems>
                );
              }}
            </TabNav>
          </TopNavContent>
          <TopNavActions>
            <SearchInput placeholder="Search settings" accessibilityLabel="Search settings" />
            <Menu>
              <Avatar size="medium" name="John Doe" />
              <MenuOverlay>
                <MenuHeader title="Profile" />
                <MenuItem>Account settings</MenuItem>
                <MenuItem color="negative">Logout</MenuItem>
              </MenuOverlay>
            </Menu>
          </TopNavActions>
        </TopNav>

        <Box flex="1" display="flex">
          {!isMobile && (
            <Box width="240px">
              <SettingsNavigation />
            </Box>
          )}

          <Box
            flex="1"
            padding="spacing.6"
            backgroundColor="surface.background.gray.subtle"
            overflowY="auto"
          >
            <Box
              display="grid"
              gridTemplateColumns={{
                base: '1fr',
                m: 'repeat(2, 1fr)',
                l: 'repeat(3, 1fr)',
              }}
              gap="spacing.6"
            >
              {settingsData.map((setting, index) => (
                <SettingCard key={index} {...setting} />
              ))}
            </Box>
          </Box>
        </Box>
      </Box>
    </BrowserRouter>
  );
};
```

This implementation provides a user-friendly overview of all available settings categories while maintaining consistency with Blade's design system principles.

### Key Features

1. **Responsive Grid Layout**
   - Single column on mobile
   - Two columns on medium screens
   - Three columns on large screens
   - Consistent spacing between cards
   - Proper padding for container

2. **Card Design**
   - Fixed height for consistency
   - Clear visual hierarchy
   - Background gradient for visual interest
   - Proper spacing for content
   - Accessible link structure


The Settings page component demonstrates best practices for:
- Grid-based layouts
- Card-based UI design
- Visual hierarchy
- Navigation patterns
- Responsive design
- Accessibility
- Component composition

### Pattern Components

The Settings Overview pattern is composed of these  components  :

1. `SettingsLayout`: The main layout component that provides:
   - Responsive navigation with TopNav and SideNav
   - Mobile-friendly layout adjustments
   - Proper accessibility labeling for navigation items
   - Consistent spacing and container widths
   - Search functionality in the header
   - User menu integration

2. `SettingsOverview`: A grid-based overview page showing:
   - Categorized settings cards with consistent styling
   - Responsive grid layout (1/2/3 columns based on screen size)
   - Accessible navigation links to detail pages
   - Clear visual hierarchy with headings and descriptions
   - Visual illustrations and gradient backgrounds
   - Quick access links for common actions


3. Sub Components:
   - `SettingCard`: Card component for each settings category
   - `TopNavigation`: Navigation header with search and user menu
   - `SideNavigation`: Side navigation with sections and items

## Settings Detail

The Settings Detail pattern demonstrates how to structure individual settings pages that users navigate to from the main Settings overview. Using the User Profile settings as an example, this pattern shows how to organize detailed configuration options in a clear, accessible, and user-friendly manner.

### Features

1. **Page Structure**
   - Back navigation to main settings
   - Clear page title and context
   - Organized sections with descriptions
   - Consistent spacing and layout

2. **Form Layout**
   - Labeled form fields with proper alignment
   - Interactive elements (edit buttons, toggles)
   - Clear grouping of related settings
   - Responsive field layouts

3. **Section Organization**
   - Distinct sections for different setting types
   - Clear section headers with descriptions
   - Proper vertical spacing between sections
   - Consistent card styling

### Example

```tsx
import React from 'react';
import {
  Box,
  Card,
  CardBody,
  Heading,
  Text,
  Switch,
  IconButton,
  Link,
  EditIcon,
  ChevronLeftIcon,
} from '@razorpay/blade/components';
import type { BoxProps } from '@razorpay/blade/components';
import { useTheme, useBreakpoint } from '@razorpay/blade/utils';
import { Link as RouterLink } from 'react-router-dom';

// Helper component for displaying row values with optional edit button
const CardRowValueContainer = ({
  showEditItem,
  value,
}: {
  showEditItem: boolean;
  value: string;
}): React.ReactElement | null => {
  if (showEditItem) {
    return (
      <Box display="flex" flexDirection="row" gap="spacing.2" alignItems="center">
        <Text size="medium" weight="semibold" color="surface.text.gray.subtle">
          {value}
        </Text>
        <IconButton
          icon={EditIcon}
          size="medium"
          accessibilityLabel="Edit"
          onClick={() => {}}
        />
      </Box>
    );
  }

  return (
    <Text size="medium" weight="semibold" color="surface.text.gray.subtle">
      {value}
    </Text>
  );
};

// Component for consistent row layout
const CardRow = ({
  label,
  value,
  trailingElement,
  showEditIcon = false,
}: {
  label: string;
  value?: string;
  trailingElement?: React.ReactNode;
  showEditIcon?: boolean;
}): React.ReactElement => {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';
  
  return (
    <Box
      display="grid"
      gridTemplateColumns={isMobile ? '150px 1fr' : '250px 1fr'}
      alignItems="center"
    >
      <Text size="medium" weight="medium" color="surface.text.gray.muted">
        {label}
      </Text>
      {trailingElement ? (
        trailingElement
      ) : (
        <CardRowValueContainer showEditItem={showEditIcon} value={value ?? ''} />
      )}
    </Box>
  );
};

// Section card component for grouping related settings
const SubSectionCard = ({
  title,
  subtitle,
  children,
  marginTop = {
    xs: 'spacing.9',
    l: '64px',
  },
}: {
  title: string;
  subtitle: string;
  children: React.ReactNode;
  marginTop?: BoxProps['marginTop'];
}): React.ReactElement => {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';
  
  return (
    <Box display="flex" flexDirection="column" gap="spacing.5" marginTop={marginTop}>
      <Box display="flex" flexDirection="column" gap="spacing.2">
        <Heading size="medium" weight="semibold" color="surface.text.gray.normal">
          {title}
        </Heading>
        <Text size="medium" weight="regular" color="surface.text.gray.muted">
          {subtitle}
        </Text>
      </Box>
      <Card
        padding={isMobile ? 'spacing.5' : 'spacing.7'}
        backgroundColor="surface.background.gray.intense"
        elevation="none"
      >
        <CardBody>{children}</CardBody>
      </Card>
    </Box>
  );
};

// Example Settings Detail Page (User Profile)
export const SettingsDetailPage = (): React.ReactElement => {
  return (
    <Box
      display="flex"
      flexDirection="column"
      paddingX={{
        xs: 'spacing.5',
        l: 'spacing.10',
      }}
      width="100%"
      justifyContent="center"
      alignItems="center"
    >
      <Box
        width={{
          xs: '343px',
          m: '718px',
        }}
        marginBottom="spacing.9"
      >
        {/* Back Navigation */}
        <Box width="100%" height="40px" display="flex" justifyContent="flex-end" flexDirection="column">
          <Box marginBottom={{ xs: 'spacing.3', l: 'spacing.2' }}>
            <RouterLink to="/settings">
              <Link icon={ChevronLeftIcon} size="small">
                Back
              </Link>
            </RouterLink>
          </Box>
        </Box>

        {/* Page Title */}
        <Box display="flex" justifyContent="flex-start" width="100%">
          <Heading size="large" weight="semibold" color="surface.text.gray.normal">
            User Profile
          </Heading>
        </Box>

        {/* Settings Sections */}
        <Box
          width="100%"
          marginTop={{
            xs: 'spacing.7',
            l: 'spacing.8',
          }}
        >
          {/* Profile Details */}
          <SubSectionCard
            title="Profile details"
            subtitle="These are your personal, user-level details"
            marginTop="none"
          >
            <Box display="flex" flexDirection="column" gap="spacing.5">
              <CardRow label="Name" value="John Doe" />
              <CardRow label="User role" value="Owner" />
              <CardRow label="Email ID" value="john@example.com" showEditIcon />
              <CardRow label="Login password" value="**********" showEditIcon />
              <CardRow label="Phone number" value="+1 234 567 8900" showEditIcon />
            </Box>
          </SubSectionCard>

          {/* Two Factor Authentication */}
            <SubSectionCard
              title="Two factor authentication"
              subtitle="Secure your account by using a one-time verification code each time you log in"
            >
              <CardRow
                label="Two factor authentication"
                trailingElement={
                  <Switch accessibilityLabel="Toggle Two Factor Authentication" size="medium" />
                }
              />
            </SubSectionCard>
        

          {/* Notifications */}
         
            <SubSectionCard
              title="Notifications"
              subtitle="Receive notifications on your phone/email for any account related updates"
            >
              <Box display="flex" flexDirection="column" gap="spacing.5">
                <CardRow
                  label="Email"
                  trailingElement={
                    <Switch accessibilityLabel="Toggle Email Notifications" size="medium" />
                  }
                />
                <CardRow
                  label="Whatsapp"
                  trailingElement={
                    <Switch accessibilityLabel="Toggle Whatsapp Notifications" size="medium" />
                  }
                />
                <CardRow
                  label="SMS"
                  trailingElement={
                    <Switch accessibilityLabel="Toggle SMS Notifications" size="medium" />
                  }
                />
              </Box>
            </SubSectionCard>
        </Box>
      </Box>
    </Box>
  );
};

```

This implementation can be used as a template for creating other settings detail pages, ensuring consistency across the application while maintaining a user-friendly and accessible interface.

### Key Features

1. **Page Layout**
   - Centered content with responsive width
   - Clear back navigation
   - Prominent page title
   - Consistent section spacing

2. **Form Components**
   - Reusable `CardRow` for consistent field layout
   - `SubSectionCard` for section grouping
   - Interactive elements with proper accessibility
   - Responsive grid layouts

3. **Visual Hierarchy**
   - Clear section headings
   - Descriptive subtitles
   - Consistent typography
   - Proper spacing between elements


The Settings Detail page pattern demonstrates best practices for:
- Detailed settings organization
- Form layout and structure
- Responsive design
- Component composition
- Visual hierarchy

### Pattern Components

The Settings Detail pattern consists of these reusable components:

1. `SettingsDetail`: A detailed settings page demonstrating:
   - Form layout best practices with consistent spacing
   - Responsive input arrangements (grid-based layout)
   - Proper accessibility labeling for all interactive elements
   - Interactive elements (IconButton, Switch) with hover states
   - Clear section organization with cards and headings
   - Save action handling with proper feedback
   - Back navigation with proper routing

2. Sub Components:
   - `CardRow`: Consistent form field layout with label and value
   - `SubSectionCard`: Section grouping with headers and descriptions
   - `CardRowValueContainer`: Interactive field display with edit functionality

These components are designed to be reusable and customizable while maintaining consistency with Blade's design system principles. They can be used independently in other contexts where similar patterns are needed.

---

# COMPONENTS

> Individual component documentation with props, examples, and usage guidelines.

---

## Accordion

# Accordion

## Component Name

Accordion

## Description

An accordion is used to allow users to toggle between different content sections in a compact vertical stack. It provides an expandable and collapsible interface to show/hide content, improving space utilization and organizing related information in a hierarchical structure.

## Important Constraints

- `AccordionItem` only allows `AccordionItemHeader` as the first component and `AccordionItemBody` as the second component
- `showNumberPrefix` and `icon` props cannot be used together on the same accordion item

## TypeScript Types

Below are the component props types that Accordion and its subcomponents accept. These types define all the possible properties and configurations you can use when implementing Accordion components in your application.

```typescript
type AccordionVariantType = 'filled' | 'transparent';

type AccordionProps = {
  /**
   * Makes the passed item index expanded by default (uncontrolled)
   */
  defaultExpandedIndex?: number;

  /**
   * Expands the passed index (controlled), `-1` implies no expanded items
   */
  expandedIndex?: number;

  /**
   * Callback for change in any item's expanded state,
   * `-1` implies no expanded items
   */
  onExpandChange?: ({ expandedIndex }: { expandedIndex: number }) => void;

  /**
   * Adds numeric index at the beginning of items
   *
   * @default false
   */
  showNumberPrefix?: boolean;

  /**
   * Visual variant of AccordionItem
   *
   * @default transparent
   */
  variant?: AccordionVariantType;

  /**
   * Size of the Accordion
   *
   * @default large
   */
  size?: 'large' | 'medium';

  /**
   * maxWidth prop of Accordion
   *
   */
  maxWidth?: BoxProps['maxWidth'];

  /**
   * Accepts `AccordionItem` child nodes
   */
  children: React.ReactElement | React.ReactElement[];
} & TestID &
  StyledPropsBlade;

type AccordionItemProps = {
  /**
   * Title text content
   *
   * @deprecated Use AccordionItemHeader and AccordionItemBody
   */
  title?: string;

  /**
   * Body text content
   *
   * @deprecated Use AccordionItemHeader and AccordionItemBody
   */
  description?: string;

  /**
   * Renders a Blade icon as title prefix (requires `showNumberPrefix={false}`)
   *
   * @deprecated Use `leading={<StarIcon size="large" />}` on AccordionItemHeader instead
   */
  icon?: IconComponent;

  /**
   * Slot, renders any custom content
   */
  children?: ReactNode | ReactNode[];

  /**
   * Disabled state of the item
   *
   * @default false
   */
  isDisabled?: boolean;
} & TestID &
  DataAnalyticsAttribute;

// AccordionItemHeader props (derived from BaseHeaderProps)
type AccordionItemHeaderProps = Pick<
  BaseHeaderProps,
  'title' | 'subtitle' | 'leading' | 'children' | 'trailing' | 'titleSuffix'
> &
  DataAnalyticsAttribute;

// AccordionItemBody props
type AccordionItemBodyProps = {
  children?: React.ReactNode | StringChildrenType;
} & DataAnalyticsAttribute;
```

## Examples

### Basic Accordion

A simple accordion with default transparent variant and expandable items.

```tsx
import {
  Accordion,
  AccordionItem,
  AccordionItemHeader,
  AccordionItemBody,
} from '@razorpay/blade/components';

const BasicAccordionExample = () => {
  return (
    <Accordion>
      <AccordionItem>
        <AccordionItemHeader title="How can I setup Route?" />
        <AccordionItemBody>
          You can use Razorpay Route from the Dashboard or using APIs to transfer money to
          customers. You may also check our docs for detailed instructions.
        </AccordionItemBody>
      </AccordionItem>
      <AccordionItem>
        <AccordionItemHeader title="How can I setup QR Codes?" />
        <AccordionItemBody>
          Just use Razorpay. You may also check our docs for detailed instructions. Please use the
          search functionality to ask your queries.
        </AccordionItemBody>
      </AccordionItem>
      <AccordionItem>
        <AccordionItemHeader title="How can I setup Subscriptions?" />
        <AccordionItemBody>
          Just use Razorpay. You may also check our docs for detailed instructions. Please use the
          search functionality to ask your queries.
        </AccordionItemBody>
      </AccordionItem>
    </Accordion>
  );
};
```

### Accordion with Visual Variations

This example shows different visual variants of Accordion, including numbered prefixes, size options, and width customization.

```tsx
import {
  Accordion,
  AccordionItem,
  AccordionItemHeader,
  AccordionItemBody,
  Box,
} from '@razorpay/blade/components';

const AccordionVariantsExample = () => {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.6">
      {/* Accordion with numbered prefixes */}
      <Accordion
        showNumberPrefix={true}
        variant="transparent"
        size="large"
        maxWidth={{ base: '100%', s: '480px' }}
      >
        <AccordionItem>
          <AccordionItemHeader title="First item with numbered prefix" />
          <AccordionItemBody>Content for first item</AccordionItemBody>
        </AccordionItem>
        <AccordionItem>
          <AccordionItemHeader title="Second item with numbered prefix" />
          <AccordionItemBody>Content for second item</AccordionItemBody>
        </AccordionItem>
      </Accordion>

      {/* Filled variant with medium size */}
      <Accordion variant="filled" size="medium">
        <AccordionItem>
          <AccordionItemHeader title="Filled variant medium size" />
          <AccordionItemBody>This accordion uses filled variant with medium size</AccordionItemBody>
        </AccordionItem>
        <AccordionItem>
          <AccordionItemHeader title="Another filled variant item" />
          <AccordionItemBody>More content for the filled variant</AccordionItemBody>
        </AccordionItem>
      </Accordion>
    </Box>
  );
};
```

### Accordion with Rich Header Features

This example shows an accordion with various header features including icons, badges, and interactive elements.

```tsx
import {
  Accordion,
  AccordionItem,
  AccordionItemHeader,
  AccordionItemBody,
  Badge,
  Link,
} from '@razorpay/blade/components';
import { RoutesIcon, QRCodeIcon, SubscriptionsIcon } from '@razorpay/blade/components';

const RichHeaderAccordionExample = () => {
  return (
    <Accordion>
      <AccordionItem>
        <AccordionItemHeader
          leading={<RoutesIcon size="large" />}
          title="How can I setup Route?"
          subtitle="Subtitle for route setup"
          titleSuffix={<Badge>New</Badge>}
          trailing={
            <Link
              variant="button"
              onClick={(e) => {
                e.stopPropagation();
              }}
            >
              Apply
            </Link>
          }
        />
        <AccordionItemBody>
          You can use Razorpay Route from the Dashboard or using APIs to transfer money to
          customers. You may also check our docs for detailed instructions.
        </AccordionItemBody>
      </AccordionItem>
      <AccordionItem>
        <AccordionItemHeader
          leading={<QRCodeIcon size="large" />}
          title="How can I setup QR Codes?"
        />
        <AccordionItemBody>
          Just use Razorpay. You may also check our docs for detailed instructions.
        </AccordionItemBody>
      </AccordionItem>
      <AccordionItem isDisabled={true}>
        <AccordionItemHeader
          leading={<SubscriptionsIcon size="large" color="surface.icon.gray.disabled" />}
          title="How can I setup Subscriptions?"
          subtitle="This item is disabled"
        />
        <AccordionItemBody>This item is disabled and cannot be expanded.</AccordionItemBody>
      </AccordionItem>
    </Accordion>
  );
};
```

### Controlled Accordion

An example of a controlled accordion where expansion state is managed externally.

```tsx
import { useState } from 'react';
import {
  Accordion,
  AccordionItem,
  AccordionItemHeader,
  AccordionItemBody,
  Box,
  Button,
} from '@razorpay/blade/components';
import { AnnouncementIcon, RoutesIcon } from '@razorpay/blade/components';

const ControlledAccordionExample = () => {
  // State for controlled accordion
  const [expandedIndex, setExpandedIndex] = useState(-1);

  return (
    <Box>
      <Box
        display="flex"
        flexDirection="row"
        gap="spacing.4"
        marginBottom="spacing.6"
        flexWrap="wrap"
      >
        <Button onClick={() => setExpandedIndex(0)}>Expand First</Button>
        <Button onClick={() => setExpandedIndex(1)}>Expand Second</Button>
        <Button onClick={() => setExpandedIndex(-1)}>Collapse All</Button>
      </Box>

      <Accordion
        expandedIndex={expandedIndex}
        onExpandChange={({ expandedIndex }) => setExpandedIndex(expandedIndex)}
      >
        <AccordionItem>
          <AccordionItemHeader
            leading={<AnnouncementIcon size="large" />}
            title="Controlled Item 1"
            subtitle="This is controlled by external state"
          />
          <AccordionItemBody>Content for controlled item 1</AccordionItemBody>
        </AccordionItem>
        <AccordionItem>
          <AccordionItemHeader
            leading={<RoutesIcon size="large" />}
            title="Controlled Item 2"
            subtitle="This is also controlled by external state"
          />
          <AccordionItemBody>Content for controlled item 2</AccordionItemBody>
        </AccordionItem>
      </Accordion>
    </Box>
  );
};
```

### Accordion with Custom Content

This example shows how to use custom content in both header and body of accordion items.

```tsx
import {
  Accordion,
  AccordionItem,
  AccordionItemHeader,
  AccordionItemBody,
  Box,
  Text,
  Indicator,
  Alert,
  TextInput,
  Button,
  UserIcon,
} from '@razorpay/blade/components';
import { useState } from 'react';

const CustomContentAccordionExample = () => {
  const [isAlertVisible, setIsAlertVisible] = useState(true);

  return (
    <Accordion maxWidth={{ base: '100%', s: '480px' }}>
      {/* Custom header content */}
      <AccordionItem>
        <AccordionItemHeader>
          <Box>
            <Text size="large" color="surface.text.gray.muted">
              #8218851
            </Text>
            <Text marginY="spacing.2" size="large" weight="semibold">
              Transactions and settlement related
            </Text>
            <Box display="flex" flexDirection="row" gap="spacing.3">
              <Indicator size="medium" color="information">
                In Progress
              </Indicator>
              <Box display="flex" alignItems="center" flexDirection="row" gap="spacing.2">
                <UserIcon size="medium" color="surface.icon.gray.subtle" />
                <Text size="medium" color="surface.text.gray.subtle">
                  Merchant Risk
                </Text>
              </Box>
            </Box>
          </Box>
        </AccordionItemHeader>
        <AccordionItemBody>
          <TextInput label="Additional Information" placeholder="Enter details here" />
          <Button marginTop="spacing.4">Submit</Button>
        </AccordionItemBody>
      </AccordionItem>

      {/* Custom body content with conditional rendering */}
      <AccordionItem>
        <AccordionItemHeader title="Item with interactive body content" />
        <AccordionItemBody>
          <Text color="surface.text.gray.subtle" marginBottom="spacing.4">
            You can use Razorpay services as described in the documentation.
          </Text>

          {isAlertVisible && (
            <Alert
              title="Custom slot"
              description="You can render anything here along with description"
              onDismiss={() => setIsAlertVisible(false)}
            />
          )}
        </AccordionItemBody>
      </AccordionItem>
    </Accordion>
  );
};
```

### Payment Method Selection Example

A real-world example showing how to use Accordion for payment method selection.

```tsx
import {
  Accordion,
  AccordionItem,
  AccordionItemHeader,
  AccordionItemBody,
  Box,
  TextInput,
  Button,
  Badge,
} from '@razorpay/blade/components';

const PaymentMethodsAccordion = () => {
  return (
    <Box maxWidth={{ base: '100%', s: '480px' }}>
      <Accordion variant="filled" defaultExpandedIndex={0}>
        <AccordionItem>
          <AccordionItemHeader title="UPI Payment" subtitle="Pay directly from your bank account" />
          <AccordionItemBody>
            <TextInput label="UPI ID" placeholder="username@upi" />
            <Button marginTop="spacing.4" isFullWidth>
              Pay Now
            </Button>
          </AccordionItemBody>
        </AccordionItem>

        <AccordionItem>
          <AccordionItemHeader
            title="Credit Card"
            subtitle="Secure card payment"
            titleSuffix={<Badge color="positive">No Extra Charge</Badge>}
          />
          <AccordionItemBody>
            <TextInput label="Card Number" placeholder="1234 5678 9012 3456" />
            <Box display="flex" flexDirection="row" gap="spacing.4" marginTop="spacing.4">
              <TextInput label="Expiry" placeholder="MM/YY" />
              <TextInput label="CVV" placeholder="123" />
            </Box>
            <Button marginTop="spacing.4" isFullWidth>
              Pay Now
            </Button>
          </AccordionItemBody>
        </AccordionItem>

        <AccordionItem>
          <AccordionItemHeader
            title="Net Banking"
            subtitle="Pay using your bank account"
            titleSuffix={<Badge color="positive">5% Cashback</Badge>}
          />
          <AccordionItemBody>
            <TextInput label="Select Bank" placeholder="Choose your bank" />
            <Button marginTop="spacing.4" isFullWidth>
              Continue
            </Button>
          </AccordionItemBody>
        </AccordionItem>
      </Accordion>
    </Box>
  );
};
```

---

## ActionList

# ActionList

## Component Name

ActionList

## Description

ActionList contains a list of actionable items that can be used to perform particular actions. It can be used inside Dropdowns, BottomSheets, or as selectable items when combined with SelectInput. ActionList provides a consistent UI pattern for presenting a menu of options with optional icons, badges, and various customization options.

## Important Constraints

- `ActionList` only supports `ActionListItem` and `ActionListSection` as children
- `ActionListItem` `leading` prop only accepts `ActionListItemIcon`, `ActionListItemAsset`, `ActionListItemAvatar`, and `ActionListItemText` components
- `ActionListItem` `trailing` prop only accepts `ActionListItemIcon` and `ActionListItemText` components
- `ActionListItem` `titleSuffix` prop only accepts `ActionListItemBadge` and `ActionListItemBadgeGroup` components
- `ActionListItem` with `intent="negative"` cannot be used inside Dropdown with SelectInput trigger

## TypeScript Types

Below are the props that the ActionList component and its subcomponents accept. These types define all possible properties you can use when implementing ActionList in your application.

```typescript
type ActionListProps = {
  /**
   * ActionList components (ActionListItem or ActionListSection)
   */
  children: React.ReactNode[];
  /**
   * Whether to use virtualized list rendering for performance with large lists
   */
  isVirtualized?: boolean;
} & TestID &
  DataAnalyticsAttribute;

type ActionListItemProps = {
  /**
   * Text to display for the item
   */
  title: string;
  /**
   * Additional information displayed below the title
   */
  description?: string;
  /**
   * Function called when item is clicked
   */
  onClick?: (clickProps: {
    name: string;
    value?: boolean;
    event: Platform.Select<{
      web: React.MouseEvent;
      native: React.TouchEvent<TouchableOpacity>;
    }>;
  }) => void;
  /**
   * Value that you get from `onChange` event on SelectInput or in form submissions
   */
  value: string;
  /**
   * Link to open when item is clicked
   */
  href?: string;
  /**
   * HTML target of the link
   */
  target?: string;
  /**
   * Item that goes on left-side of item.
   * Valid elements - `<ActionListItemIcon />`, `<ActionListItemAsset />`, `<ActionListItemAvatar />`
   */
  leading?: React.ReactNode;
  /**
   * Item that goes on right-side of item.
   * Valid elements - `<ActionListItemText />`, `<ActionListItemIcon />`
   */
  trailing?: React.ReactNode;
  /**
   * Item that goes immediately next to the title.
   * Valid elements - `<ActionListItemBadge />`, `<ActionListItemBadgeGroup />`
   */
  titleSuffix?: React.ReactElement;
  /**
   * Whether the item is disabled
   */
  isDisabled?: boolean;
  /**
   * Visual color style - currently only supports 'negative'
   */
  intent?: Extract<FeedbackColors, 'negative'>;
  /**
   * Whether the item is selected
   */
  isSelected?: boolean;
} & TestID &
  DataAnalyticsAttribute;

type ActionListSectionProps = {
  /**
   * Section title text
   */
  title: string;
  /**
   * ActionListItem components within this section
   */
  children: React.ReactNode[] | React.ReactNode;
} & TestID &
  DataAnalyticsAttribute;

type ActionListItemAssetProps = {
  /**
   * Source of the image
   */
  src: string;
  /**
   * Alt tag for the image
   */
  alt: string;
};
```

## Examples

### Basic ActionList

A simple example showing how to use ActionList with different types of items.

```tsx
import {
  Box,
  ActionList,
  ActionListItem,
  ActionListSection,
  ActionListItemIcon,
  ActionListItemAsset,
  ActionListItemText,
  ActionListItemBadge,
  ActionListItemBadgeGroup,
  ActionListItemAvatar,
  LogOutIcon,
  SettingsIcon,
  DownloadIcon,
  BankIcon,
  UserIcon,
  ActivityIcon,
  TransactionsIcon,
} from '@razorpay/blade/components';

const ActionListExample = () => {
  return (
    <Box backgroundColor="surface.background.gray.intense" maxWidth="300px">
      {/* Basic ActionList with simple items */}
      <ActionList>
        {/* Basic item with just title */}
        <ActionListItem title="Profile" value="profile" />

        {/* Section with title to group related items */}
        <ActionListSection title="Account Management">
          {/* Item with icon and disabled state */}
          <ActionListItem
            leading={<ActionListItemIcon icon={SettingsIcon} />}
            title="Settings"
            value="settings"
            isDisabled={true}
          />

          {/* Item with icon */}
          <ActionListItem
            leading={<ActionListItemIcon icon={DownloadIcon} />}
            title="Download"
            value="download"
          />

          {/* Item with description */}
          <ActionListItem
            title="Credit"
            value="credit"
            leading={<ActionListItemIcon icon={UserIcon} />}
            description="Check your credit here!"
          />
        </ActionListSection>

        {/* Item with image asset */}
        <ActionListItem
          leading={<ActionListItemAsset src="https://flagcdn.com/w20/in.png" alt="India" />}
          title="Pricing"
          value="pricing"
        />

        {/* Item with href for navigation */}
        <ActionListItem
          title="Go to Home"
          value="home"
          href="https://razorpay.com"
          target="_blank"
        />

        {/* Item with click handler */}
        <ActionListItem
          title="Alert user"
          value="alert_user"
          onClick={({ name, value, event }) => {
            alert('Alert user is clicked!');
          }}
        />

        {/* Item with badges */}
        <ActionListItem
          title="Systems"
          value="systems"
          href="https://razorpay.com/careers"
          target="_blank"
          titleSuffix={
            <ActionListItemBadgeGroup>
              <ActionListItemBadge icon={ActivityIcon} color="information">
                unstable
              </ActionListItemBadge>
              <ActionListItemBadge>last updated: 2hr ago</ActionListItemBadge>
            </ActionListItemBadgeGroup>
          }
        />

        {/* Item with trailing text */}
        <ActionListItem
          title="Bank Settings"
          value="bank_settings"
          trailing={<ActionListItemText>âŒ˜ + B</ActionListItemText>}
        />

        {/* Item with avatar */}
        <ActionListItem
          title="Profile"
          value="profile"
          leading={<ActionListItemAvatar icon={UserIcon} color="primary" name="John Doe" />}
        />

        {/* Item with negative intent for destructive actions */}
        <ActionListItem
          leading={<ActionListItemIcon icon={LogOutIcon} />}
          title="Log Out"
          value="logout"
          intent="negative"
        />
      </ActionList>
    </Box>
  );
};
```

### ActionList with Virtualization

When dealing with large lists, you can use the virtualization feature for better performance.

```tsx
import { Box, ActionList, ActionListItem, ActionListSection } from '@razorpay/blade/components';

const LargeActionListExample = () => {
  // Generate a large list of items
  const generateItems = (count) => {
    return Array.from({ length: count }).map((_, index) => (
      <ActionListItem key={index} title={`Item ${index + 1}`} value={`item-${index + 1}`} />
    ));
  };

  return (
    <Box backgroundColor="surface.background.gray.intense" height="300px">
      <ActionList isVirtualized={true}>
        <ActionListSection title="Large List">{generateItems(100)}</ActionListSection>
        <ActionListSection title="Other Items">
          <ActionListItem title="Additional Item 1" value="additional-1" />
          <ActionListItem title="Additional Item 2" value="additional-2" />
        </ActionListSection>
      </ActionList>
    </Box>
  );
};
```

### ActionList in Different Contexts

ActionList can be used in different contexts like Dropdowns and BottomSheets.

```tsx
import {
  Box,
  Dropdown,
  DropdownOverlay,
  DropdownHeader,
  DropdownFooter,
  SelectInput,
  ActionList,
  ActionListItem,
  ActionListItemIcon,
  Button,
  HomeIcon,
  UserIcon,
  SettingsIcon,
} from '@razorpay/blade/components';

const ActionListInContextExample = () => {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.4">
      {/* ActionList in a Dropdown */}
      <Dropdown>
        <SelectInput label="Select Action" />
        <DropdownOverlay>
          <DropdownHeader title="Available Actions" />
          <ActionList>
            <ActionListItem
              title="Home"
              value="home"
              leading={<ActionListItemIcon icon={HomeIcon} />}
            />
            <ActionListItem
              title="Profile"
              value="profile"
              leading={<ActionListItemIcon icon={UserIcon} />}
            />
            <ActionListItem
              title="Settings"
              value="settings"
              leading={<ActionListItemIcon icon={SettingsIcon} />}
            />
          </ActionList>
          <DropdownFooter>
            <Button>Apply</Button>
          </DropdownFooter>
        </DropdownOverlay>
      </Dropdown>
    </Box>
  );
};
```

---

## Alert

## Component Name

Alert

## Description

Alerts are messages that communicate information to users about any significant changes or explanations inside the system in a prominent way. They can include titles, descriptions, and actions, and come in different emphasis levels and colors to convey different types of information. Alerts can be dismissible and can span the full width of their container.

## TypeScript Types

The following types represent the props that the Alert component accepts. These types define all the available properties you can use when implementing the Alert component in your application.

```typescript
type PrimaryAction = {
  text: string;
  onClick: () => void;
};

type SecondaryActionButton = {
  text: string;
  onClick: () => void;
};

type SecondaryActionLinkButton = {
  text: string;
  href: string;
  onClick?: () => void;
  target?: string;
  /**
   * When `target` is set to `_blank` this is automatically set to `noopener noreferrer`
   */
  rel?: string;
};

type SecondaryAction = SecondaryActionButton | SecondaryActionLinkButton;

type AlertProps = {
  /**
   * Body content, pass text or JSX. Avoid passing components except `Link` to customize the content.
   */
  description: ReactChild;

  /**
   * A brief heading
   */
  title?: string;

  /**
   * Shows a dismiss button
   *
   * @default true
   */
  isDismissible?: boolean;

  /**
   * A callback when the dismiss button is clicked
   */
  onDismiss?: () => void;

  /**
   * Can be used to render custom icon
   */
  icon?: IconComponent;

  /**
   * Can be set to `intense` for a more prominent look. Not to be confused with a11y emphasis.
   *
   * @default subtle
   */
  emphasis?: SubtleOrIntense;

  /**
   * Makes the Alert span the entire container width, instead of the default max width of `584px`.
   * This also makes the alert borderless, useful for creating full bleed layouts.
   *
   * @default false
   */
  isFullWidth?: boolean;

  /**
   * Sets the color tone
   */
  color?: FeedbackColors;

  /**
   * Renders a primary action button and a secondary action link button
   */
  actions?: {
    /**
     * Renders a button (should **always** be present if `secondary` action is being used)
     */
    primary?: PrimaryAction;
    /**
     * Renders a Link button
     */
    secondary?: SecondaryAction;
  };
} & TestID &
  StyledPropsBlade &
  DataAnalyticsAttribute;
```

## Examples

### Standard Alert with Title, Description, and Actions

This example demonstrates a standard information alert with title, description, and both primary and secondary actions.

```tsx
import { Alert } from '@razorpay/blade/components';

function StandardAlertExample() {
  return (
    <Alert
      title="International Payments Only"
      description="Currently you can only accept payments in international currencies using PayPal. You cannot accept payments in INR (â‚¹) using PayPal."
      color="information"
      emphasis="subtle"
      isDismissible={true}
      onDismiss={() => console.log('Alert dismissed')}
      actions={{
        primary: {
          text: 'Enable International Payments',
          onClick: () => console.log('Primary action clicked'),
        },
        secondary: {
          text: 'Learn More',
          href: 'https://razorpay.com/docs',
          target: '_blank',
        },
      }}
    />
  );
}
```

### High Emphasis Alerts

High emphasis alerts have a more prominent look with intense styling, useful for drawing more attention.

```tsx
import { Alert } from '@razorpay/blade/components';

function HighEmphasisAlertExample() {
  return (
    <Alert
      title="Unable to fetch merchants"
      description="There was some internal error while fetching the merchants list, this might also be due to the poor internet connection."
      color="negative"
      emphasis="intense"
      isDismissible={true}
      actions={{
        primary: {
          text: 'Try Refetching',
          onClick: () => console.log('Refetch clicked'),
        },
      }}
    />
  );
}
```

### Minimal Alerts

Alerts can be minimal with just a description and no title or actions.

```tsx
import { Alert } from '@razorpay/blade/components';

function MinimalAlertExample() {
  return (
    <Alert
      description="The payment was made 6 months ago, therefore you can't issue refund to this merchant."
      color="notice"
      emphasis="subtle"
      isDismissible={false}
    />
  );
}
```

### Alerts with Single Action

Alerts that provide only a primary action for users to respond.

```tsx
import { Alert } from '@razorpay/blade/components';

function SingleActionAlertExample() {
  return (
    <Alert
      title="Unable to fetch merchants"
      description="There was some internal error while fetching the merchants list, this might also be due to the poor internet connection."
      color="negative"
      emphasis="subtle"
      actions={{
        primary: {
          text: 'Try Refetching',
          onClick: () => console.log('Refetch clicked'),
        },
      }}
    />
  );
}
```

### Full Width Alerts

Full width alerts span the entire width of their container and are useful for full-bleed layouts.

```tsx
import { Alert, Box } from '@razorpay/blade/components';

function FullWidthAlertExample() {
  return (
    <Box position="relative" width="100%">
      <Alert
        title="System Notification"
        description="Currently you can only accept payments in international currencies using PayPal."
        color="information"
        isFullWidth={true}
        actions={{
          primary: {
            text: 'Acknowledge',
            onClick: () => console.log('Acknowledged'),
          },
          secondary: {
            text: 'Read Policy',
            href: 'https://razorpay.com/policy',
            target: '_blank',
          },
        }}
      />
    </Box>
  );
}
```

---

## Amount

## Component Name

Amount

## Description

The Amount component is used to display currency values with proper formatting. It shows small amounts of color-coded metadata, which are ideal for getting user attention. This component only displays the provided value in the specified currency with the formatting capabilities enabled by @razorpay/i18nify-react, it does not perform any currency conversion.

## Important Constraints

- `size` options are limited based on the `type` prop:
  - `type="body"` supports sizes: `xsmall`, `small`, `medium`, `large`
  - `type="heading"` supports sizes: `small`, `medium`, `large`, `xlarge`, `2xlarge`
  - `type="display"` supports sizes: `small`, `medium`, `large`, `xlarge`

## Typescript Types

The following types represent the props that the Amount component and its subcomponents accept. These types allow you to properly configure the Amount component according to your needs.

```typescript
type AmountSizes = 'xsmall' | 'small' | 'medium' | 'large' | 'xlarge' | '2xlarge';

type AmountDisplayProps = {
  type?: 'display';
  size?: Extract<AmountSizes, 'small' | 'medium' | 'large' | 'xlarge'>;
  weight?: 'regular' | 'medium' | 'semibold';
};

type AmountHeadingProps = {
  type?: 'heading';
  size?: Extract<AmountSizes, 'small' | 'medium' | 'large' | 'xlarge' | '2xlarge'>;
  weight?: 'regular' | 'semibold';
};

type AmountBodyProps = {
  type?: 'body';
  size?: Extract<AmountSizes, 'xsmall' | 'small' | 'medium' | 'large'>;
  weight?: 'regular' | 'medium' | 'semibold';
};

type AmountTypeProps = AmountDisplayProps | AmountHeadingProps | AmountBodyProps;

type AmountCommonProps = {
  /**
   * The value to be rendered within the component.
   */
  value: number;
  /**
   * Sets the color of the amount.
   * @default undefined
   */
  color?: string;
  /**
   * Indicates what the suffix of amount should be
   * @default 'decimals'
   */
  suffix?: 'decimals' | 'none' | 'humanize';
  /**
   * Makes the currency indicator(currency symbol/code) and decimal digits small and faded
   * @default true
   */
  isAffixSubtle?: boolean;
  /**
   * Determines the visual representation of the currency, choose between displaying the currency symbol or code.
   * Note: Currency symbol and code is determined by the locale set in user's browser or set via @razorpay/i18nify-react library.
   * @default 'currency-symbol'
   */
  currencyIndicator?: 'currency-symbol' | 'currency-code';
  /**
   * The currency of the amount. Note that this component
   * only displays the provided value in the specified currency, it does not perform any currency conversion.
   * @default 'INR'
   */
  currency?: string;
  /**
   * If true, the amount text will have a line through it.
   * @default false
   */
  isStrikethrough?: boolean;
  /**
   * Test ID for the component
   */
  testID?: string;
  /**
   * Data analytics attributes
   */
  [key: `data-analytics-${string}`]: string;
};

type AmountProps = AmountTypeProps & AmountCommonProps;
```

## Examples

### Display Variations

```tsx
import { Amount } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';
import { Text } from '@razorpay/blade/components';

const AmountVariationsExample = () => {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.6">
      <Box>
        <Text marginBottom="spacing.2">Different types and sizes:</Text>
        <Box display="flex" gap="spacing.4">
          <Amount value={12345.67} type="body" size="small" weight="medium" currency="INR" />
          <Amount value={12345.67} type="heading" size="large" weight="semibold" currency="USD" />
          <Amount value={12345.67} type="display" size="xlarge" weight="regular" currency="EUR" />
        </Box>
      </Box>

      <Box>
        <Text marginBottom="spacing.2">Currency variations:</Text>
        <Box display="flex" gap="spacing.4">
          <Amount value={12345.67} currency="INR" currencyIndicator="currency-symbol" />
          <Amount value={12345.67} currency="USD" currencyIndicator="currency-symbol" />
          <Amount value={12345.67} currency="GBP" currencyIndicator="currency-code" />
        </Box>
      </Box>
    </Box>
  );
};

export default AmountVariationsExample;
```

### Formatting and Styling

```tsx
import { Amount } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';
import { Text } from '@razorpay/blade/components';
import { I18nProvider } from '@razorpay/i18nify-react';

const AmountFormattingExample = () => {
  return (
    <I18nProvider>
      <Box display="flex" flexDirection="column" gap="spacing.6">
        <Box>
          <Text marginBottom="spacing.2">Suffix options:</Text>
          <Box display="flex" gap="spacing.4">
            <Amount value={12345.67} suffix="decimals" testID="amount-decimals" />
            <Amount value={12345.67} suffix="none" testID="amount-no-suffix" />
            <Amount value={1234567} suffix="humanize" testID="amount-humanize" />
          </Box>
        </Box>

        <Box>
          <Text marginBottom="spacing.2">Styling options:</Text>
          <Box display="flex" gap="spacing.4">
            <Amount
              value={12345.67}
              isStrikethrough={true}
              data-analytics-section="pricing"
              data-analytics-action="view"
            />
            <Amount value={12345.67} isAffixSubtle={false} />
            <Amount value={12345.67} color="feedback.text.positive.intense" isAffixSubtle={true} />
          </Box>
        </Box>

        <Box>
          <Text marginBottom="spacing.2">Color variations:</Text>
          <Box display="flex" gap="spacing.4">
            <Amount value={12345.67} color="feedback.text.positive.intense" />
            <Amount value={12345.67} color="feedback.text.negative.intense" />
            <Amount value={12345.67} color="feedback.text.notice.intense" />
            <Amount value={12345.67} color="feedback.text.information.intense" />
          </Box>
        </Box>
      </Box>
    </I18nProvider>
  );
};

export default AmountFormattingExample;
```

---

## AnimateInteractions

## Component Name

AnimateInteractions

## Description

AnimateInteractions is a component that allows you to animate child components based on interactions with the parent element. It acts similar to the CSS pattern `.parent:hover .child {}`, enabling effects like revealing elements, adding movement, or scaling components when a user interacts with a container.

## TypeScript Types

The following types represent the props that the AnimateInteractions component accepts. These types allow you to properly configure the component according to your needs.

```typescript
// Type for motion triggers used in entry/exit animations
type MotionTriggerEntryExitType = 'mount' | 'in-view' | 'focus' | 'on-animate-interactions';

// Full motion triggers type including interactive triggers
type MotionTriggersType = MotionTriggerEntryExitType | 'hover' | 'tap';

type AnimateInteractionsProps = {
  /**
   * The child element to be wrapped by AnimateInteractions.
   * Child components using 'on-animate-interactions' in their motionTriggers
   * will animate when the parent AnimateInteractions is triggered.
   */
  children: React.ReactElement;

  /**
   * Determines what interactions will trigger the animations of children.
   *
   * Possible values:
   * - 'hover': Animations trigger when the parent is hovered
   * - 'focus': Animations trigger when the parent receives focus
   * - 'tap': Animations trigger when the parent is tapped/clicked
   * - 'mount': Animations trigger when the component mounts
   * - 'in-view': Animations trigger when the component enters the viewport
   *
   * @default ['hover']
   */
  motionTriggers?: MotionTriggersType[];
};
```

## Examples

### Basic Card with Animated Buttons

This example shows a card that reveals action buttons when hovered.

```tsx
import React from 'react';
import {
  AnimateInteractions,
  Move,
  Card,
  CardBody,
  Box,
  Heading,
  Text,
  Button,
  ExternalLinkIcon,
} from '@razorpay/blade/components';

const AnimatedCardExample = () => {
  return (
    <AnimateInteractions motionTriggers={['hover']}>
      <Card width="400px" padding="spacing.0" backgroundColor="surface.background.gray.moderate">
        <CardBody>
          <Box overflow="auto">
            <Box padding="spacing.6">
              <Heading as="h2" weight="regular">
                Payment Pages
              </Heading>
              <Heading marginY="spacing.4" size="large" as="h3">
                Accept payments{' '}
                <Heading size="large" as="span" color="surface.text.primary.normal">
                  without coding on a custom branded store
                </Heading>
              </Heading>
              <Text>Hover over this card to see the buttons animate in from below</Text>
            </Box>

            <Move motionTriggers={['on-animate-interactions']}>
              <Box
                display="flex"
                gap="spacing.4"
                justifyContent="flex-end"
                padding="spacing.4"
                elevation="highRaised"
              >
                <Button variant="secondary" icon={ExternalLinkIcon} iconPosition="right">
                  Know More
                </Button>
                <Button>Sign Up</Button>
              </Box>
            </Move>
          </Box>
        </CardBody>
      </Card>
    </AnimateInteractions>
  );
};

export default AnimatedCardExample;
```

### Image with Hover Overlay

This example demonstrates an image that reveals an overlay with a button when hovered.

```tsx
import React from 'react';
import {
  AnimateInteractions,
  Fade,
  Box,
  Button,
  ExternalLinkIcon,
} from '@razorpay/blade/components';

const AnimatedImageOverlayExample = () => {
  return (
    <AnimateInteractions motionTriggers={['hover']}>
      <Box
        position="relative"
        width="300px"
        height="300px"
        borderRadius="medium"
        elevation="midRaised"
        overflow="hidden"
      >
        <img
          src="https://example.com/your-image.jpg"
          width="100%"
          height="300px"
          alt="Image description"
        />
        <Fade motionTriggers={['on-animate-interactions']}>
          <Box
            display="flex"
            position="absolute"
            top="spacing.0"
            left="spacing.0"
            width="100%"
            height="100%"
            alignItems="center"
            justifyContent="center"
            backgroundColor="overlay.background.subtle"
          >
            <Button
              icon={ExternalLinkIcon}
              iconPosition="right"
              target="_blank"
              href="https://example.com"
            >
              View Details
            </Button>
          </Box>
        </Fade>
      </Box>
    </AnimateInteractions>
  );
};

export default AnimatedImageOverlayExample;
```

### Interactive Card with Multiple Triggers

This example shows a card that responds to both hover and focus interactions, using scale animation.

```tsx
import React from 'react';
import {
  AnimateInteractions,
  Scale,
  Card,
  CardBody,
  Box,
  Heading,
  Text,
} from '@razorpay/blade/components';

const MultiTriggerAnimationExample = () => {
  return (
    <AnimateInteractions motionTriggers={['hover', 'focus']}>
      <Card
        width="400px"
        padding="spacing.5"
        backgroundColor="surface.background.gray.moderate"
        onClick={() => console.log('Card clicked')}
      >
        <CardBody>
          <Box overflow="auto">
            <Box padding="spacing.6">
              <Heading as="h2" size="large">
                Interactive Card
              </Heading>

              <Box display="flex" gap="spacing.4" marginTop="spacing.4">
                <Box flex="2">
                  <Text>
                    This card responds to both hover and keyboard focus. Try hovering over it or
                    pressing Tab to focus on it.
                  </Text>
                </Box>

                <Box>
                  <Scale motionTriggers={['on-animate-interactions']}>
                    <img
                      src="https://example.com/your-image.jpg"
                      width="140px"
                      height="140px"
                      alt="Feature image"
                    />
                  </Scale>
                </Box>
              </Box>
            </Box>
          </Box>
        </CardBody>
      </Card>
    </AnimateInteractions>
  );
};

export default MultiTriggerAnimationExample;
```

### Tap to Reveal Information

This example shows content that is revealed when the user clicks/taps on a card.

```tsx
import React from 'react';
import {
  AnimateInteractions,
  Fade,
  Card,
  CardBody,
  Box,
  Heading,
  Text,
  Button,
} from '@razorpay/blade/components';

const TapRevealExample = () => {
  return (
    <AnimateInteractions motionTriggers={['tap']}>
      <Card width="400px" padding="spacing.7" backgroundColor="surface.background.gray.moderate">
        <CardBody>
          <Heading as="h2" size="large" marginBottom="spacing.4">
            Click me to reveal more
          </Heading>

          <Text>This card reveals additional information when clicked/tapped.</Text>

          <Fade motionTriggers={['on-animate-interactions']}>
            <Box
              marginTop="spacing.6"
              padding="spacing.4"
              backgroundColor="surface.background.gray.subtle"
            >
              <Text weight="semibold">Additional Information</Text>
              <Text marginTop="spacing.2">
                This content is revealed when the user interacts with the card by clicking or
                tapping. The 'tap' trigger works well for mobile experiences.
              </Text>
              <Button marginTop="spacing.4">Take Action</Button>
            </Box>
          </Fade>
        </CardBody>
      </Card>
    </AnimateInteractions>
  );
};

export default TapRevealExample;
```

### In-View Animation on Scroll

This example shows content that animates when it scrolls into the viewport.

```tsx
import React from 'react';
import { AnimateInteractions, Move, Box, Heading, Text } from '@razorpay/blade/components';

const ScrollInViewExample = () => {
  return (
    <AnimateInteractions motionTriggers={['in-view']}>
      <Box
        padding="spacing.6"
        backgroundColor="surface.background.gray.moderate"
        borderRadius="medium"
        width="100%"
        maxWidth="600px"
      >
        <Heading as="h2" size="large">
          Scroll-triggered Animation
        </Heading>

        <Text marginTop="spacing.4">
          This content animates when it scrolls into the viewport. Useful for creating engaging
          scroll experiences on landing pages and long-form content.
        </Text>

        <Move motionTriggers={['on-animate-interactions']}>
          <Box
            marginTop="spacing.6"
            padding="spacing.4"
            backgroundColor="surface.background.primary.subtle"
            borderRadius="medium"
          >
            <Text weight="semibold">I animate when scrolled into view!</Text>
            <Text marginTop="spacing.2">
              The 'in-view' trigger is perfect for creating scroll-based animations that engage
              users as they move down the page.
            </Text>
          </Box>
        </Move>
      </Box>
    </AnimateInteractions>
  );
};

export default ScrollInViewExample;
```

---

## AreaChart

# AreaChart

## Component Name

AreaChart

## Description

AreaChart is a data visualization component built on top of Recharts that displays quantitative data as filled areas under curves. It supports single and multiple data series, stacked areas, and various styling options. The component is designed for showing trends over time, comparing multiple datasets, and highlighting data patterns with customizable colors and interactive features.

## Important Constraints

- Maximum of 10 areas can be configured in a single chart (throws error if exceeded)
- `ChartAreaWrapper` only accepts `ChartArea` components as direct children for proper indexing
- `dataKey` prop is required for each `ChartArea` component to specify which data field to display
- `name` prop is required for each `ChartArea` component for legend and tooltip display
- Data array must contain objects with consistent key structure across all data points
- `colorTheme` currently only supports 'default' value (other themes will log warning)

## TypeScript Types

These types define the props that the AreaChart component and its subcomponents accept:

```typescript

type ChartAreaProps {
  type?: 'step' | 'stepAfter' | 'stepBefore' | 'linear' | 'monotone';
  connectNulls?: boolean;
  showLegend?: boolean;
  dataKey: string;
  name: string;
  stackId?: string | number;
  color?: ChartsCategoricalColorToken;
  dot?: RechartAreaProps['dot'];
  activeDot?: RechartAreaProps['activeDot'];
}

type data = {
  [key: string]: string | number | null;
};

type ChartAreaWrapperProps = {
  children?: React.ReactNode;
  colorTheme?:  'categorical';
  data: data[];
} & BoxProps;

type ChartReferenceLineProps = {
  /**
   * The y-coordinate of the reference line.
   */
  y?: RechartsReferenceLineProps['y'];
  /**
   * The x-coordinate  of the reference line.
   */
  x?: RechartsReferenceLineProps['x'];
  /**
   * The label of the reference line.
   */
  label: string;
};

type ChartXAxisProps = Omit<RechartsXAxisProps, 'tick' | 'label' | 'dataKey' | 'stroke'> & {
  /**
   * The label of the x-axis.
   */
  label?: string;
  /**
   * The data key of the x-axis.
   */
  dataKey?: string;
};

type ChartYAxisProps = Omit<RechartsYAxisProps, 'tick' | 'label' | 'dataKey' | 'stroke'> & {
  /**
   * The label of the y-axis.
   */
  label?: string;
  /**
   * The data key of the y-axis.
   */
  dataKey?: string;
};

type ChartTooltipProps = ComponentProps<typeof RechartsTooltip>;


type Layout = 'horizontal' | 'vertical';
type Align = 'left' | 'right';

type ChartTooltipProps = ComponentProps<typeof RechartsTooltip>;
type ChartLegendProps = ComponentProps<typeof RechartsLegend> & {
  layout?: Layout;
  align?: Align;
};


type ChartCartesianGridProps = ComponentProps<typeof RechartsCartesianGrid>;

type ChartsCategoricalColorToken = `data.background.categorical.${ChartColorCategories}.${keyof ChartCategoricalEmphasis}`;

type colorTheme = 'categorical';
```

## Examples

### Basic Area Chart with Single Data Series

```typescript
import React from 'react';
import {
  ChartAreaWrapper,
  ChartArea,
  ChartXAxis,
  ChartYAxis,
  ChartCartesianGrid,
  ChartTooltip,
  Box,
} from '@razorpay/blade/components';

function BasicAreaChart() {
  const data = [
    { month: 'Jan', revenue: 4000 },
    { month: 'Feb', revenue: 3000 },
    { month: 'Mar', revenue: 2000 },
    { month: 'Apr', revenue: 2780 },
    { month: 'May', revenue: 1890 },
    { month: 'Jun', revenue: 2390 },
  ];

  return (
    <Box width="100%" height="400px">
      <ChartAreaWrapper data={data}>
        <ChartCartesianGrid />
        <CharChartXAxis dataKey="month" />
        <ChartYAxis />
        <ChartTooltip />
        <Area
          dataKey="revenue"
          name="Revenue"
          type="monotone"
          color="data.background.categorical.azure.intense"
        />
      </ChartAreaWrapper>
    </Box>
  );
}
```

---

## AutoComplete

## Component Name

AutoComplete

## Description

AutoComplete is an enhanced dropdown trigger component that combines text input functionality with dropdown selection. It extends the capabilities of SelectInput by allowing users to type and filter options, making it ideal for scenarios where users need to search through a large set of options. Like SelectInput, it must be used within a Dropdown component and pairs with ActionList to create interactive, filterable selection experiences.

## TypeScript Types

The following types define the props that the AutoComplete component accepts. These types are essential for proper usage of the component in TypeScript projects.

```typescript
type AutoCompleteProps = {
  /**
   * Label to be shown for the input field
   */
  label?: string;

  /**
   * Accessibility label for the input
   */
  accessibilityLabel?: string;

  /**
   * Position of the label.
   * Can be 'top', 'left', or 'inside-input'
   */
  labelPosition?: 'top' | 'left' | 'inside-input';

  /**
   * Indicates whether the field is optional or required
   */
  necessityIndicator?: 'optional' | 'required';

  /**
   * Validation state of the input
   */
  validationState?: 'none' | 'error' | 'success';

  /**
   * Help text to be displayed below the input
   */
  helpText?: string;

  /**
   * Error text to be displayed when validationState is 'error'
   */
  errorText?: string;

  /**
   * Success text to be displayed when validationState is 'success'
   */
  successText?: string;

  /**
   * Name of the input field
   */
  name?: string;

  /**
   * Whether the input is disabled
   */
  isDisabled?: boolean;

  /**
   * Whether the input is required
   */
  isRequired?: boolean;

  /**
   * Prefix text to be displayed before the value
   */
  prefix?: string;

  /**
   * Suffix text to be displayed after the value
   */
  suffix?: string;

  /**
   * Whether the input should be focused on mount
   */
  autoFocus?: boolean;

  /**
   * Callback that is called when the input value changes
   */
  onInputValueChange?: (params: { name?: string; value: string }) => void;

  /**
   * Callback that is called when the input is clicked
   */
  onClick?: ({ name, value }: { name?: string; value?: string }) => void;

  /**
   * Callback that is called when the input receives focus
   */
  onFocus?: ({ name, value }: { name?: string; value?: string }) => void;

  /**
   * Callback that is called when the input loses focus
   */
  onBlur?: ({ name, value }: { name?: string; value?: string }) => void;

  /**
   * Placeholder text to be displayed when no value is selected
   */
  placeholder?: string;

  /**
   * Test ID for testing
   */
  testID?: string;

  /**
   * Size of the input
   */
  size?: 'medium' | 'large';

  /**
   * Icon to be displayed at the beginning of the input
   */
  icon?: React.ComponentType<any>;

  /**
   * Controlled value of the AutoComplete. Used in combination with `onChange`.
   */
  value?: string | string[];

  /**
   * Controlled input value of the AutoComplete. Used in combination with `onInputValueChange`.
   */
  inputValue?: string;

  /**
   * Used to set the default value of AutoComplete when it's uncontrolled.
   */
  defaultValue?: string | string[];

  /**
   * Used to set the default input value of AutoComplete when it's uncontrolled.
   */
  defaultInputValue?: string;

  /**
   * Callback that is called when the selection changes
   */
  onChange?: ({ name, values }: { name?: string; values: string[] }) => void;

  /**
   * Whether to keep the input value after selection
   * @default false
   */
  shouldKeepInputValueOnSelect?: boolean;

  /**
   * Whether to open the dropdown when the input is focused
   * @default true
   */
  shouldOpenOnFocus?: boolean;

  /**
   * Function to filter options based on input value
   */
  filter?: (inputValue: string, option: string) => boolean;

  /**
   * Function to format display text from option value
   */
  formatValue?: (value: string) => string;

  /**
   * Constraints the height of input to given number rows
   * @default 'single'
   */
  maxRows?: 'single' | 'multiple' | 'expandable';

  /**
   * Controlled state of filtering of items in AutoComplete.
   *
   * Checkout [Custom Filtering Example](https://blade.razorpay.com/?path=/story/components-dropdown-with-autocomplete--controlled-filtering)
   */
  filteredValues?: string[];
} & DataAnalyticsAttribute;
```

## Example

### Basic AutoComplete with Client-Side Filtering

This example demonstrates a basic AutoComplete with client-side filtering, showing how to use it within a Dropdown component.

```jsx
import { useState } from 'react';
import {
  Dropdown,
  DropdownOverlay,
  AutoComplete,
  ActionList,
  ActionListItem,
  Box,
  Text,
  SearchIcon,
} from '@razorpay/blade/components';

function BasicAutoCompleteExample() {
  const [selectedItem, setSelectedItem] = useState('');
  const [inputValue, setInputValue] = useState('');

  const fruits = [
    { id: 'apple', name: 'Apple' },
    { id: 'banana', name: 'Banana' },
    { id: 'cherry', name: 'Cherry' },
    { id: 'dragonfruit', name: 'Dragon Fruit' },
    { id: 'elderberry', name: 'Elderberry' },
    { id: 'fig', name: 'Fig' },
    { id: 'grape', name: 'Grape' },
    { id: 'honeydew', name: 'Honeydew Melon' },
  ];

  const handleSelectionChange = ({ values }) => {
    setSelectedItem(values[0] || '');
  };

  const handleInputValueChange = ({ value }) => {
    setInputValue(value);
  };

  return (
    <Box width="100%" maxWidth="400px">
      <Text marginBottom="spacing.4">
        Selected fruit:{' '}
        {selectedItem ? fruits.find((f) => f.id === selectedItem)?.name || selectedItem : 'None'}
      </Text>

      <Dropdown selectionType="single">
        <AutoComplete
          label="Search Fruits"
          name="fruit"
          placeholder="Type to search..."
          icon={SearchIcon}
          value={selectedItem}
          inputValue={inputValue}
          onChange={handleSelectionChange}
          onInputValueChange={handleInputValueChange}
          helpText="Start typing to see matching fruits"
          size="medium"
          data-analytics-section="fruit-search"
        />
        <DropdownOverlay>
          <ActionList>
            {fruits.map((fruit) => (
              <ActionListItem key={fruit.id} title={fruit.name} value={fruit.id} />
            ))}
          </ActionList>
        </DropdownOverlay>
      </Dropdown>
    </Box>
  );
}
```

### AutoComplete with Asynchronous Data Loading

This example shows how to implement an AutoComplete with asynchronous data loading to fetch options based on user input.

```jsx
import { useState, useEffect } from 'react';
import {
  Dropdown,
  DropdownOverlay,
  AutoComplete,
  ActionList,
  ActionListItem,
  Box,
  Text,
  Spinner,
} from '@razorpay/blade/components';

function AsyncAutoCompleteExample() {
  const [inputValue, setInputValue] = useState('');
  const [selectedCity, setSelectedCity] = useState('');
  const [cities, setCities] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // Simulate API call to fetch cities based on input
  useEffect(() => {
    if (inputValue.length < 2) {
      setCities([]);
      return;
    }

    const fetchCities = async () => {
      setIsLoading(true);
      setError(null);

      try {
        // Simulate API delay
        await new Promise((resolve) => setTimeout(resolve, 800));

        // Mock data - in real app would be an API call
        const allCities = [
          { id: 'nyc', name: 'New York City', country: 'USA' },
          { id: 'london', name: 'London', country: 'UK' },
          { id: 'paris', name: 'Paris', country: 'France' },
          { id: 'tokyo', name: 'Tokyo', country: 'Japan' },
          { id: 'mumbai', name: 'Mumbai', country: 'India' },
          { id: 'sydney', name: 'Sydney', country: 'Australia' },
          { id: 'berlin', name: 'Berlin', country: 'Germany' },
          { id: 'rio', name: 'Rio de Janeiro', country: 'Brazil' },
          { id: 'cairo', name: 'Cairo', country: 'Egypt' },
          { id: 'toronto', name: 'Toronto', country: 'Canada' },
        ];

        const filteredCities = allCities.filter(
          (city) =>
            city.name.toLowerCase().includes(inputValue.toLowerCase()) ||
            city.country.toLowerCase().includes(inputValue.toLowerCase()),
        );

        setCities(filteredCities);
      } catch (err) {
        setError('Failed to fetch cities. Please try again.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchCities();
  }, [inputValue]);

  const handleInputValueChange = ({ value }) => {
    setInputValue(value);
  };

  const handleSelectionChange = ({ values }) => {
    setSelectedCity(values[0] || '');
  };

  return (
    <Box width="100%" maxWidth="400px">
      <Text marginBottom="spacing.4">
        Selected city:{' '}
        {selectedCity
          ? cities.find((c) => c.id === selectedCity)?.name +
              ', ' +
              cities.find((c) => c.id === selectedCity)?.country || selectedCity
          : 'None'}
      </Text>

      <Dropdown selectionType="single">
        <AutoComplete
          label="Search Cities"
          name="city"
          placeholder="Enter city or country name..."
          value={selectedCity}
          inputValue={inputValue}
          onChange={handleSelectionChange}
          onInputValueChange={handleInputValueChange}
          helpText="Type at least 2 characters to search"
          validationState={error ? 'error' : 'none'}
          errorText={error}
          size="large"
          data-analytics-section="city-search"
        />
        <DropdownOverlay>
          {isLoading ? (
            <Box padding="spacing.4" display="flex" justifyContent="center">
              <Spinner size="medium" accessibilityLabel="Loading cities" />
            </Box>
          ) : cities.length === 0 ? (
            <Box padding="spacing.4" textAlign="center">
              <Text>No cities found. Try a different search.</Text>
            </Box>
          ) : (
            <ActionList>
              {cities.map((city) => (
                <ActionListItem
                  key={city.id}
                  title={city.name}
                  description={city.country}
                  value={city.id}
                />
              ))}
            </ActionList>
          )}
        </DropdownOverlay>
      </Dropdown>
    </Box>
  );
}
```

### AutoComplete with Create Option Feature

This example demonstrates an AutoComplete with the ability to create new options when no matching options are found.

```jsx
import { useState } from 'react';
import {
  Dropdown,
  DropdownOverlay,
  AutoComplete,
  ActionList,
  ActionListItem,
  ActionListSection,
  Box,
  Button,
  Text,
  PlusIcon,
  TagIcon,
} from '@razorpay/blade/components';

function CreatableAutoCompleteExample() {
  const [inputValue, setInputValue] = useState('');
  const [selectedTags, setSelectedTags] = useState([]);
  const [availableTags, setAvailableTags] = useState([
    { id: 'important', name: 'Important' },
    { id: 'urgent', name: 'Urgent' },
    { id: 'review', name: 'Needs Review' },
    { id: 'bug', name: 'Bug' },
    { id: 'feature', name: 'Feature Request' },
    { id: 'documentation', name: 'Documentation' },
  ]);

  const handleInputValueChange = ({ value }) => {
    setInputValue(value);
  };

  const handleSelectionChange = ({ values }) => {
    setSelectedTags(values);
  };

  const handleCreateTag = () => {
    // Only create if there's input and it doesn't match existing tags
    if (!inputValue.trim()) return;

    const normalizedInput = inputValue.trim();
    const tagExists = availableTags.some(
      (t) => t.name.toLowerCase() === normalizedInput.toLowerCase(),
    );

    if (!tagExists) {
      const newTagId = normalizedInput.toLowerCase().replace(/\s+/g, '-');
      const newTag = { id: newTagId, name: normalizedInput };

      setAvailableTags((prev) => [...prev, newTag]);
      setSelectedTags((prev) => [...prev, newTagId]);
      setInputValue('');
    }
  };

  // Check if current input exists in available tags
  const shouldShowCreateOption =
    inputValue.trim() !== '' &&
    !availableTags.some((t) => t.name.toLowerCase() === inputValue.trim().toLowerCase());

  // Get display names for selected tags
  const selectedTagNames = selectedTags.map((tagId) => {
    const tag = availableTags.find((t) => t.id === tagId);
    return tag ? tag.name : tagId;
  });

  return (
    <Box
      width="100%"
      maxWidth="450px"
      padding="spacing.5"
      backgroundColor="surface.background.gray.subtle"
      borderRadius="medium"
    >
      <Text size="large" weight="semibold" marginBottom="spacing.4">
        Task Tags
      </Text>

      <Dropdown selectionType="multiple">
        <AutoComplete
          label="Add Tags"
          name="tags"
          placeholder="Search or create new tags..."
          icon={TagIcon}
          value={selectedTags}
          inputValue={inputValue}
          onChange={handleSelectionChange}
          onInputValueChange={handleInputValueChange}
          maxRows="multiple"
          size="medium"
          data-analytics-section="task-tagging"
        />
        <DropdownOverlay>
          <ActionList>
            {shouldShowCreateOption && (
              <ActionListSection title="Create New">
                <ActionListItem
                  title={`Create "${inputValue}"`}
                  value={`create:${inputValue}`}
                  leading={<PlusIcon />}
                  onClick={handleCreateTag}
                />
              </ActionListSection>
            )}

            <ActionListSection title="Available Tags">
              {availableTags.length === 0 ? (
                <Box padding="spacing.3">
                  <Text>No tags available</Text>
                </Box>
              ) : (
                availableTags.map((tag) => (
                  <ActionListItem key={tag.id} title={tag.name} value={tag.id} />
                ))
              )}
            </ActionListSection>
          </ActionList>
        </DropdownOverlay>
      </Dropdown>

      <Box marginTop="spacing.4">
        <Text size="small" weight="medium">
          Selected Tags:
        </Text>
        <Box display="flex" flexWrap="wrap" gap="spacing.2" marginTop="spacing.2">
          {selectedTagNames.length > 0 ? (
            selectedTagNames.map((tagName, index) => (
              <Box
                key={index}
                backgroundColor="surface.background.gray.subtle"
                padding={['spacing.1', 'spacing.3']}
                borderRadius="medium"
              >
                {tagName}
              </Box>
            ))
          ) : (
            <Text size="small">No tags selected</Text>
          )}
        </Box>
      </Box>
    </Box>
  );
}
```

---

## Avatar

## Component Name

Avatar and AvatarGroup

## Description

Avatar is a standardized visual representation of a user or entity, displayed as a profile picture, icon, or initials. It facilitates user recognition and streamlines interface navigation in applications. AvatarGroup allows you to display multiple avatars together in a compact, overlapping layout, useful for team members or participants.

## Important Constraints

- `src` prop requires either `alt` or `name` prop to be provided
- `topAddon` prop only accepts `Indicator` component
- `bottomAddon` prop only accepts `IconComponent`
- `AvatarGroup` component only accepts `Avatar` components as children

## TypeScript Types

The following types represent the props that the Avatar and AvatarGroup components accept. These types allow you to properly configure the components according to your needs.

```typescript
// Common size options for Avatar
type AvatarSize = 'xsmall' | 'small' | 'medium' | 'large' | 'xlarge';

// Image-specific properties for Avatar
type AvatarImgProps = {
  /**
   * Custom image source
   */
  src?: string;
  /**
   * The `alt` attribute for the `img` element
   */
  alt?: string;
  /**
   * The `srcSet` attribute for the `img` element, useful for responsive images.
   */
  srcSet?: string;
  /**
   * CORS settings attributes
   */
  crossOrigin?: 'anonymous' | 'use-credentials' | '';
  /**
   * Defines which referrer is sent when fetching the resource.
   */
  referrerPolicy?: HTMLAttributeReferrerPolicy;
};

// Common properties for Avatar
type AvatarCommonProps = {
  /**
   * The size of the avatar.
   * @default "medium"
   */
  size?: AvatarSize;
  /**
   * The visual variant of the avatar.
   * @default "circle"
   */
  variant?: 'circle' | 'square';
  /**
   * The color theme of the avatar.
   * @default "neutral"
   */
  color?: 'primary' | 'information' | 'negative' | 'neutral' | 'notice' | 'positive';
  /**
   * Custom icon component to use as the avatar.
   */
  icon?: IconComponent;
  /**
   * The name of the avatar, used to generate initials.
   * If src has loaded, the name will be used as the alt attribute of the img.
   * If src is not loaded, the name will be used to create the initials.
   */
  name?: string;
  /**
   * Automatically renders button with `a` tag with `href` on web
   */
  href?: string;
  /**
   * anchor target attribute
   * Should only be used alongside `href`
   */
  target?: '_blank' | '_self' | '_parent' | '_top';
  /**
   * anchor rel attribute
   * Should only be used alongside `href`
   */
  rel?: string;
  /**
   * Click handler for the avatar.
   */
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  /**
   * Whether the avatar is selected
   */
  isSelected?: boolean;
  /**
   * Custom icon component to render at bottom of the avatar.
   * Only accepts IconComponent
   */
  bottomAddon?: IconComponent;
  /**
   * Custom component to render at top of the avatar.
   * Only accepts Indicator
   */
  topAddon?: React.ReactElement;
  /**
   * Test ID for the component
   */
  testID?: string;

  // Common event handlers
  onBlur?: React.FocusEventHandler;
  onFocus?: React.FocusEventHandler;
  onMouseLeave?: React.MouseEventHandler;
  onMouseMove?: React.MouseEventHandler;
  onMouseDown?: React.MouseEventHandler;
  onPointerDown?: React.PointerEventHandler;
  onPointerEnter?: React.PointerEventHandler;
  onTouchStart?: React.TouchEventHandler;
  onTouchEnd?: React.TouchEventHandler;

  // Data analytics attributes
  [key: `data-analytics-${string}`]: string;
};

// Complete Avatar component props
type AvatarProps = AvatarCommonProps & AvatarImgProps;

// AvatarGroup component props
type AvatarGroupProps = {
  /**
   * Children elements representing the avatars to stack.
   */
  children: React.ReactNode;
  /**
   * The size of each avatar within the group. Propagates to all avatars.
   * @default "medium"
   */
  size?: AvatarSize;
  /**
   * The maximum number of avatars to display before truncating.
   */
  maxCount?: number;
  /**
   * Test ID for the component
   */
  testID?: string;

  // Data analytics attributes
  [key: `data-analytics-${string}`]: string;
};
```

## Examples

### Avatar Component Usage

This example shows the three main types of Avatar (image, letter, and icon) with various configurations.

```tsx
import React from 'react';
import { Avatar, Box, Indicator, BuildingIcon, TrustedBadgeIcon } from '@razorpay/blade/components';

const AvatarExample = () => {
  // Image avatar with interactive props and variants
  const renderImageAvatars = () => (
    <Box display="flex" gap="spacing.4" alignItems="center">
      <Avatar
        name="John Doe"
        src="https://example.com/profile.jpg"
        size="medium"
        variant="circle"
        onClick={() => console.log('Avatar clicked')}
      />

      <Avatar
        name="Jane Smith"
        src="https://example.com/profile.jpg"
        size="large"
        variant="square"
        href="https://example.com/profile"
        target="_blank"
        rel="noopener noreferrer"
        isSelected={true}
      />
    </Box>
  );

  // Letter avatars showing color variations
  const renderLetterAvatars = () => (
    <Box display="flex" gap="spacing.4" alignItems="center">
      <Avatar name="John Doe" color="primary" size="small" />
      <Avatar name="Jane Smith" color="positive" size="medium" />
      <Avatar name="Bob Miller" color="negative" size="large" />
    </Box>
  );

  // Icon avatars and avatars with addons
  const renderAddonAvatars = () => (
    <Box display="flex" gap="spacing.4" alignItems="center">
      <Avatar icon={BuildingIcon} color="information" variant="circle" />

      <Avatar
        name="With Addons"
        size="large"
        topAddon={<Indicator color="negative" />}
        bottomAddon={TrustedBadgeIcon}
        data-analytics-section="profile"
        testID="user-avatar"
      />
    </Box>
  );

  return (
    <Box display="flex" flexDirection="column" gap="spacing.5">
      {renderImageAvatars()}
      {renderLetterAvatars()}
      {renderAddonAvatars()}
    </Box>
  );
};

export default AvatarExample;
```

### Interactive Avatar with Controlled Selection State

This example shows how to handle click events and manage the selection state of avatars.

```tsx
import React, { useState } from 'react';
import { Avatar, Box, Text } from '@razorpay/blade/components';

const InteractiveAvatarExample = () => {
  // Track the selected avatar index
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);

  // User data
  const users = [
    { id: 1, name: 'John Doe', color: 'primary' },
    { id: 2, name: 'Jane Smith', color: 'positive' },
    { id: 3, name: 'Bob Miller', color: 'negative' },
    { id: 4, name: 'Alice Walker', color: 'primary' },
  ];

  // Handle avatar click
  const handleAvatarClick = (index: number, userId: number) => {
    setSelectedIndex(index);
    console.log(`Avatar clicked: ${users[index].name}, ID: ${userId}`);

    // This is where you could do something with the selected user
    // e.g., fetch user details, open a profile modal, etc.
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.5">
      <Text>Click an avatar to select it:</Text>

      <Box display="flex" gap="spacing.4" alignItems="center">
        {users.map((user, index) => (
          <Avatar
            key={user.id}
            name={user.name}
            size="medium"
            isSelected={selectedIndex === index}
            onClick={() => handleAvatarClick(index, user.id)}
          />
        ))}
      </Box>

      {selectedIndex !== null && <Text>Selected user: {users[selectedIndex].name}</Text>}
    </Box>
  );
};

export default InteractiveAvatarExample;
```

### AvatarGroup Component Usage

This example demonstrates the AvatarGroup component with different settings and configurations.

```tsx
import React from 'react';
import { Avatar, AvatarGroup, Box } from '@razorpay/blade/components';

const AvatarGroupExample = () => {
  // Team members data
  const teamMembers = [
    { name: 'John Doe', color: 'primary' },
    { name: 'Jane Smith', color: 'positive' },
    { name: 'Bob Miller', color: 'negative' },
    { name: 'Alice Walker', color: 'primary' },
    { name: 'David Clark', color: 'primary' },
  ];

  return (
    <Box display="flex" flexDirection="column" gap="spacing.6">
      {/* Basic avatar group */}
      <AvatarGroup>
        {teamMembers.map((member, index) => (
          <Avatar key={index} name={member.name} />
        ))}
      </AvatarGroup>

      {/* With maxCount - shows "+2" for overflow */}
      <AvatarGroup maxCount={3} size="large">
        {teamMembers.map((member, index) => (
          <Avatar key={index} name={member.name} />
        ))}
      </AvatarGroup>

      {/* With size customization and analytics */}
      <AvatarGroup size="small" data-analytics-section="team-view" testID="small-team-avatars">
        <Avatar name="User 1" color="primary" />
        <Avatar name="User 2" color="positive" />
        <Avatar name="User 3" color="negative" />
      </AvatarGroup>
    </Box>
  );
};

export default AvatarGroupExample;
```

### Interactive AvatarGroup with Click Handling

This example shows how to handle clicks within an AvatarGroup.

```tsx
import React, { useState } from 'react';
import { Avatar, AvatarGroup, Box, Text } from '@razorpay/blade/components';

const InteractiveAvatarGroupExample = () => {
  const [selectedUser, setSelectedUser] = useState<string | null>(null);

  // Team members data
  const teamMembers = [
    { id: 1, name: 'John Doe', color: 'primary' },
    { id: 2, name: 'Jane Smith', color: 'positive' },
    { id: 3, name: 'Bob Miller', color: 'negative' },
    { id: 4, name: 'Alice Walker', color: 'primary' },
    { id: 5, name: 'David Clark', color: 'primary' },
  ];

  const handleAvatarClick = (name: string) => {
    setSelectedUser(name);
    // Here you could trigger an action like showing a profile or opening a modal
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.6">
      <Text>Click an avatar to select that team member:</Text>

      <AvatarGroup maxCount={4}>
        {teamMembers.map((member) => (
          <Avatar
            key={member.id}
            name={member.name}
            isSelected={selectedUser === member.name}
            onClick={() => handleAvatarClick(member.name)}
          />
        ))}
      </AvatarGroup>

      {selectedUser && <Text>Selected team member: {selectedUser}</Text>}
    </Box>
  );
};

export default InteractiveAvatarGroupExample;
```

---

## Badge

## Component Name

Badge

## Description

Badges are small, color-coded UI elements used to display concise metadata, designed to draw user attention to important information. They offer visual categorization through different colors, sizes, and emphasis levels, making them ideal for status indicators, counts, or category labels.

## Important Constraints

- `children` prop is required and must contain text content
- `icon` prop only accepts `IconComponent`

## TypeScript Types

The following types represent the props that the Badge component accepts. These types allow you to properly configure the component according to your needs.

```typescript
// Main Badge component props
type BadgeProps = {
  /**
   * Sets the label for the badge.
   */
  children: StringChildrenType;

  /**
   * Sets the color of the badge.
   * @default 'neutral'
   */
  color?: FeedbackColors | 'primary';

  /**
   * Sets the contrast of the badge.
   * @default 'subtle'
   */
  emphasis?: SubtleOrIntense;

  /**
   * Sets the size of the badge.
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * Icon to be displayed in the badge.
   * Accepts a component of type `IconComponent` from Blade.
   */
  icon?: IconComponent;

  /**
   * Test ID that can be used to select element in testing environments
   */
  testID?: string;
} & StyledPropsBlade &
  DataAnalyticsAttribute;
```

## Examples

### Badge Usage

This example demonstrates badges with key properties and styling.

```tsx
import React from 'react';
import { Badge, Box, InfoIcon, CheckCircleIcon } from '@razorpay/blade/components';

const BadgeExample = () => {
  return (
    <Box display="flex" gap="spacing.4">
      <Badge color="primary" emphasis="subtle" icon={InfoIcon} size="small">
        Info
      </Badge>

      <Badge
        color="positive"
        emphasis="intense"
        icon={CheckCircleIcon}
        size="medium"
        data-analytics-section="status"
        testID="success-badge"
      >
        Success
      </Badge>

      <Badge
        color="notice"
        emphasis="subtle"
        icon={InfoIcon}
        size="large"
        marginLeft="spacing.2"
        display="inline-flex"
      >
        Warning
      </Badge>
    </Box>
  );
};

export default BadgeExample;
```

---

## BarChart

# BarChart

## Component Name

BarChart

## Description

BarChart is a comprehensive data visualization component that renders interactive bar charts with support for grouped, stacked, and vertical layouts. It provides customizable colors, animations, and interactive features like hover states and tooltips. The component is built on top of Recharts and integrates seamlessly with Blade's design system, offering consistent styling and accessibility features. BarChart supports multiple data series, custom color themes, and various chart configurations for displaying categorical data effectively.

## Important Constraints

- `ChartBarWrapper` component only accepts `ChartBar`, `ChartXAxis`, `ChartYAxis`, `ChartCartesianGrid`, `ChartTooltip`, `ChartLegend`, and `ChartReferenceLine` components as children.
- `data` prop is required and must be an array of objects with consistent data structure
- `dataKey` prop is required for each `ChartBar` component and must correspond to a property in the data array
- `stackId` must be consistent across all bars that should be stacked together
- `layout="vertical"` requires `ChartXAxis` to have `type="number"` and `ChartYAxis` to have `type="category"`
- Color tokens must follow the exact format: `data.background.categorical.{color}.{emphasis}` or `data.background.sequential.{color}.{number}`

## TypeScript Types

These types define the props that the BarChart component and its subcomponents accept:

```typescript
type ChartBarProps = Omit<RechartsBarProps, 'fill' | 'dataKey' | 'name' | 'label' | 'activeBar'> & {
  /**
   * The data key of the bar chart.
   */
  dataKey: RechartsBarProps['dataKey'];
  /**
   * The name of the bar chart.
   */
  name?: RechartsBarProps['name'];
  /**
   * The color of the bar chart.
   */
  color?: ChartsCategoricalColorToken | ChartSequentialColorToken;
  /**
   * The stack id of the bar chart.
   */
  stackId?: RechartsBarProps['stackId'];
  /**
   * The active bar of the bar chart.
   */
  activeBar?: RechartsBarProps['activeBar'];
  /**
   * The label of the bar chart.
   */
  label?: RechartsBarProps['label'];
  /**
   * The show legend of the bar chart.
  */
  showLegend?: boolean;
};

type data = {
  [key: string]: unknown;
};

type ChartBarWrapperProps = {
  children?: React.ReactNode;
  /**
   * The color theme of the bar chart.
   */
  colorTheme?:  'categorical';
  /**
   * The orientation of the bar chart.
   */
  layout?: 'horizontal' | 'vertical';
  /**
   * Chart data to be rendered
   */
  data: data[];
} & BoxProps;


type ChartsCategoricalColorToken = `data.background.categorical.${ChartColorCategories}.${keyof ChartCategoricalEmphasis}`;

type ChartSequentialColorToken = `data.background.sequential.${Exclude<ChartColorCategories, 'gray'>}.${keyof ChartSequentialEmphasis}`;

type colorTheme = 'categorical';


type ChartXAxisProps = Omit<RechartsXAxisProps, 'tick' | 'label' | 'dataKey' | 'stroke'> & {
  /**
   * The label of the x-axis.
   */
  label?: string;
  /**
   * The data key of the x-axis.
   */
  dataKey?: string;
};

type ChartYAxisProps = Omit<RechartsYAxisProps, 'tick' | 'label' | 'dataKey' | 'stroke'> & {
  /**
   * The label of the y-axis.
   */
  label?: string;
  /**
   * The data key of the y-axis.
   */
  dataKey?: string;
};

type ChartTooltipProps = ComponentProps<typeof RechartsTooltip>;


type Layout = 'horizontal' | 'vertical';
type Align = 'left' | 'right';

type ChartTooltipProps = ComponentProps<typeof RechartsTooltip>;
type ChartLegendProps = ComponentProps<typeof RechartsLegend> & {
  layout?: Layout;
  align?: Align;
};


type ChartCartesianGridProps = Omit<RechartsCartesianGridProps, 'strokeDasharray' | 'verticalFill' | 'horizontalFill'>;

type ChartReferenceLineProps = {
  /**
   * The y-coordinate of the reference line.
   */
  y?: RechartsReferenceLineProps['y'];
  /**
   * The x-coordinate  of the reference line.
   */
  x?: RechartsReferenceLineProps['x'];
  /**
   * The label of the reference line.
   */
  label: string;
};
```

## Example

### Basic BarChart with Multiple Series

```tsx
import React from 'react';
import {
  ChartBar,
  ChartBarWrapper,
  ChartXAxis,
  ChartYAxis,
  ChartCartesianGrid,
  ChartTooltip,
  ChartLegend,
} from '@razorpay/blade/components';

const salesData = [
  { month: 'Jan', revenue: 4000, profit: 2000, expenses: 1000 },
  { month: 'Feb', revenue: 3000, profit: 1500, expenses: 800 },
  { month: 'Mar', revenue: 5000, profit: 3000, expenses: 1200 },
  { month: 'Apr', revenue: 4500, profit: 2500, expenses: 1100 },
];

const BasicBarChart = () => {
  return (
    <div style={{ width: '100%', height: '400px' }}>
      <ChartBarWrapper data={salesData}>
        <ChartCartesianGrid />
        <ChartXAxis dataKey="month" />
        <ChartYAxis />
        <ChartTooltip />
        <ChartLegend />
        <ChartBar
          dataKey="revenue"
          name="Revenue"
          color="data.background.categorical.blue.moderate"
        />
        <ChartBar
          dataKey="profit"
          name="Profit"
          color="data.background.categorical.green.moderate"
        />
        <ChartBar
          dataKey="expenses"
          name="Expenses"
          color="data.background.categorical.gold.moderate"
        />
      </ChartBarWrapper>
    </div>
  );
};
```

---

## BottomNav

## Component Name

BottomNav

## Description

BottomNav is a persistent navigation component designed for mobile interfaces, positioned at the bottom of the screen. It provides quick access to core functionalities through icons and labels, allowing users to navigate between primary destinations in an application. The component is optimized for touch interaction and follows mobile UI design patterns with clear visual indicators for active states.

## Important Constraints

- `BottomNav` component must have between 2 and 5 children

## TypeScript Types

The following types represent the props that the BottomNav component and its subcomponents accept. These types allow you to properly configure the navigation according to your app's structure.

````typescript
/**
 * Props for the BottomNav component
 */
type BottomNavProps = {
  /**
   * children slot of BottomNav, accepts BottomNavItem
   */
  children: React.ReactNode;

  /**
   * zIndex of BottomNav
   *
   * @default 100
   */
  zIndex?: number;
} & StyledPropsBlade &
  TestID &
  DataAnalyticsAttribute;

/**
 * Props for the BottomNavItem component
 */
type BottomNavItemProps = {
  /**
   * Title text of the BottomNavItem
   */
  title: string;

  /**
   * Icon rendered above the title.
   *
   * Accepts icon component from blade
   */
  icon: IconComponent;

  /**
   * href property of link
   *
   * maps to `to` property when react router is being used
   */
  href?: string;

  /**
   * HTML's `target` attribute for anchor links
   */
  target?: string;

  /**
   * HTML's `rel` tag of anchor links
   */
  rel?: string;

  /**
   * as prop to pass ReactRouter's Link component.
   *
   * ```jsx
   * import { NavLink } from 'react-router-dom';
   *
   * <BottomNavItem as={NavLink} />
   * ```
   */
  as?: React.ComponentType<any>;

  /**
   * Active state of the BottomNavItem.
   *
   * Use this to set the current page's active state using react router
   */
  isActive?: boolean;

  /**
   * onClick handler of BottomNavItem
   */
  onClick?: React.MouseEventHandler;
} & TestID &
  DataAnalyticsAttribute;
````

## Example

This example demonstrates how to implement BottomNav with React Router for a mobile application, including active state management and integration with side navigation.

```tsx
import React, { useState } from 'react';
import { BrowserRouter, Routes, Route, NavLink, useLocation, matchPath } from 'react-router-dom';
import {
  BottomNav,
  BottomNavItem,
  SideNav,
  SideNavBody,
  SideNavLink,
  Box,
  Text,
  HomeIcon,
  PaymentGatewayIcon,
  TransactionsIcon,
  PaymentLinkIcon,
  PaymentPagesIcon,
  MenuDotsIcon,
  CurrentAccountIcon,
  RazorpayIcon,
} from '@razorpay/blade/components';

// Sample page component to show when a route is matched
const PageContent = ({ title }) => (
  <Box padding="spacing.5" paddingBottom="spacing.6">
    <Text variant="body" size="medium">
      {title} Page Content
    </Text>
  </Box>
);

// Helper function to check if a route is active
const isItemActive = (
  location: { pathname: string },
  { href, activeOnLinks }: { href?: string; activeOnLinks?: string[] },
): boolean => {
  const isCurrentPathActive = Boolean(
    href && matchPath({ path: href, end: true }, location.pathname),
  );

  const isSubItemActive = Boolean(
    activeOnLinks?.find((link) => matchPath({ path: link, end: true }, location.pathname)),
  );

  return isCurrentPathActive || isSubItemActive;
};

// Custom BottomNavItem with React Router integration
const RouterBottomNavItem = (props) => {
  const { activeOnLinks, ...rest } = props;
  const location = useLocation();

  return (
    <BottomNavItem
      {...rest}
      as={NavLink}
      isActive={isItemActive(location, {
        href: props.href,
        activeOnLinks,
      })}
    />
  );
};

// Custom SideNavLink with React Router integration
const RouterSideNavLink = (props) => {
  const { activeOnLinks, ...rest } = props;
  const location = useLocation();

  return (
    <SideNavLink
      {...rest}
      as={NavLink}
      isActive={isItemActive(location, {
        href: props.href,
        activeOnLinks,
      })}
    />
  );
};

// Main App component with navigation implementation
const MobileAppExample = () => {
  const [isSideNavOpen, setIsSideNavOpen] = useState(false);

  // Bottom navigation items
  const mainNavItems = [
    {
      title: 'Home',
      href: '/',
      icon: HomeIcon,
    },
    {
      title: 'Payments',
      href: '/payments',
      icon: PaymentGatewayIcon,
    },
    {
      title: 'Transactions',
      href: '/transactions',
      icon: TransactionsIcon,
    },
    {
      title: 'Links',
      href: '/payment-links',
      icon: PaymentLinkIcon,
    },
  ];

  // Additional items for side navigation
  const sideNavItems = [
    {
      title: 'Pages',
      href: '/payment-pages',
      icon: PaymentPagesIcon,
    },
    {
      title: 'Account',
      href: '/account',
      icon: CurrentAccountIcon,
    },
    {
      title: 'Settings',
      href: '/settings',
      icon: RazorpayIcon,
    },
  ];

  return (
    <Box height="100vh" width="100%" position="relative">
      {/* Routes configuration */}
      <Routes>
        <Route path="/" element={<PageContent title="Home" />} />
        <Route path="/payments" element={<PageContent title="Payments" />} />
        <Route path="/transactions" element={<PageContent title="Transactions" />} />
        <Route path="/payment-links" element={<PageContent title="Payment Links" />} />
        <Route path="/payment-pages" element={<PageContent title="Payment Pages" />} />
        <Route path="/account" element={<PageContent title="Account" />} />
        <Route path="/settings" element={<PageContent title="Settings" />} />
      </Routes>

      {/* Side Navigation */}
      <SideNav
        isOpen={isSideNavOpen}
        onDismiss={() => setIsSideNavOpen(false)}
        position="absolute"
        zIndex={200}
      >
        <SideNavBody>
          {/* Include both main and extra navigation items in side nav */}
          {[...mainNavItems, ...sideNavItems].map((item) => (
            <RouterSideNavLink
              key={item.href}
              title={item.title}
              href={item.href}
              icon={item.icon}
              onClick={() => setIsSideNavOpen(false)}
            />
          ))}
        </SideNavBody>
      </SideNav>

      {/* Bottom Navigation */}
      <BottomNav
        position="fixed"
        bottom="spacing.0"
        left="spacing.0"
        testID="main-navigation"
        data-analytics="bottom-nav"
      >
        {/* First 3 main navigation items */}
        {mainNavItems.slice(0, 3).map((item) => (
          <RouterBottomNavItem
            key={item.href}
            title={item.title}
            href={item.href}
            icon={item.icon}
            testID={`nav-item-${item.title.toLowerCase()}`}
          />
        ))}

        {/* More button that opens side nav */}
        <BottomNavItem
          title="More"
          icon={MenuDotsIcon}
          onClick={() => setIsSideNavOpen(true)}
          testID="nav-item-more"
        />
      </BottomNav>
    </Box>
  );
};

// Wrap with router for complete example
const App = () => (
  <BrowserRouter>
    <MobileAppExample />
  </BrowserRouter>
);

export default App;
```

---

## BottomSheet

## Component Name

BottomSheet

## Description

BottomSheet is a component commonly used in mobile applications to display additional information or actions without obstructing the main content of the screen. It slides up from the bottom of the viewport and can be configured with various heights through snap points. BottomSheet provides a structured layout with optional header, body, and footer sections, making it ideal for presenting forms, selection menus, and detailed information in a mobile-friendly interface.

## TypeScript Types

The following types represent the props that the BottomSheet component and its subcomponents accept. These types allow you to properly configure the bottom sheet according to your needs.

```typescript
/**
 * Props for the main BottomSheet component
 */
type BottomSheetProps = {
  /**
   * Controls whether the BottomSheet is opened
   */
  isOpen: boolean;

  /**
   * Callback function when the sheet is dismissed
   */
  onDismiss: () => void;

  /**
   * Whether the bottom sheet can be dismissed by tapping backdrop, swiping down.
   * @default true
   */
  isDismissible?: boolean;

  /**
   * The content of the BottomSheet
   */
  children: React.ReactNode;

  /**
   * Array of numbers between 0 and 1 that define the height of the BottomSheet
   * Default is [0.35, 0.5, 0.85]
   */
  snapPoints?: number[];

  /**
   * Reference to the element that should receive focus when the BottomSheet opens
   * By default, focus is set to the close button
   */
  initialFocusRef?: React.RefObject<HTMLElement>;

  /**
   * The z-index value for the BottomSheet
   * @default 400
   */
  zIndex?: number;
} & TestID &
  DataAnalyticsAttribute;

/**
 * Props for the BottomSheetHeader component
 */
type BottomSheetHeaderProps = {
  /**
   * The title text of the BottomSheet
   */
  title?: string;

  /**
   * The subtitle text of the BottomSheet
   */
  subtitle?: string;

  /**
   * Element to be displayed next to the title
   * Accepts a Counter component
   */
  titleSuffix?: React.ReactNode;

  /**
   * Trailing element displayed on the right side of the header
   * Accepts one of Badge, Text, Button, Link
   */
  trailing?: React.ReactNode;

  /**
   * Whether to show a back button in the header
   * @default false
   */
  showBackButton?: boolean;

  /**
   * Callback function when the back button is clicked
   */
  onBackButtonClick?: () => void;

  /**
   * Leading element displayed on the left side of the header
   */
  leading?: React.ReactNode;
} & TestID &
  DataAnalyticsAttribute;

/**
 * Props for the BottomSheetBody component
 */
type BottomSheetBodyProps = {
  /**
   * The content of the BottomSheetBody
   */
  children: React.ReactNode;

  /**
   * Padding to be applied to the body
   * @default "spacing.5"
   */
  padding?: string;
} & TestID &
  DataAnalyticsAttribute;

/**
 * Props for the BottomSheetFooter component
 */
type BottomSheetFooterProps = {
  /**
   * The content of the BottomSheetFooter
   */
  children: React.ReactNode;
} & TestID &
  DataAnalyticsAttribute;
```

## Example

Here are several examples demonstrating different uses of the BottomSheet component:

### Basic BottomSheet with Terms and Conditions

This example shows a basic BottomSheet with header, body, and footer sections used for displaying terms and conditions with an agreement checkbox.

```tsx
import React, { useState } from 'react';
import {
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Button,
  Box,
  Text,
  Checkbox,
} from '@razorpay/blade/components';

const TermsAndConditionsBottomSheet = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [termsAccepted, setTermsAccepted] = useState(false);

  return (
    <>
      <Button onClick={() => setIsOpen(true)}>Open Terms & Conditions</Button>

      <BottomSheet isOpen={isOpen} onDismiss={() => setIsOpen(false)}>
        <BottomSheetHeader title="Terms & Conditions" subtitle="Read carefully before accepting" />
        <BottomSheetBody>
          <Text>
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla facilisi. Maecenas
            consequat, dolor vel lobortis ultrices, risus velit volutpat erat, ac pretium urna nibh
            sit amet magna. Donec tristique quam at lectus blandit, non eleifend dui dictum.
          </Text>
          <Text marginTop="spacing.3">
            Curabitur id neque vel metus tincidunt efficitur. Morbi vitae arcu lorem. Vivamus at
            tortor et metus placerat elementum vel ac neque. Nulla facilisi. Praesent vel dolor
            orci.
          </Text>
        </BottomSheetBody>
        <BottomSheetFooter>
          <Box
            display="flex"
            flexDirection="row"
            alignItems="center"
            justifyContent="space-between"
          >
            <Checkbox isChecked={termsAccepted} onChange={() => setTermsAccepted(!termsAccepted)}>
              I accept terms and conditions
            </Checkbox>
            <Button variant="primary" isDisabled={!termsAccepted} onClick={() => setIsOpen(false)}>
              Continue
            </Button>
          </Box>
        </BottomSheetFooter>
      </BottomSheet>
    </>
  );
};

export default TermsAndConditionsBottomSheet;
```

### Form with Custom Initial Focus

This example demonstrates a BottomSheet with form controls and custom initial focus reference, along with custom snap points.

```tsx
import React, { useRef, useState } from 'react';
import {
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Button,
  Box,
  Text,
  TextInput,
  ActionList,
  ActionListItem,
  ActionListItemIcon,
} from '@razorpay/blade/components';
import { CustomersIcon } from '@razorpay/blade/components';

const SearchUsersBottomSheet = () => {
  const [isOpen, setIsOpen] = useState(false);
  const searchInputRef = useRef(null);

  return (
    <>
      <Button onClick={() => setIsOpen(true)}>Search Users</Button>

      <BottomSheet
        isOpen={isOpen}
        onDismiss={() => setIsOpen(false)}
        initialFocusRef={searchInputRef}
        snapPoints={[0.4, 0.7, 0.95]} // Custom snap points
      >
        <BottomSheetHeader
          title="Search Users"
          showBackButton
          onBackButtonClick={() => setIsOpen(false)}
        />
        <BottomSheetBody>
          <TextInput
            label="Search for users"
            placeholder="Type a name or email"
            ref={searchInputRef}
            marginBottom="spacing.5"
          />

          <Text
            variant="body"
            size="small"
            color="surface.text.gray.muted"
            marginBottom="spacing.3"
          >
            Recently viewed users
          </Text>

          <ActionList>
            <ActionListItem
              title="Anurag Hazra"
              value="user1"
              leading={<ActionListItemIcon icon={CustomersIcon} />}
            />
            <ActionListItem
              title="Kamlesh Chandnani"
              value="user2"
              leading={<ActionListItemIcon icon={CustomersIcon} />}
            />
            <ActionListItem
              title="Divyanshu Maithani"
              value="user3"
              leading={<ActionListItemIcon icon={CustomersIcon} />}
            />
          </ActionList>
        </BottomSheetBody>
        <BottomSheetFooter>
          <Button isFullWidth onClick={() => setIsOpen(false)}>
            Done
          </Button>
        </BottomSheetFooter>
      </BottomSheet>
    </>
  );
};

export default SearchUsersBottomSheet;
```

### Header Variants and Radio Selection

This example shows all possible header variants with title, subtitle, titleSuffix, trailing, and back button, along with radio button selection.

```tsx
import React, { useState } from 'react';
import {
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Button,
  Badge,
  Counter,
  Radio,
  RadioGroup,
} from '@razorpay/blade/components';

const AddressSelectionBottomSheet = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [selectedAddress, setSelectedAddress] = useState('');

  return (
    <>
      <Button onClick={() => setIsOpen(true)}>Select Address</Button>

      <BottomSheet isOpen={isOpen} onDismiss={() => setIsOpen(false)}>
        <BottomSheetHeader
          title="Address Details"
          subtitle="Saving addresses will improve your checkout experience"
          titleSuffix={<Counter value={3} color="positive" />}
          trailing={<Badge color="positive">Action Needed</Badge>}
          showBackButton
          onBackButtonClick={() => setIsOpen(false)}
        />
        <BottomSheetBody>
          <RadioGroup
            label="Addresses"
            value={selectedAddress}
            onChange={({ value }) => setSelectedAddress(value)}
          >
            <Radio value="home">Home - 11850 Florida 24, Cedar Key, Florida</Radio>
            <Radio value="office-1">Office - 2033 Florida 21, Cedar Key, Florida</Radio>
            <Radio value="office-2">Work - 5938 New York, Main Street</Radio>
          </RadioGroup>
        </BottomSheetBody>
        <BottomSheetFooter>
          <Button isFullWidth variant="tertiary" marginBottom="spacing.3">
            Remove address
          </Button>
          <Button isFullWidth onClick={() => setIsOpen(false)}>
            Add address
          </Button>
        </BottomSheetFooter>
      </BottomSheet>
    </>
  );
};

export default AddressSelectionBottomSheet;
```

### Phone Verification Form with Validation

This example demonstrates a BottomSheet with form validation and error handling.

```tsx
import React, { useState } from 'react';
import {
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Button,
  Box,
  Text,
  TextInput,
  Link,
} from '@razorpay/blade/components';
import { ArrowRightIcon } from '@razorpay/blade/components';

const PhoneVerificationBottomSheet = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [phoneNumber, setPhoneNumber] = useState('');
  const [verificationError, setVerificationError] = useState('');

  const handleVerify = () => {
    if (!phoneNumber) {
      setVerificationError('Please enter a phone number');
      return;
    }
    setVerificationError('');
    setIsOpen(false);
    // Handle verification logic here
  };

  return (
    <>
      <Button onClick={() => setIsOpen(true)}>Verify Phone Number</Button>

      <BottomSheet isOpen={isOpen} onDismiss={() => setIsOpen(false)}>
        <BottomSheetHeader
          title="Verify Phone Number"
          showBackButton
          onBackButtonClick={() => setIsOpen(false)}
        />
        <BottomSheetBody>
          <TextInput
            label="Phone Number"
            placeholder="Enter your phone number"
            value={phoneNumber}
            onChange={({ value }) => setPhoneNumber(value)}
            errorText={verificationError}
            validationState={verificationError ? 'error' : 'none'}
            marginBottom="spacing.5"
          />

          <Text variant="body" size="small" textAlign="center">
            By continuing, you agree to our <Link href="#">Terms of Service</Link> and{' '}
            <Link href="#">Privacy Policy</Link>
          </Text>
        </BottomSheetBody>
        <BottomSheetFooter>
          <Box display="flex" flexDirection="column" gap="spacing.3">
            <Button isFullWidth icon={ArrowRightIcon} iconPosition="right" onClick={handleVerify}>
              Verify
            </Button>
            <Button isFullWidth variant="tertiary" onClick={() => setIsOpen(false)}>
              Cancel
            </Button>
          </Box>
        </BottomSheetFooter>
      </BottomSheet>
    </>
  );
};

export default PhoneVerificationBottomSheet;
```

### Integration with Dropdown

This example shows how to use BottomSheet with the Dropdown component.

```tsx
import React from 'react';
import {
  Dropdown,
  SelectInput,
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  ActionList,
  ActionListItem,
  ActionListItemIcon,
} from '@razorpay/blade/components';
import { CustomersIcon, ClockIcon, ThumbsUpIcon } from '@razorpay/blade/components';

const DropdownWithBottomSheet = () => {
  return (
    <Dropdown selectionType="single">
      <SelectInput label="Sort Items" />
      <BottomSheet>
        <BottomSheetHeader title="Sort By" />
        <BottomSheetBody>
          <ActionList>
            <ActionListItem
              leading={<ActionListItemIcon icon={CustomersIcon} />}
              title="Relevance (Default)"
              value="relevance"
            />
            <ActionListItem
              leading={<ActionListItemIcon icon={ClockIcon} />}
              title="Delivery Time"
              value="delivery-time"
            />
            <ActionListItem
              leading={<ActionListItemIcon icon={ThumbsUpIcon} />}
              title="Rating"
              value="rating"
            />
          </ActionList>
        </BottomSheetBody>
      </BottomSheet>
    </Dropdown>
  );
};

export default DropdownWithBottomSheet;
```

### Stacked BottomSheets

This example demonstrates how to implement a multi-step flow using stacked BottomSheets.

```tsx
import React, { useState } from 'react';
import {
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Button,
  Box,
  ActionList,
  ActionListItem,
  ActionListSection,
  ActionListItemIcon,
} from '@razorpay/blade/components';
import {
  CustomersIcon,
  ClockIcon,
  ThumbsUpIcon,
  TrendingUpIcon,
  TrendingDownIcon,
} from '@razorpay/blade/components';

const StackedBottomSheets = () => {
  const [isFirstSheetOpen, setIsFirstSheetOpen] = useState(false);
  const [isSecondSheetOpen, setIsSecondSheetOpen] = useState(false);

  const openSecondSheet = () => {
    setIsFirstSheetOpen(false);
    setIsSecondSheetOpen(true);
  };

  const backToFirstSheet = () => {
    setIsSecondSheetOpen(false);
    setIsFirstSheetOpen(true);
  };

  return (
    <>
      <Button onClick={() => setIsFirstSheetOpen(true)}>Open Multi-step Flow</Button>

      {/* First sheet with sort options */}
      <BottomSheet isOpen={isFirstSheetOpen} onDismiss={() => setIsFirstSheetOpen(false)}>
        <BottomSheetHeader title="Sort Options" subtitle="Choose how to organize your data" />
        <BottomSheetBody>
          <ActionList>
            <ActionListItem
              leading={<ActionListItemIcon icon={CustomersIcon} />}
              title="Relevance (Default)"
              value="relevance"
            />
            <ActionListItem
              leading={<ActionListItemIcon icon={ClockIcon} />}
              title="Delivery Time"
              value="delivery-time"
            />
            <ActionListItem
              leading={<ActionListItemIcon icon={ThumbsUpIcon} />}
              title="Rating"
              value="rating"
            />
            <ActionListItem
              leading={<ActionListItemIcon icon={TrendingUpIcon} />}
              title="Cost: Low to High"
              value="cost-low-high"
            />
            <ActionListItem
              leading={<ActionListItemIcon icon={TrendingDownIcon} />}
              title="Cost: High to Low"
              value="cost-high-low"
            />
          </ActionList>
        </BottomSheetBody>
        <BottomSheetFooter>
          <Button isFullWidth onClick={openSecondSheet}>
            Next: Filter Options
          </Button>
        </BottomSheetFooter>
      </BottomSheet>

      {/* Second sheet with filter options */}
      <BottomSheet isOpen={isSecondSheetOpen} onDismiss={() => setIsSecondSheetOpen(false)}>
        <BottomSheetHeader title="Filter By Cuisines" />
        <BottomSheetBody>
          <ActionList>
            <ActionListSection title="Asia">
              <ActionListItem title="Chinese" value="Chinese" />
              <ActionListItem title="Indian" value="Indian" />
              <ActionListItem title="Thai" value="Thai" />
              <ActionListItem title="Japanese" value="Japanese" />
            </ActionListSection>

            <ActionListSection title="Europe">
              <ActionListItem title="Italian" value="Italian" />
              <ActionListItem title="French" value="French" />
              <ActionListItem title="Spanish" value="Spanish" />
            </ActionListSection>
          </ActionList>
        </BottomSheetBody>
        <BottomSheetFooter>
          <Box display="flex" flexDirection="column" gap="spacing.3">
            <Button isFullWidth onClick={() => setIsSecondSheetOpen(false)}>
              Apply Filters
            </Button>
            <Button isFullWidth variant="tertiary" onClick={backToFirstSheet}>
              Back to Sort Options
            </Button>
          </Box>
        </BottomSheetFooter>
      </BottomSheet>
    </>
  );
};

export default StackedBottomSheets;
```

### BottomSheet with Zero Padding

This example shows how to create a BottomSheet with zero padding for full-width content like images or banners.

```tsx
import React, { useState } from 'react';
import {
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Button,
  Box,
  Text,
  Heading,
} from '@razorpay/blade/components';

const ZeroPaddingBottomSheet = () => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <Button onClick={() => setIsOpen(true)}>Open Full-Width Content</Button>

      <BottomSheet isOpen={isOpen} onDismiss={() => setIsOpen(false)}>
        <BottomSheetHeader />
        <BottomSheetBody padding="spacing.0">
          <Box>
            {/* Full-width banner/image container */}
            <Box
              position="relative"
              height="200px"
              backgroundColor="surface.background.cloud.subtle"
              display="flex"
              alignItems="flex-end"
              padding="spacing.5"
            >
              <Heading size="large" color="surface.text.gray.normal">
                All-in-one Management Platform
              </Heading>
            </Box>

            {/* Content with padding */}
            <Box padding="spacing.5">
              <Text>
                We bring together all services in ONE place to deliver a seamless user experience
                for you. Work with our experts to ensure your transfers are always compliant, safe &
                effortless.
              </Text>
              <Text marginTop="spacing.3" color="surface.text.gray.muted">
                100% secure | Instant payouts | Unbeatable pricing
              </Text>
            </Box>
          </Box>
        </BottomSheetBody>
        <BottomSheetFooter>
          <Button isFullWidth>Talk To Our Experts</Button>
        </BottomSheetFooter>
      </BottomSheet>
    </>
  );
};

export default ZeroPaddingBottomSheet;
```

---

## Box

## Component Name

Box

## Description

Box is a versatile layout primitive component that serves as the foundational building block for creating complex layouts in Blade applications. It provides a comprehensive set of styling and layout properties through a consistent prop-based API, supporting responsive design, flexbox layouts, and styled-system patterns. Box allows developers to create consistent layouts without writing custom CSS while maintaining design system constraints.

## Important Constraints

- `backgroundColor` prop only accepts `transparent`, `surface.background.*`, and `overlay.*` tokens

## Design Guidelines

- Prefer `Card` component instead of this for adding card with shadows. Box component should be primarily used for non-visual layouts (e.g. creating containers, grids, positioning items, etc)

## TypeScript Types

The following types represent the props that the Box component accepts. These types allow you to properly configure the component according to your needs.

```typescript
/**
 * Type for responsive values, allowing different values at different breakpoints
 */
type ResponsiveValue<T> =
  | T
  | {
      base?: T;
      xs?: T;
      s?: T;
      m?: T;
      l?: T;
      xl?: T;
    };

/**
 * Props for the Box component
 */
type BoxProps = {
  /**
   * The HTML element to render the Box as
   * @default 'div'
   */
  as?: 'div' | 'section' | 'article' | 'main' | 'header' | 'footer' | 'aside' | 'nav';

  /**
   * ID attribute of the Box
   */
  id?: string;

  /**
   * The children to render inside the Box
   */
  children?: React.ReactNode;

  /**
   * Flex property - defines how the item will grow or shrink
   * @example "1" | "auto" | "initial" | "none"
   */
  flex?: ResponsiveValue<string | number>;

  /**
   * Flex direction property - defines the direction of the flex items
   * @example "row" | "column" | "row-reverse" | "column-reverse"
   */
  flexDirection?: ResponsiveValue<string>;

  /**
   * Flex wrap property - defines whether flex items should wrap
   * @example "nowrap" | "wrap" | "wrap-reverse"
   */
  flexWrap?: ResponsiveValue<string>;

  /**
   * Flex basis property - defines the initial main size of a flex item
   */
  flexBasis?: ResponsiveValue<string | number>;

  /**
   * Flex grow property - defines how much a flex item will grow
   */
  flexGrow?: ResponsiveValue<string | number>;

  /**
   * Flex shrink property - defines how much a flex item will shrink
   */
  flexShrink?: ResponsiveValue<string | number>;

  /**
   * Display property - defines the display type of an element
   * @example "flex" | "block" | "inline" | "inline-block" | "grid" | "none"
   */
  display?: ResponsiveValue<string>;

  /**
   * Align items property - defines how flex items are aligned along the cross axis
   * @example "flex-start" | "flex-end" | "center" | "baseline" | "stretch"
   */
  alignItems?: ResponsiveValue<string>;

  /**
   * Align self property - overrides the align-items property for a specific flex item
   */
  alignSelf?: ResponsiveValue<string>;

  /**
   * Justify content property - defines how flex items are aligned along the main axis
   * @example "flex-start" | "flex-end" | "center" | "space-between" | "space-around" | "space-evenly"
   */
  justifyContent?: ResponsiveValue<string>;

  /**
   * Gap property - defines the gap between flex/grid items
   */
  gap?: ResponsiveValue<SpacingValueType>;

  /**
   * Margin properties
   */
  margin?: ResponsiveValue<SpacingValueType>;
  marginTop?: ResponsiveValue<SpacingValueType>;
  marginRight?: ResponsiveValue<SpacingValueType>;
  marginBottom?: ResponsiveValue<SpacingValueType>;
  marginLeft?: ResponsiveValue<SpacingValueType>;
  marginX?: ResponsiveValue<SpacingValueType>;
  marginY?: ResponsiveValue<SpacingValueType>;

  /**
   * Padding properties
   */
  padding?: ResponsiveValue<SpacingValueType>;
  paddingTop?: ResponsiveValue<SpacingValueType>;
  paddingRight?: ResponsiveValue<SpacingValueType>;
  paddingBottom?: ResponsiveValue<SpacingValueType>;
  paddingLeft?: ResponsiveValue<SpacingValueType>;
  paddingX?: ResponsiveValue<SpacingValueType>;
  paddingY?: ResponsiveValue<SpacingValueType>;

  /**
   * Width property
   * @example "100%" | "200px" | "auto" | "fit-content"
   */
  width?: ResponsiveValue<string | number>;

  /**
   * Height property
   * @example "100%" | "200px" | "auto" | "fit-content"
   */
  height?: ResponsiveValue<string | number>;

  /**
   * Min-width property
   */
  minWidth?: ResponsiveValue<string | number>;

  /**
   * Min-height property
   */
  minHeight?: ResponsiveValue<string | number>;

  /**
   * Max-width property
   */
  maxWidth?: ResponsiveValue<string | number>;

  /**
   * Max-height property
   */
  maxHeight?: ResponsiveValue<string | number>;

  /**
   * Background color property
   * Uses theme color tokens
   * @example "surface.background.gray.intense"
   */
  backgroundColor?: ResponsiveValue<string>;

  /**
   * Border properties
   */
  border?: ResponsiveValue<string>;
  borderTop?: ResponsiveValue<string>;
  borderRight?: ResponsiveValue<string>;
  borderBottom?: ResponsiveValue<string>;
  borderLeft?: ResponsiveValue<string>;
  borderColor?: ResponsiveValue<string>;
  borderRadius?: ResponsiveValue<string>;
  borderStyle?: ResponsiveValue<string>;
  borderWidth?: ResponsiveValue<string>;

  /**
   * Position property
   * @example "static" | "relative" | "absolute" | "fixed" | "sticky"
   */
  position?: ResponsiveValue<string>;

  /**
   * Top, right, bottom, left properties for positioning
   */
  top?: ResponsiveValue<string | number>;
  right?: ResponsiveValue<string | number>;
  bottom?: ResponsiveValue<string | number>;
  left?: ResponsiveValue<string | number>;

  /**
   * Z-index property
   */
  zIndex?: ResponsiveValue<number | string>;

  /**
   * Overflow properties
   */
  overflow?: ResponsiveValue<string>;
  overflowX?: ResponsiveValue<string>;
  overflowY?: ResponsiveValue<string>;

  /**
   * Elevation - applies box-shadow based on theme elevation tokens
   * @example "lowRaised" | "midRaised" | "highRaised"
   */
  elevation?: 'lowRaised' | 'midRaised' | 'highRaised';

  /**
   * Transform property
   */
  transform?: string;

  /**
   * Transform origin property
   */
  transformOrigin?: string;

  /**
   * Clip path property
   */
  clipPath?: string;

  /**
   * Event handlers
   */
  onMouseOver?: React.MouseEventHandler;
  onMouseEnter?: React.MouseEventHandler;
  onMouseLeave?: React.MouseEventHandler;
  onScroll?: React.UIEventHandler;
  onDragStart?: React.DragEventHandler;
  onDragEnd?: React.DragEventHandler;
  onDragEnter?: React.DragEventHandler;
  onDragOver?: React.DragEventHandler;
  onDragLeave?: React.DragEventHandler;
  onDrop?: React.DragEventHandler;
} & TestID &
  DataAnalyticsAttribute;

/**
 * Type for Box ref
 */
type BoxRefType = HTMLElement;
```

## Example

Here are comprehensive examples demonstrating the versatility of the Box component:

### Responsive Layout with Flexbox and Styling

This example demonstrates a responsive layout with flexbox properties, styling, and elevation.

```tsx
import React from 'react';
import { Box, Text, Heading, Button, RazorpayIcon } from '@razorpay/blade/components';

const ResponsiveLayout = () => {
  return (
    <Box
      // Responsive container with padding that changes at different breakpoints
      padding={{ base: 'spacing.3', m: 'spacing.5' }}
      backgroundColor="surface.background.gray.intense"
      borderRadius="large"
      width="100%"
      maxWidth="800px"
      margin={{ base: 'spacing.0', m: 'auto' }}
    >
      <Heading size="large" marginBottom="spacing.5">
        Responsive Layout
      </Heading>

      {/* Responsive grid */}
      <Box
        display="flex"
        flexDirection={{ base: 'column', m: 'row' }}
        flexWrap="wrap"
        gap="spacing.4"
      >
        <Box
          flex={{ base: 1, m: 1 }}
          flexBasis={{ base: '100%', m: '45%' }}
          backgroundColor="surface.background.gray.intense"
          borderRadius="medium"
          padding="spacing.4"
          elevation="lowRaised"
          overflow="hidden"
          position="relative"
        >
          <Box
            display="flex"
            alignItems="center"
            justifyContent="space-between"
            marginBottom="spacing.3"
          >
            <Heading size="small">Basic Plan</Heading>
            <Box
              backgroundColor="surface.background.primary.subtle"
              padding="spacing.2"
              borderRadius="round"
            >
              <RazorpayIcon size="medium" />
            </Box>
          </Box>

          <Text marginBottom="spacing.3">
            Perfect for individuals and small teams getting started with our platform.
          </Text>

          <Box marginY="spacing.3">
            <Box display="flex" justifyContent="space-between" marginBottom="spacing.2">
              <Text>Storage</Text>
              <Text>10GB</Text>
            </Box>
            <Box display="flex" justifyContent="space-between" marginBottom="spacing.2">
              <Text>Users</Text>
              <Text>Up to 5</Text>
            </Box>
            <Box display="flex" justifyContent="space-between">
              <Text>Support</Text>
              <Text>Email</Text>
            </Box>
          </Box>

          <Box marginTop="spacing.4">
            <Button variant="secondary" isFullWidth>
              Choose Plan
            </Button>
          </Box>
        </Box>

        <Box
          flex={{ base: 1, m: 1 }}
          flexBasis={{ base: '100%', m: '45%' }}
          backgroundColor="surface.background.primary.intense"
          borderRadius="medium"
          padding="spacing.4"
          elevation="midRaised"
          overflow="hidden"
          position="relative"
        >
          <Box
            position="absolute"
            top="spacing.2"
            right="spacing.2"
            backgroundColor="surface.background.primary.subtle"
            borderRadius="medium"
            padding="spacing.2"
          >
            <Text size="small" color="interactive.text.primary.normal">
              Popular
            </Text>
          </Box>

          <Box
            display="flex"
            alignItems="center"
            justifyContent="space-between"
            marginBottom="spacing.3"
          >
            <Text weight="semibold">Pro Plan</Text>
            <Box
              backgroundColor="surface.background.gray.intense"
              padding="spacing.2"
              borderRadius="round"
            >
              <RazorpayIcon size="medium" color="surface.icon.staticWhite.normal" />
            </Box>
          </Box>

          <Text marginBottom="spacing.3">
            Enhanced features for growing businesses and professional teams.
          </Text>

          <Box marginY="spacing.3">
            <Box display="flex" justifyContent="space-between" marginBottom="spacing.2">
              <Text>Storage</Text>
              <Text>100GB</Text>
            </Box>
            <Box display="flex" justifyContent="space-between" marginBottom="spacing.2">
              <Text>Users</Text>
              <Text>Up to 20</Text>
            </Box>
            <Box display="flex" justifyContent="space-between">
              <Text>Support</Text>
              <Text>Priority</Text>
            </Box>
          </Box>

          <Box marginTop="spacing.4">
            <Button variant="primary" isFullWidth>
              Choose Plan
            </Button>
          </Box>
        </Box>
      </Box>
    </Box>
  );
};

export default ResponsiveLayout;
```

### Advanced Positioning and Transformations

This example demonstrates how to use Box with advanced positioning techniques, transformations, and custom styling.

```tsx
import React from 'react';
import { Box, Text, Button } from '@razorpay/blade/components';

const AdvancedPositioningExample = () => {
  return (
    <Box
      // Container for the example
      position="relative"
      height="400px"
      width="100%"
      backgroundColor="surface.background.gray.intense"
      borderRadius="large"
      overflow="hidden"
      padding="spacing.5"
    >
      {/* Background decorative elements */}
      <Box
        position="absolute"
        top="-50px"
        right="-50px"
        width="200px"
        height="200px"
        borderRadius="round"
        backgroundColor="surface.background.primary.subtle"
        clipPath="circle(50% at 50% 50%)"
      />

      <Box
        position="absolute"
        bottom="-30px"
        left="20%"
        width="150px"
        height="150px"
        borderRadius="round"
        backgroundColor="surface.background.cloud.subtle"
        transform="rotate(45deg)"
      />

      {/* Content container */}
      <Box
        position="relative"
        zIndex={1} // Ensures content is above background elements
        display="flex"
        flexDirection="column"
        height="100%"
      >
        <Text variant="body" size="large" marginBottom="spacing.5">
          Advanced positioning example
        </Text>

        {/* Box with transformation */}
        <Box
          backgroundColor="surface.background.gray.subtle"
          borderRadius="medium"
          padding="spacing.4"
          elevation="midRaised"
          marginBottom="spacing.5"
          transform="rotate(-2deg)"
          transformOrigin="center"
        >
          <Text>This box has a slight rotation applied to create visual interest.</Text>
        </Box>

        {/* Overlapping elements */}
        <Box position="relative" height="100px" marginBottom="spacing.4">
          <Box
            position="absolute"
            left="spacing.0"
            top="spacing.0"
            width="80px"
            height="80px"
            backgroundColor="surface.background.primary.intense"
            borderRadius="medium"
            display="flex"
            alignItems="center"
            justifyContent="center"
            zIndex={1}
          >
            <Text>Box 1</Text>
          </Box>

          <Box
            position="absolute"
            left="40px"
            top="20px"
            width="80px"
            height="80px"
            backgroundColor="surface.background.cloud.intense"
            borderRadius="medium"
            display="flex"
            alignItems="center"
            justifyContent="center"
            zIndex={2}
          >
            <Text color="surface.text.onCloud.onIntense">Box 2</Text>
          </Box>

          <Box
            position="absolute"
            left="80px"
            top="40px"
            width="80px"
            height="80px"
            backgroundColor="surface.background.gray.intense"
            borderRadius="medium"
            display="flex"
            alignItems="center"
            justifyContent="center"
            zIndex={3}
          >
            <Text>Box 3</Text>
          </Box>
        </Box>

        {/* Custom shape using clipPath */}
        <Box
          height="80px"
          backgroundColor="surface.background.primary.subtle"
          padding="spacing.4"
          clipPath="polygon(0% 0%, 90% 0%, 100% 50%, 90% 100%, 0% 100%)"
          display="flex"
          alignItems="center"
        >
          <Text>Custom shape using clipPath</Text>
        </Box>
      </Box>
    </Box>
  );
};

export default AdvancedPositioningExample;
```

### Responsive Grid Layout with Event Handling

This example demonstrates a responsive grid layout with event handlers.

```tsx
import React, { useState } from 'react';
import { Box, Text, Heading } from '@razorpay/blade/components';

const ResponsiveGridExample = () => {
  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);
  const [draggedItem, setDraggedItem] = useState<number | null>(null);

  const handleDrop = (e: React.DragEvent, destinationIndex: number) => {
    e.preventDefault();
    if (draggedItem !== null) {
      console.log(`Moved item from index ${draggedItem} to ${destinationIndex}`);
    }
    setDraggedItem(null);
  };

  const gridItems: Array<{
    title: string;
    color:
      | 'surface.background.primary.intense'
      | 'surface.background.cloud.intense'
      | 'surface.background.primary.subtle'
      | 'surface.background.gray.intense'
      | 'surface.background.gray.moderate'
      | 'surface.background.cloud.subtle';
  }> = [
    { title: 'Analytics', color: 'surface.background.primary.intense' },
    { title: 'Customers', color: 'surface.background.cloud.intense' },
    { title: 'Payments', color: 'surface.background.primary.subtle' },
    { title: 'Products', color: 'surface.background.gray.intense' },
    { title: 'Settings', color: 'surface.background.gray.moderate' },
    { title: 'Reports', color: 'surface.background.cloud.subtle' },
  ];

  return (
    <Box
      // Container
      padding="spacing.5"
      backgroundColor="surface.background.gray.intense"
      borderRadius="large"
    >
      <Heading size="large" marginBottom="spacing.5">
        Responsive Grid Layout
      </Heading>

      <Text marginBottom="spacing.4">
        This grid adapts to screen size and supports hover effects and drag-and-drop.
      </Text>

      {/* Grid container */}
      <Box display="flex" flexWrap="wrap" gap="spacing.4">
        {gridItems.map((item, index) => (
          <Box
            key={index}
            // Responsive sizing
            flex={1}
            flexBasis={{ base: '100%', s: 'calc(50% - 8px)', m: 'calc(33.333% - 16px)' }}
            backgroundColor={item.color}
            borderRadius="medium"
            padding="spacing.4"
            // Elevation changes on hover
            elevation={hoveredIndex === index ? 'highRaised' : 'lowRaised'}
            // Transform on hover
            transform={hoveredIndex === index ? 'translateY(-4px)' : 'none'}
            // Drag and drop handlers
            draggable
            onDragStart={(e) => {
              setDraggedItem(index);
              e.dataTransfer.setData('text/plain', index.toString());
            }}
            onDragEnd={() => setDraggedItem(null)}
            onDragOver={(e) => e.preventDefault()}
            onDrop={(e) => handleDrop(e, index)}
            // Mouse event handlers
            onMouseEnter={() => setHoveredIndex(index)}
            onMouseLeave={() => setHoveredIndex(null)}
          >
            <Text
              color={
                item.color.includes('primary.intense') || item.color.includes('gray.intense')
                  ? 'surface.text.staticWhite.normal'
                  : 'surface.text.gray.normal'
              }
              weight="semibold"
            >
              {item.title}
            </Text>
          </Box>
        ))}
      </Box>
    </Box>
  );
};

export default ResponsiveGridExample;
```

---

## Breadcrumb

## Component Name

Breadcrumb

## Description

Breadcrumbs are navigational components that display the user's current location within an application's hierarchy. They provide a clear path back to previous pages or sections, enhancing user orientation and enabling quick navigation between related pages. Breadcrumbs are particularly useful in applications with multiple levels of content organization, helping users understand their current context and navigate efficiently.

## TypeScript Types

The following types represent the props that the Breadcrumb component and its subcomponent BreadcrumbItem accept. These types allow you to properly configure the navigation according to your needs.

```typescript
/**
 * Props for the Breadcrumb component
 */
type BreadcrumbProps = {
  /**
   * The children of the Breadcrumb component
   * Should be BreadcrumbItem components
   */
  children: React.ReactNode;

  /**
   * The size of the Breadcrumb
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * The color scheme of the Breadcrumb
   * @default 'primary'
   */
  color?: 'primary' | 'neutral' | 'white';

  /**
   * Whether to show a separator after the last item
   * @default false
   */
  showLastSeparator?: boolean;
} & StyledPropsBlade &
  DataAnalyticsAttribute;

/**
 * Props for the BreadcrumbItem component
 */
type BreadcrumbItemProps = {
  /**
   * The content of the BreadcrumbItem
   * Not required when using icon-only
   */
  children?: React.ReactNode;

  /**
   * The URL that the breadcrumb item links to
   */
  href?: string;

  /**
   * Icon to display before the item text
   * Can be used alone with accessibilityLabel for icon-only items
   */
  icon?: IconComponent;

  /**
   * Whether this item represents the current page
   * @default false
   */
  isCurrentPage?: boolean;

  /**
   * Accessible label for the breadcrumb item
   * Required for icon-only items
   */
  accessibilityLabel?: string;

  /**
   * Called when the item is clicked
   */
  onClick?: React.MouseEventHandler<HTMLAnchorElement | HTMLSpanElement>;

  /**
   * For advanced use cases: render with a custom component (e.g., React Router's Link)
   */
  as?: React.ElementType;
} & DataAnalyticsAttribute;

/**
 * Type for icon components
 */
type IconComponent = React.ComponentType<{
  size?: 'small' | 'medium' | 'large';
  color?: string;
}>;
```

## Example

The following examples demonstrate how to use the Breadcrumb component in various scenarios.

### Basic Breadcrumb with Different Sizes and Colors

This example demonstrates Breadcrumbs with different sizes, colors, and on different backgrounds.

```tsx
import React from 'react';
import { Box, Breadcrumb, BreadcrumbItem, HomeIcon } from '@razorpay/blade/components';

const BreadcrumbExample = () => {
  return (
    <Box padding="spacing.4">
      <Breadcrumb size="medium" color="primary" data-analytics="breadcrumb-primary">
        <BreadcrumbItem icon={HomeIcon} href="/home" accessibilityLabel="Home" />
        <BreadcrumbItem href="/dashboard">Dashboard</BreadcrumbItem>
        <BreadcrumbItem href="/payments">Payments</BreadcrumbItem>
        <BreadcrumbItem isCurrentPage href="/settlements">
          Settlements
        </BreadcrumbItem>
      </Breadcrumb>
    </Box>
  );
};

export default BreadcrumbExample;
```

### React Router Integration

This example demonstrates how to integrate the Breadcrumb component with React Router for dynamic navigation.

```tsx
import React from 'react';
import {
  Box,
  Breadcrumb,
  BreadcrumbItem,
  HomeIcon,
  CreditCardIcon,
  FolderIcon,
} from '@razorpay/blade/components';
import { useLocation, Link as RouterLink, matchPath } from 'react-router-dom';

// Custom BreadcrumbItem that integrates with React Router
const RouterBreadcrumbItem = (props) => {
  const location = useLocation();
  const { to, children, icon, ...rest } = props;

  // Check if this item matches the current location
  const isCurrentPage = matchPath({ path: to, end: true }, location.pathname) !== null;

  return (
    <BreadcrumbItem as={RouterLink} href={to} icon={icon} isCurrentPage={isCurrentPage} {...rest}>
      {children}
    </BreadcrumbItem>
  );
};

// Breadcrumb based on the current route
const DynamicBreadcrumb = () => {
  const location = useLocation();
  const pathSegments = location.pathname.split('/').filter(Boolean);

  // Generate breadcrumb items based on the path
  const getItems = () => {
    const items = [];
    let currentPath = '';

    // Always include home
    items.push(
      <RouterBreadcrumbItem key="home" to="/" icon={HomeIcon} accessibilityLabel="Home" />,
    );

    // Add items for each path segment
    pathSegments.forEach((segment, index) => {
      currentPath += `/${segment}`;

      // Get appropriate icon and label based on the segment
      let icon = null;
      let label = segment.charAt(0).toUpperCase() + segment.slice(1);

      if (segment === 'products') icon = FolderIcon;
      if (segment === 'payments') icon = CreditCardIcon;

      items.push(
        <RouterBreadcrumbItem key={currentPath} to={currentPath} icon={icon}>
          {label}
        </RouterBreadcrumbItem>,
      );
    });

    return items;
  };

  return (
    <Box padding="spacing.4">
      <Breadcrumb
        size="medium"
        color={location.pathname.includes('/payments') ? 'primary' : 'neutral'}
      >
        {getItems()}
      </Breadcrumb>
    </Box>
  );
};

export default DynamicBreadcrumb;
```

### Responsive Breadcrumb with Multi-line Wrapping

This example demonstrates a responsive breadcrumb that wraps to multiple lines on smaller screens.

```tsx
import React from 'react';
import {
  Box,
  Breadcrumb,
  BreadcrumbItem,
  Text,
  HomeIcon,
  FolderIcon,
} from '@razorpay/blade/components';

const ResponsiveBreadcrumb = () => {
  // Example deep navigation structure
  const navigationItems = [
    { label: 'Home', href: '/home', icon: HomeIcon },
    { label: 'Products', href: '/products' },
    { label: 'Electronics', href: '/products/electronics', icon: FolderIcon },
    { label: 'Computers', href: '/products/electronics/computers' },
    { label: 'Laptops', href: '/products/electronics/computers/laptops' },
    { label: 'Gaming Laptops', href: '/products/electronics/computers/laptops/gaming' },
    { label: 'Accessories', href: '/products/electronics/computers/laptops/gaming/accessories' },
    {
      label: 'Product Details',
      href: '/products/electronics/computers/laptops/gaming/accessories/details',
      isCurrentPage: true,
    },
  ];

  return (
    <Box
      width={{ base: '100%', m: '80%', l: '100%' }}
      padding="spacing.4"
      backgroundColor="surface.background.gray.subtle"
      borderRadius="medium"
    >
      <Text variant="body" size="medium" marginBottom="spacing.3">
        Breadcrumb automatically wraps to multiple lines when needed:
      </Text>

      <Breadcrumb size="medium" color="primary">
        {navigationItems.map((item, index) => (
          <BreadcrumbItem
            key={index}
            href={item.href}
            icon={item.icon}
            isCurrentPage={item.isCurrentPage}
            accessibilityLabel={item.icon && !item.label ? item.label : undefined}
          >
            {item.label}
          </BreadcrumbItem>
        ))}
      </Breadcrumb>
    </Box>
  );
};

export default ResponsiveBreadcrumb;
```

---

## Button

## Component Name

Button

## Description

The Button component is a versatile interactive element used for triggering actions within an application. It supports multiple variants, sizes, and colors to accommodate different UI requirements and hierarchies. Buttons can contain text, icons, or both, and feature various states including disabled and loading to provide clear feedback to users during interactions.

## Important Constraints

- `variant="tertiary"` can only be used with `color="primary"` or `color="white"`

## TypeScript Types

The following types represent the props that the Button component accepts. These types allow you to properly configure the button according to your needs.

```typescript
/**
 * Props for the Button component
 */
type ButtonProps = {
  /**
   * The content of the button
   */
  children?: React.ReactNode;

  /**
   * Button variant that defines the visual style
   * @default 'primary'
   */
  variant?: 'primary' | 'secondary' | 'tertiary';

  /**
   * Color theme of the button
   * Note: Not all color and variant combinations are valid
   * @default 'primary'
   */
  color?: 'primary' | 'white' | 'positive' | 'negative';

  /**
   * Icon to display in the button
   * Accepts an icon component from Blade
   */
  icon?: IconComponent;

  /**
   * Position of the icon relative to the button text
   * @default 'left'
   */
  iconPosition?: 'left' | 'right';

  /**
   * Size of the button
   * @default 'medium'
   */
  size?: 'xsmall' | 'small' | 'medium' | 'large';

  /**
   * Whether the button is disabled
   * @default false
   */
  isDisabled?: boolean;

  /**
   * Whether the button is in a loading state
   * @default false
   */
  isLoading?: boolean;

  /**
   * Whether the button should take the full width of its container
   * @default false
   */
  isFullWidth?: boolean;

  /**
   * The accessible label for the button
   * Required for icon-only buttons
   */
  accessibilityLabel?: string;

  /**
   * Function called when the button is clicked
   */
  onClick?: React.MouseEventHandler<HTMLButtonElement | HTMLAnchorElement>;

  /**
   * URL that the button should navigate to when clicked
   * When provided, the button renders as an anchor (<a>) element
   */
  href?: string;

  /**
   * Where to open the linked URL
   * Only applicable when href is provided
   */
  target?: '_blank' | '_self' | '_parent' | '_top';

  /**
   * Relationship between the current page and the linked URL
   * Only applicable when href is provided
   */
  rel?: string;

  /**
   * The type of the button element
   * @default 'button'
   */
  type?: 'button' | 'submit' | 'reset';

  /**
   * Ref object for the button element
   */
  ref?: React.RefObject<HTMLButtonElement | HTMLAnchorElement>;
} & StyledPropsBlade &
  TestID &
  DataAnalyticsAttribute;

/**
 * Type for icon components
 */
type IconComponent = React.ComponentType<{
  size?: 'small' | 'medium' | 'large';
  color?: string;
}>;
```

## Example

Here are comprehensive examples demonstrating various ways to use the Button component:

### Basic Button Variants, Sizes, and Colors

This example demonstrates different button variants, sizes, and colors in a payment form.

```tsx
import React, { useState } from 'react';
import {
  Button,
  Box,
  Text,
  Heading,
  CreditCardIcon,
  ArrowRightIcon,
  ShieldIcon,
} from '@razorpay/blade/components';

const PaymentFormExample = () => {
  const [isProcessing, setIsProcessing] = useState(false);

  const handlePayment = () => {
    setIsProcessing(true);
    // Simulate payment processing
    setTimeout(() => {
      setIsProcessing(false);
      // Handle success
    }, 2000);
  };

  return (
    <Box
      padding="spacing.5"
      backgroundColor="surface.background.gray.subtle"
      borderRadius="medium"
      maxWidth="500px"
    >
      <Heading size="large" marginBottom="spacing.4">
        Complete Payment
      </Heading>

      <Text marginBottom="spacing.5">
        Please select a payment option and complete your transaction.
      </Text>

      {/* Primary button - Large size with icon on the right */}
      <Button
        variant="primary"
        color="primary"
        size="large"
        icon={CreditCardIcon}
        iconPosition="right"
        isFullWidth
        isLoading={isProcessing}
        onClick={handlePayment}
        marginBottom="spacing.4"
        testID="pay-button"
        data-analytics="payment-button-click"
      >
        Pay Now â‚¹1,999
      </Button>

      {/* Secondary button - Medium size */}
      <Button
        variant="secondary"
        color="primary"
        size="medium"
        icon={ArrowRightIcon}
        iconPosition="right"
        isFullWidth
        marginBottom="spacing.4"
        onClick={() => console.log('Save for later')}
      >
        Save for Later
      </Button>

      {/* Tertiary button - Small size with left icon */}
      <Button
        variant="tertiary"
        color="primary"
        size="small"
        icon={ShieldIcon}
        iconPosition="left"
        href="https://razorpay.com/terms"
        target="_blank"
        rel="noopener noreferrer"
        marginBottom="spacing.5"
      >
        View Terms & Conditions
      </Button>

      {/* Extra small icon-only button */}
      <Box display="flex" justifyContent="flex-end">
        <Button
          variant="tertiary"
          size="xsmall"
          icon={CreditCardIcon}
          accessibilityLabel="View payment methods"
          onClick={() => console.log('View payment methods')}
        />
      </Box>
    </Box>
  );
};

export default PaymentFormExample;
```

### Interactive Button with State Management

This example demonstrates buttons with dynamic states and interactions.

```tsx
import React, { useState } from 'react';
import { Button, Box, Text, CheckIcon, RefreshIcon } from '@razorpay/blade/components';

const SimpleToggleExample = () => {
  const [isActive, setIsActive] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const handleActivate = () => {
    setIsLoading(true);
    // Simulate API call
    setTimeout(() => {
      setIsLoading(false);
      setIsActive(true);
    }, 1000);
  };

  const handleReset = () => {
    setIsActive(false);
  };

  return (
    <Box
      padding="spacing.5"
      backgroundColor="surface.background.gray.subtle"
      borderRadius="medium"
      maxWidth="400px"
    >
      <Text marginBottom="spacing.4">
        {isActive ? 'Feature is now active!' : 'Activate this feature to continue'}
      </Text>

      <Box display="flex" gap="spacing.3">
        {!isActive ? (
          <Button
            variant="primary"
            icon={CheckIcon}
            iconPosition="right"
            isLoading={isLoading}
            onClick={handleActivate}
          >
            Activate
          </Button>
        ) : (
          <Button variant="secondary" icon={RefreshIcon} iconPosition="left" onClick={handleReset}>
            Reset
          </Button>
        )}
      </Box>
    </Box>
  );
};

export default SimpleToggleExample;
```

---

## ButtonGroup

## Component Name

ButtonGroup

## Description

The ButtonGroup component is used to group related buttons together, creating a cohesive set of actions with consistent styling and spacing. It's ideal for toolbars, segmented controls, or action areas where multiple related options are presented. ButtonGroup automatically handles proper spacing and visual connection between buttons to create a unified control.

## Important Constraints

- `ButtonGroup` component only accepts `Button`, `Dropdown`, `Tooltip`, and `Popover` components as children

## TypeScript Types

The following types represent the props that the ButtonGroup component accepts. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the ButtonGroup component
 */
type ButtonGroupProps = {
  /**
   * The buttons to be grouped
   */
  children: React.ReactNode;

  /**
   * The visual style of the buttons
   * @default 'primary'
   */
  variant?: 'primary' | 'secondary' | 'tertiary';

  /**
   * The size of the buttons
   * @default 'medium'
   */
  size?: 'xsmall' | 'small' | 'medium' | 'large';

  /**
   * The color theme of the buttons
   * @default 'primary'
   */
  color?: 'primary' | 'white' | 'positive' | 'negative';
} & StyledPropsBlade &
  TestID &
  DataAnalyticsAttribute;
```

## Examples

### ButtonGroup with Variants and State Management

This example demonstrates a ButtonGroup with different variants, loading state, and event handling.

```tsx
import React, { useState } from 'react';
import {
  ButtonGroup,
  Button,
  Box,
  Text,
  RefreshIcon,
  ShareIcon,
  DownloadIcon,
} from '@razorpay/blade/components';

const ButtonGroupExample = () => {
  const [isLoading, setIsLoading] = useState(false);

  const handleSync = () => {
    setIsLoading(true);
    setTimeout(() => {
      setIsLoading(false);
    }, 2000);
  };

  return (
    <Box padding="spacing.5">
      <Text marginBottom="spacing.4">Primary variant (default)</Text>
      <ButtonGroup
        variant="primary"
        size="medium"
        data-analytics="document-actions"
        testID="document-actions"
        marginBottom="spacing.6"
      >
        <Button icon={RefreshIcon} isLoading={isLoading} onClick={handleSync}>
          Sync
        </Button>
        <Button icon={ShareIcon} onClick={() => console.log('Share clicked')}>
          Share
        </Button>
        <Button icon={DownloadIcon} onClick={() => console.log('Download clicked')}>
          Download
        </Button>
      </ButtonGroup>

      <Text marginBottom="spacing.4">Secondary variant with small size</Text>
      <ButtonGroup variant="secondary" size="small">
        <Button icon={RefreshIcon}>Sync</Button>
        <Button icon={ShareIcon}>Share</Button>
        <Button icon={DownloadIcon}>Download</Button>
      </ButtonGroup>
    </Box>
  );
};

export default ButtonGroupExample;
```

### ButtonGroup with Dropdown Integration

This example demonstrates how to integrate ButtonGroup with Dropdown for split button patterns.

```tsx
import React, { useState } from 'react';
import {
  ButtonGroup,
  Button,
  Box,
  Text,
  Dropdown,
  DropdownButton,
  DropdownOverlay,
  ActionList,
  ActionListItem,
  PlusIcon,
  ChevronDownIcon,
} from '@razorpay/blade/components';

const ButtonGroupWithDropdownExample = () => {
  const [selectedAction, setSelectedAction] = useState('');

  const handleActionSelect = (value: string) => {
    setSelectedAction(value);
    console.log(`Selected action: ${value}`);
  };

  return (
    <Box padding="spacing.5">
      <Text marginBottom="spacing.4">Split button with dropdown:</Text>

      <ButtonGroup variant="primary" size="medium">
        <Button icon={PlusIcon} onClick={() => console.log('Create new payout')}>
          Payout
        </Button>
        <Dropdown>
          <DropdownButton icon={ChevronDownIcon} accessibilityLabel="More payout options" />
          <DropdownOverlay defaultPlacement="bottom-end">
            <ActionList>
              <ActionListItem
                title="Bulk Payout"
                value="bulk-payout"
                onClick={() => handleActionSelect('bulk-payout')}
              />
              <ActionListItem
                title="Upload Invoice"
                value="upload-invoice"
                onClick={() => handleActionSelect('upload-invoice')}
              />
              <ActionListItem
                title="Add Contact"
                value="add-contact"
                onClick={() => handleActionSelect('add-contact')}
              />
              <ActionListItem
                title="Team Member"
                value="team-member"
                onClick={() => handleActionSelect('team-member')}
              />
            </ActionList>
          </DropdownOverlay>
        </Dropdown>
      </ButtonGroup>

      {selectedAction && (
        <Box marginTop="spacing.4">
          <Text>Selected: {selectedAction}</Text>
        </Box>
      )}
    </Box>
  );
};

export default ButtonGroupWithDropdownExample;
```

---

## Card

## Component Name

Card

## Description

Cards are containers that group related content and actions on a single topic. They help separate content into distinct sections, making interfaces easier to scan and understand. Cards support various layouts with customizable headers, bodies, and footers, enabling consistent presentation of information while providing clear interaction points for users.

## Important Constraints

- `Card` component only accepts `CardHeader`, `CardBody`, `CardFooter` components as children
- `CardHeader` component only accepts `CardHeaderLeading`, `CardHeaderTrailing` components as children
- `CardFooter` component only accepts `CardFooterLeading`, `CardFooterTrailing` components as children

Make sure to only follow structure as given in the examples below. Fragments are also not allowed as children in these components.

## TypeScript Types

The following types define the props that the Card component and its subcomponents accept:

```typescript
export type CardProps = {
  /**
   * Card contents
   */
  children: React.ReactNode;
  /**
   * Sets the background color of the Card
   *
   * @default `surface.background.gray.intense`
   */
  backgroundColor?:
    | 'surface.background.gray.intense'
    | 'surface.background.gray.moderate'
    | 'surface.background.gray.subtle';
  /**
   * Sets the border radius of the Card
   *
   * @default `medium`
   */
  borderRadius?: Extract<BoxProps['borderRadius'], 'medium' | 'large' | 'xlarge'>;
  /**
   * Sets the elevation for Cards
   *
   * eg: `theme.elevation.midRaised`
   *
   * @default `theme.elevation.lowRaised`
   */
  elevation?: keyof Elevation;
  /**
   * Sets the padding equally on all sides. Only few `spacing` tokens are allowed deliberately
   * @default `spacing.7`
   */
  padding?: 'spacing.0' | 'spacing.3' | 'spacing.4' | 'spacing.5' | 'spacing.7';
  /**
   * Sets the width of the card
   */
  width?: BoxProps['width'];
  /**
   * Sets the height of the card
   */
  height?: BoxProps['height'];
  /**
   * Sets minimum height of the card
   */
  minHeight?: BoxProps['minHeight'];
  /**
   * Sets minimum width of the card
   */
  minWidth?: BoxProps['minWidth'];
  /**
   * Sets maximum width of the card
   */
  maxWidth?: BoxProps['maxWidth'];
  /**
   * If `true`, the card will be in selected state
   * Card will have a primary color border around it.
   *
   * @default false
   */
  isSelected?: boolean;
  /**
   * Makes the Card linkable by setting the `href` prop
   *
   * @default undefined
   */
  href?: string;
  /**
   * Sets the `target` attribute for the linkable card
   */
  target?: string;
  /**
   * Sets the `rel` attribute for the linkable card
   */
  rel?: string;
  /**
   * Sets the accessibility label for the card
   * This is useful when the card has an `href` or `onClick` prop
   * Setting this will announce the label when the card is focused
   */
  accessibilityLabel?: string;
  /**
   * If `true`, the card will scale up on hover
   *
   * On mobile devices it will scale down on press
   *
   * @default false
   */
  shouldScaleOnHover?: boolean;
  /**
   * Callback triggered when the card is hovered
   */
  onHover?: () => void;
  /**
   * Callback triggered when the card is clicked
   */
  onClick?: (
    event: Platform.Select<{
      web: React.MouseEvent;
      native: GestureResponderEvent;
    }>,
  ) => void;
  /**
   * Sets the HTML element for the Card
   *
   * When `as` is set to `label`, the card will be rendered as a label element
   * This can be used to create a custom checkbox or radio button using the card
   *
   * @default undefined
   */
  as?: 'label';
} & TestID &
  DataAnalyticsAttribute &
  StyledPropsBlade;

type CardBodyProps = {
  children: React.ReactNode;
  height?: BoxProps['height'];
} & TestID &
  DataAnalyticsAttribute;

type CardHeaderProps = {
  children?: React.ReactNode;
  /**
   * For spacing between divider and header title
   */
  paddingBottom?: CardSpacingValueType;
  /**
   * For spacing between body content and divider
   */
  marginBottom?: CardSpacingValueType;
  /**
   * @default true
   */
  showDivider?: boolean;
} & TestID &
  DataAnalyticsAttribute;

type CardHeaderLeadingProps = {
  title: string;
  subtitle?: string;
  /**
   * prefix element of Card
   *
   * Accepts: `CardHeaderIcon` component
   */
  prefix?: React.ReactNode;
  /**
   * suffix element of Card
   *
   * Accepts: `CardHeaderCounter` component
   */
  suffix?: React.ReactNode;
} & DataAnalyticsAttribute;

type CardHeaderTrailingProps = {
  /**
   * Renders a visual ornament in card header trailing section
   *
   * Accepts: `CardHeaderLink`, `CardHeaderText`, `CardHeaderIconButton`, `CardHeaderBadge`
   */
  visual?: React.ReactNode;
};

export type CardFooterAction = Pick<
  ButtonProps,
  'type' | 'accessibilityLabel' | 'isLoading' | 'isDisabled' | 'icon' | 'iconPosition' | 'onClick'
> & {
  text: ButtonProps['children'];
};

type CardFooterProps = {
  children?: React.ReactNode;
  /**
   * For spacing between divider and footer title
   */
  paddingTop?: CardSpacingValueType;
  /**
   * For spacing between body content and divider
   */
  marginTop?: CardSpacingValueType;
  /**
   * @default true
   */
  showDivider?: boolean;
} & TestID &
  DataAnalyticsAttribute;

type CardFooterLeadingProps = {
  title?: string;
  subtitle?: string;
} & DataAnalyticsAttribute;

type CardFooterTrailingProps = {
  actions?: {
    primary?: CardFooterAction;
    secondary?: CardFooterAction;
  };
} & DataAnalyticsAttribute;
```

## Example

### Basic Card with Header, Body, and Footer

A complete Card with header, body, and footer sections. Shows how to combine all Card components including icons, titles, badges, and actions.

```tsx
import {
  Card,
  CardBody,
  CardFooter,
  CardFooterLeading,
  CardFooterTrailing,
  CardHeader,
  CardHeaderLeading,
  CardHeaderTrailing,
  CardHeaderIcon,
  CardHeaderCounter,
  CardHeaderBadge,
  Text,
  InfoIcon,
} from '@razorpay/blade/components';

const BasicCardExample = () => {
  return (
    <Card>
      <CardHeader>
        <CardHeaderLeading
          title="Card Header"
          subtitle="Subtitle text that explains more"
          prefix={<CardHeaderIcon icon={InfoIcon} />}
          suffix={<CardHeaderCounter value={12} />}
        />
        <CardHeaderTrailing visual={<CardHeaderBadge color="positive">NEW</CardHeaderBadge>} />
      </CardHeader>
      <CardBody>
        <Text>
          Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum efficitur nisl nec
          dapibus volutpat. Sed vitae fringilla justo, in finibus metus. Nulla facilisi. Nunc ac
          luctus nisi, a ultrices purus.
        </Text>
      </CardBody>
      <CardFooter>
        <CardFooterLeading title="Card footer title" subtitle="Subtitle with more information" />
        <CardFooterTrailing
          actions={{
            primary: {
              onClick: () => console.log('Primary action clicked'),
              text: 'Accept',
            },
            secondary: {
              onClick: () => console.log('Secondary action clicked'),
              text: 'Cancel',
            },
          }}
        />
      </CardFooter>
    </Card>
  );
};
```

### Metric Card

A card displaying metrics with dynamic data visualization, hover effects, and responsive layout. Shows how to combine Card with data display components.

```tsx
import {
  Card,
  CardHeader,
  CardHeaderLeading,
  CardHeaderTrailing,
  CardHeaderLink,
  CardHeaderBadge,
  CardBody,
  Box,
  Text,
  Amount,
  ArrowSquareUpIcon,
  ArrowRightIcon,
  useTheme,
} from '@razorpay/blade/components';
import { useBreakpoint } from '@razorpay/blade/utils';

const MetricCard = () => {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  return (
    <Card
      backgroundColor="surface.background.gray.intense"
      maxWidth="500px"
      minWidth="300px"
      padding="spacing.5"
      size="medium"
    >
      <CardHeader showDivider={false}>
        <CardHeaderLeading
          title={isMobile ? 'TPV' : 'Total Payment Volume'}
          subtitle={
            isMobile ? 'TPV for the current month' : 'Total Payment Volume for the current month'
          }
        />
        <CardHeaderTrailing
          visual={
            isMobile ? (
              <CardHeaderLink href="/" icon={ArrowRightIcon} iconPosition="right">
                Chart settings
              </CardHeaderLink>
            ) : (
              <CardHeaderBadge color="positive">New</CardHeaderBadge>
            )
          }
        />
      </CardHeader>
      <CardBody>
        <Box display="flex" flexDirection={isMobile ? 'row' : 'column'} gap="spacing.5">
          <Box display="flex" flexDirection="column" justifyContent="flex-end">
            <Box display="flex" flexDirection="row" gap="spacing.3" alignItems="center">
              <Amount
                value={1000}
                color="surface.text.gray.normal"
                weight="semibold"
                size="2xlarge"
                type="heading"
              />
              <Box display="flex" flexDirection="row" gap="spacing.1" alignItems="center">
                <ArrowSquareUpIcon color="interactive.icon.positive.normal" />
                <Text color="interactive.text.positive.normal">12</Text>
              </Box>
            </Box>
          </Box>
          {/* Add your chart/graph component here */}
        </Box>
      </CardBody>
    </Card>
  );
};
```

### Interactive Cards

This example demonstrates how to create a group of cards that can be multi-selected using checkboxes, with validation and error states.

/\*
AI Implementation Notes:

1.  Simple interactive card:
    <Card
    shouldScaleOnHover
    isSelected={isSelected}
    onClick={() => setIsSelected(!isSelected)}
    accessibilityLabel="Card Name"

    >   <CardHeader>

        <CardHeaderLeading title="Title" subtitle="Subtitle" prefix={<CardHeaderIcon icon={Icon} />} />

      </CardHeader>
      <CardBody>
        <Text>Content</Text>
      </CardBody>
    </Card>

2.  Radio button version:
    - Use RadioGroup instead of CheckboxGroup
    - Single state: const [selected, setSelected] = useState('')
    - onChange: ({ value }) => setSelected(value)
    - isSelected check: selected === option.value
    - Remove max selection logic
      \*/

```tsx
import {
  Card,
  CardBody,
  CardHeaderLeading,
  CardHeaderIcon,
  Box,
  Text,
  Button,
  List,
  ListItem,
  ListItemText,
  Divider,
  CheckboxGroup,
  Checkbox,
  RazorpayIcon,
} from '@razorpay/blade/components';
import React from 'react';

type ProductOption = {
  value: string;
  title: string;
  subtitle: string;
  features: string[];
};

const productOptions: ProductOption[] = [
  {
    value: 'payment-gateway',
    title: 'Payment Gateway',
    subtitle: 'Accept online payments',
    features: [
      '100+ payment methods',
      'UPI, Cards, Netbanking, Wallets',
      'Industry-leading success rates',
      'Real-time payment tracking',
    ],
  },
  {
    value: 'payment-links',
    title: 'Payment Links',
    subtitle: 'Share & collect payments',
    features: [
      'No coding required',
      'Share via SMS, email, WhatsApp',
      'Instant payment collection',
      'Custom branding options',
    ],
  },
  {
    value: 'payment-pages',
    title: 'Payment Pages',
    subtitle: 'Create online store',
    features: [
      'Ready-to-use online store',
      'Product catalog management',
      'Inventory tracking',
      'Mobile-optimized checkout',
    ],
  },
];

const ProductCard = ({
  option,
  isSelected,
  children,
}: {
  option: ProductOption;
  isSelected: boolean;
  children: React.ReactNode;
}) => (
  <Card
    as="label"
    isSelected={isSelected}
    marginBottom="spacing.3"
    width={{ s: '100%', m: '400px' }}
    shouldScaleOnHover
    accessibilityLabel={`Select ${option.title}`}
  >
    <CardBody>
      <Box display="flex" flexDirection="row" gap="spacing.3" alignItems="flex-start">
        <CardHeaderLeading
          title={option.title}
          subtitle={option.subtitle}
          prefix={<CardHeaderIcon icon={RazorpayIcon} />}
        />
        {children}
      </Box>
      <Divider marginY="spacing.3" />
      <List variant="unordered">
        {option.features.map((feature, index) => (
          <ListItem key={index}>
            <ListItemText>{feature}</ListItemText>
          </ListItem>
        ))}
      </List>
    </CardBody>
  </Card>
);

const ProductSelection = () => {
  const [selectedProducts, setSelectedProducts] = React.useState<string[]>([]);
  const [isSubmitted, setIsSubmitted] = React.useState(false);

  const hasError = isSubmitted && selectedProducts.length === 0;
  const hasMaxError = selectedProducts.length > 3;
  const validationState = hasError || hasMaxError ? 'error' : 'none';
  const errorText = hasError
    ? 'Please select at least one product'
    : hasMaxError
    ? 'Maximum 3 products allowed'
    : undefined;

  return (
    <Box display="flex" gap="spacing.6" flexDirection="column">
      <Box>
        <Text marginBottom="spacing.4" weight="semibold" size="large">
          Multi-Select Products
        </Text>
        <CheckboxGroup
          value={selectedProducts}
          onChange={({ values }) => setSelectedProducts(values)}
          label="Which products do you want to use?"
          necessityIndicator="required"
          validationState={validationState}
          errorText={errorText}
          helpText="Select 1-3 products to start with"
          orientation="horizontal"
          flexWrap="wrap"
        >
          {productOptions.map((option) => (
            <ProductCard
              key={option.value}
              option={option}
              isSelected={selectedProducts.includes(option.value)}
            >
              <Checkbox value={option.value} />
            </ProductCard>
          ))}
        </CheckboxGroup>

        <Box
          marginTop="spacing.4"
          display="flex"
          justifyContent="space-between"
          alignItems="center"
        >
          <Button onClick={() => setIsSubmitted(true)} variant="primary">
            Continue
          </Button>
          {selectedProducts.length > 0 && (
            <Text color="surface.text.gray.subtle">Selected: {selectedProducts.length}/3</Text>
          )}
        </Box>
      </Box>
    </Box>
  );
};

export default ProductSelection;
```

---

## Carousel

## Component Name

Carousel

## Description

The Carousel is a component that displays a collection of items in a horizontally scrollable container. It enables users to navigate through content items like images, cards, or promotional content with pagination indicators and navigation buttons. The Carousel supports various configurations including multiple visible items, autoplay, and different navigation styles.

## Important Constraints

- `Carousel` component only accepts `CarouselItem` components as children

## TypeScript Types

The following types represent the props that the Carousel component and its subcomponents accept. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the Carousel component
 */
type CarouselProps = {
  /**
   * The content to be displayed inside the carousel
   */
  children: React.ReactNode;

  /**
   * Accessibility label for the carousel
   */
  accessibilityLabel?: string;

  /**
   * Whether to automatically play the carousel
   * @default false
   */
  autoPlay?: boolean;

  /**
   * Alignment of carousel items
   * @default 'start'
   */
  carouselItemAlignment?:
    | 'normal'
    | 'stretch'
    | 'center'
    | 'end'
    | 'flex-end'
    | 'flex-start'
    | 'self-end'
    | 'self-start'
    | 'start';

  /**
   * Width of carousel items
   */
  carouselItemWidth?: string | ResponsiveValue<string>;

  /**
   * Position of navigation buttons
   * @default 'bottom'
   */
  navigationButtonPosition?: 'bottom' | 'side';

  /**
   * Variant of indicators
   * @default 'gray'
   */
  indicatorVariant?: 'gray' | 'white';

  /**
   * Variant of navigation buttons
   * @default 'filled'
   */
  navigationButtonVariant?: 'filled' | 'outlined';

  /**
   * Number of visible items
   * @default 1
   */
  visibleItems?: number | 'autofit';

  /**
   * Whether to add spacing at the start and end
   * @default false
   */
  shouldAddStartEndSpacing?: boolean;

  /**
   * Whether to show indicators
   * @default true
   */
  showIndicators?: boolean;

  /**
   * Color of scroll overlay
   */
  scrollOverlayColor?: string;

  /**
   * Currently active slide (controlled mode)
   */
  activeSlide?: number;

  /**
   * Default active slide (uncontrolled mode)
   */
  defaultActiveSlide?: number;

  /**
   * Callback when slide changes
   */
  onChange?: (index: number) => void;

  /**
   * Controls how carousel items are aligned within the container
   * @default 'start'
   */
  snapAlign?: 'start' | 'center' | 'end';

  /**
   * Sets the gap between carousel items
   * @default { base: 'spacing.4', m: 'spacing.5' }
   */
  gap?: BoxProps['gap'];
} & StyledPropsBlade &
  TestID;

/**
 * Props for the CarouselItem component
 */
type CarouselItemProps = {
  /**
   * The content to be displayed inside the carousel item
   */
  children: React.ReactNode;
} & StyledPropsBlade;

/**
 * Type for responsive values
 */
type ResponsiveValue<T> = {
  base?: T;
  s?: T;
  m?: T;
  l?: T;
  xl?: T;
};
```

## Examples

### Basic Responsive Carousel

This example demonstrates a simple carousel with responsive item widths and bottom navigation.

```tsx
import React from 'react';
import {
  Carousel,
  CarouselItem,
  Card,
  CardBody,
  CardHeader,
  CardHeaderLeading,
  Box,
  Text,
} from '@razorpay/blade/components';

const BasicCarouselExample = () => {
  const testimonials = [
    {
      id: '1',
      title: 'Increased Conversion Rate',
      quote: 'We saw a 35% increase in conversion after integrating Razorpay Checkout.',
      author: 'Priya Sharma',
      company: 'TechStart',
    },
    {
      id: '2',
      title: 'Seamless Integration',
      quote: 'The API was easy to integrate and the dashboard provides great insights.',
      author: 'Rahul Gupta',
      company: 'Shopify Plus',
    },
    {
      id: '3',
      title: 'Excellent Customer Support',
      quote: 'Whenever we faced any issues, the support team was quick to respond.',
      author: 'Anita Desai',
      company: 'StyleBazaar',
    },
    {
      id: '4',
      title: 'Simplified Refunds',
      quote: 'Processing refunds has become a breeze with the dashboard.',
      author: 'Vikram Singh',
      company: 'TravelEasy',
    },
  ];

  return (
    <Box padding="spacing.5">
      <Carousel
        accessibilityLabel="Customer testimonials"
        carouselItemWidth={{ base: '90%', m: '45%', l: '30%' }}
        visibleItems="autofit"
        navigationButtonPosition="bottom"
        indicatorVariant="gray"
        showIndicators={true}
      >
        {testimonials.map((testimonial) => (
          <CarouselItem key={testimonial.id}>
            <Card height="100%" padding="spacing.4" elevation="lowRaised">
              <CardHeader>
                <CardHeaderLeading
                  title={testimonial.title}
                  subtitle={`${testimonial.author}, ${testimonial.company}`}
                />
              </CardHeader>
              <CardBody>
                <Text>{testimonial.quote}</Text>
              </CardBody>
            </Card>
          </CarouselItem>
        ))}
      </Carousel>
    </Box>
  );
};

export default BasicCarouselExample;
```

### Carousel with AutoPlay and Side Navigation

This example shows a carousel with autoplay functionality, side navigation buttons, and custom styling.

```tsx
import React from 'react';
import {
  Carousel,
  CarouselItem,
  Card,
  CardBody,
  Box,
  Text,
  Heading,
} from '@razorpay/blade/components';

const AutoPlayCarouselExample = () => {
  const testimonials = [
    {
      id: '1',
      title: 'Increased Conversion Rate',
      quote: 'We saw a 35% increase in conversion after integrating Razorpay Checkout.',
      author: 'Priya Sharma',
      role: 'Product Manager',
      company: 'TechStart',
    },
    {
      id: '2',
      title: 'Seamless Integration',
      quote: 'The API was easy to integrate and the dashboard provides great insights.',
      author: 'Rahul Gupta',
      role: 'CTO',
      company: 'Shopify Plus',
    },
    {
      id: '3',
      title: 'Excellent Customer Support',
      quote: 'Whenever we faced any issues, the support team was quick to respond.',
      author: 'Anita Desai',
      role: 'Engineering Lead',
      company: 'StyleBazaar',
    },
  ];

  return (
    <Box
      backgroundColor="surface.background.gray.moderate"
      padding="spacing.5"
      borderRadius="medium"
    >
      <Carousel
        accessibilityLabel="Featured testimonials"
        autoPlay={true}
        carouselItemWidth={{ base: '100%', m: '80%' }}
        visibleItems={1}
        navigationButtonPosition="side"
        navigationButtonVariant="filled"
        shouldAddStartEndSpacing={true}
        scrollOverlayColor="surface.background.gray.intense"
        indicatorVariant="gray"
        showIndicators={true}
        data-analytics="featured-testimonials"
      >
        {testimonials.map((testimonial) => (
          <CarouselItem key={testimonial.id}>
            <Card
              height="100%"
              padding="spacing.5"
              elevation="lowRaised"
              backgroundColor="surface.background.gray.subtle"
            >
              <CardBody>
                <Heading size="medium" marginBottom="spacing.3">
                  {testimonial.title}
                </Heading>
                <Text marginBottom="spacing.4" size="large">
                  "{testimonial.quote}"
                </Text>
                <Text weight="semibold">{testimonial.author}</Text>
                <Text size="small">
                  {testimonial.role}, {testimonial.company}
                </Text>
              </CardBody>
            </Card>
          </CarouselItem>
        ))}
      </Carousel>
    </Box>
  );
};

export default AutoPlayCarouselExample;
```

### Controlled Carousel with Custom Navigation

This example demonstrates a controlled carousel with custom external navigation buttons.

```tsx
import React, { useState } from 'react';
import {
  Carousel,
  CarouselItem,
  Card,
  CardBody,
  CardFooter,
  Box,
  Text,
  Heading,
  Button,
  ChevronLeftIcon,
  ChevronRightIcon,
} from '@razorpay/blade/components';

const ControlledCarouselExample = () => {
  const [activeSlide, setActiveSlide] = useState(0);

  const testimonials = [
    {
      id: '1',
      title: 'Increased Conversion Rate',
      quote: 'We saw a 35% increase in conversion after integrating Razorpay Checkout.',
      author: 'Priya Sharma',
      role: 'Product Manager',
      company: 'TechStart',
    },
    {
      id: '2',
      title: 'Seamless Integration',
      quote: 'The API was easy to integrate and the dashboard provides great insights.',
      author: 'Rahul Gupta',
      role: 'CTO',
      company: 'Shopify Plus',
    },
    {
      id: '3',
      title: 'Excellent Customer Support',
      quote: 'Whenever we faced any issues, the support team was quick to respond.',
      author: 'Anita Desai',
      role: 'Engineering Lead',
      company: 'StyleBazaar',
    },
  ];

  return (
    <Box
      backgroundColor="surface.background.gray.moderate"
      padding="spacing.5"
      borderRadius="medium"
    >
      <Box
        display="flex"
        justifyContent="space-between"
        alignItems="center"
        marginBottom="spacing.4"
      >
        <Heading size="medium">Customer Stories</Heading>
        <Box display="flex" gap="spacing.3">
          <Button
            variant="secondary"
            icon={ChevronLeftIcon}
            onClick={() => setActiveSlide((prev) => Math.max(0, prev - 1))}
            isDisabled={activeSlide === 0}
          >
            Previous
          </Button>
          <Button
            variant="secondary"
            icon={ChevronRightIcon}
            iconPosition="right"
            onClick={() => setActiveSlide((prev) => Math.min(testimonials.length - 1, prev + 1))}
            isDisabled={activeSlide === testimonials.length - 1}
          >
            Next
          </Button>
        </Box>
      </Box>

      <Carousel
        accessibilityLabel="Controlled testimonial carousel"
        activeSlide={activeSlide}
        onChange={setActiveSlide}
        visibleItems={1}
        showIndicators={true}
        navigationButtonPosition="bottom"
        carouselItemWidth="100%"
      >
        {testimonials.map((testimonial, index) => (
          <CarouselItem key={testimonial.id}>
            <Card height="100%" padding="spacing.5" elevation="lowRaised">
              <CardBody>
                <Heading size="medium" marginBottom="spacing.3">
                  {testimonial.title}
                </Heading>
                <Text marginBottom="spacing.4" size="large">
                  "{testimonial.quote}"
                </Text>
                <Text weight="semibold">{testimonial.author}</Text>
                <Text size="small">
                  {testimonial.role}, {testimonial.company}
                </Text>
              </CardBody>
              <CardFooter marginTop="spacing.4">
                <Text size="small" color="surface.text.gray.muted">
                  Testimonial {index + 1} of {testimonials.length}
                </Text>
              </CardFooter>
            </Card>
          </CarouselItem>
        ))}
      </Carousel>
    </Box>
  );
};

export default ControlledCarouselExample;
```

### Multi-Item Selectable Carousel

This example shows a carousel with multiple visible items and selectable items.

```tsx
import React, { useState } from 'react';
import {
  Carousel,
  CarouselItem,
  Box,
  Text,
  Heading,
  Card,
  CardBody,
  CreditCardIcon,
  UpiIcon,
  WalletIcon,
  BankIcon,
  CalendarIcon,
  ClockIcon,
} from '@razorpay/blade/components';

const MultiItemSelectableCarouselExample = () => {
  const [selectedPayment, setSelectedPayment] = useState<string | null>(null);

  const paymentMethods = [
    { id: 'card', name: 'Credit/Debit Card', icon: CreditCardIcon },
    { id: 'upi', name: 'UPI', icon: UpiIcon },
    { id: 'wallet', name: 'Wallet', icon: WalletIcon },
    { id: 'netbanking', name: 'Netbanking', icon: BankIcon },
    { id: 'emi', name: 'EMI', icon: CalendarIcon },
    { id: 'paylater', name: 'Pay Later', icon: ClockIcon },
  ];

  const handleSelect = (id: string) => {
    setSelectedPayment(id === selectedPayment ? null : id);
  };

  return (
    <Box padding="spacing.5">
      <Heading size="medium" marginBottom="spacing.5">
        Payment Methods
      </Heading>

      <Carousel
        accessibilityLabel="Payment methods carousel"
        visibleItems={3}
        navigationButtonPosition="side"
        navigationButtonVariant="stroked"
        indicatorVariant="gray"
        carouselItemWidth={{ base: '80%', s: '45%', m: '30%', l: '22%' }}
        shouldAddStartEndSpacing={false}
        data-analytics="payment-methods-carousel"
      >
        {paymentMethods.map((method) => {
          const isSelected = selectedPayment === method.id;
          const Icon = method.icon;

          return (
            <CarouselItem key={method.id}>
              <Card
                height="100%"
                padding="spacing.4"
                elevation={isSelected ? 'midRaised' : 'lowRaised'}
                backgroundColor={
                  isSelected ? 'surface.background.gray.intense' : 'surface.background.gray.subtle'
                }
                isSelected={isSelected}
                onClick={() => handleSelect(method.id)}
              >
                <CardBody>
                  <Box
                    display="flex"
                    flexDirection="column"
                    alignItems="center"
                    justifyContent="center"
                    padding="spacing.3"
                    gap="spacing.3"
                  >
                    <Icon
                      size="large"
                      color={isSelected ? 'interactive.icon.primary.normal' : undefined}
                    />
                    <Text
                      weight={isSelected ? 'semibold' : 'regular'}
                      color={isSelected ? 'interactive.text.primary.normal' : undefined}
                    >
                      {method.name}
                    </Text>
                  </Box>
                </CardBody>
              </Card>
            </CarouselItem>
          );
        })}
      </Carousel>

      {selectedPayment && (
        <Box
          padding="spacing.4"
          backgroundColor="surface.background.gray.subtle"
          borderRadius="medium"
          marginTop="spacing.4"
        >
          <Text>
            Selected payment method: {paymentMethods.find((m) => m.id === selectedPayment)?.name}
          </Text>
        </Box>
      )}
    </Box>
  );
};

export default MultiItemSelectableCarouselExample;
```

### Auto-Playing Product Carousel

This example demonstrates an auto-playing carousel with custom styling and responsive sizing.

```tsx
import React from 'react';
import { Carousel, CarouselItem, Box, Text, Card, CardBody } from '@razorpay/blade/components';

const AutoPlayProductCarouselExample = () => {
  const products = [
    { id: 1, name: 'Premium Plan', description: 'Our most popular plan' },
    { id: 2, name: 'Enterprise Solution', description: 'For large organizations' },
    { id: 3, name: 'Starter Package', description: 'Perfect for small businesses' },
    { id: 4, name: 'Custom Solution', description: 'Tailored to your needs' },
    { id: 5, name: 'Mobile Package', description: 'Optimize for mobile payments' },
  ];

  return (
    <Box padding="spacing.5">
      <Carousel
        accessibilityLabel="Featured products"
        autoPlay={true}
        carouselItemWidth={{ base: '85%', m: '40%', l: '30%' }}
        visibleItems="autofit"
        shouldAddStartEndSpacing={true}
        navigationButtonPosition="bottom"
        showIndicators={true}
      >
        {products.map((product, index) => (
          <CarouselItem key={product.id}>
            <Card
              height="180px"
              backgroundColor={
                index % 2 === 0
                  ? 'surface.background.gray.intense'
                  : 'surface.background.gray.moderate'
              }
            >
              <CardBody>
                <Box
                  display="flex"
                  flexDirection="column"
                  justifyContent="center"
                  alignItems="center"
                  height="100%"
                >
                  <Text weight="semibold" size="large">
                    {product.name}
                  </Text>
                  <Text marginTop="spacing.2">{product.description}</Text>
                </Box>
              </CardBody>
            </Card>
          </CarouselItem>
        ))}
      </Carousel>
    </Box>
  );
};

export default AutoPlayProductCarouselExample;
```

### Carousel with Peek Behavior

This example demonstrates a carousel with peek behavior where the active card is centered with adjacent cards visible on the sides.

You can achieve peek behavior by setting `visibleItems` to 1, adding `carouselItemWidth` to be less than 100% (eg: 80%), setting `snapAlign` to "center", and adding `gap` for spacing between items.

```tsx
import React from 'react';
import {
  Carousel,
  CarouselItem,
  Card,
  CardBody,
  CardHeader,
  CardHeaderLeading,
  Box,
  Text,
  Heading,
} from '@razorpay/blade/components';

const CarouselWithPeekExample = () => {
  const features = [
    {
      id: '1',
      title: 'Instant Settlements',
      description: 'Get your money in seconds with our instant settlement feature.',
      benefit: 'Improved cash flow',
    },
    {
      id: '2',
      title: 'Smart Routing',
      description: 'AI-powered payment routing for maximum success rates.',
      benefit: 'Higher conversion',
    },
    {
      id: '3',
      title: 'Fraud Detection',
      description: 'Advanced ML models to prevent fraudulent transactions.',
      benefit: 'Enhanced security',
    },
    {
      id: '4',
      title: 'Analytics Dashboard',
      description: 'Real-time insights and detailed payment analytics.',
      benefit: 'Data-driven decisions',
    },
  ];

  return (
    <Box padding="spacing.5">
      <Carousel
        accessibilityLabel="Payment features with peek"
        visibleItems={1}
        carouselItemWidth={{ base: '80%', m: '80%' }}
        snapAlign="center"
        gap="spacing.7"
        navigationButtonPosition="bottom"
        showIndicators={true}
      >
        {features.map((feature) => (
          <CarouselItem key={feature.id}>
            <Card height="100%" elevation="midRaised">
              <CardHeader>
                <CardHeaderLeading title={feature.title} subtitle={feature.benefit} />
              </CardHeader>
              <CardBody>
                <Text>{feature.description}</Text>
              </CardBody>
            </Card>
          </CarouselItem>
        ))}
      </Carousel>
    </Box>
  );
};

export default CarouselWithPeekExample;
```

---

## ChatMessage

## Component Name

ChatMessage

## Description

ChatMessage is a visual representation of a message in a chat interface. It provides a consistent way to display messages from different senders, supporting various states such as loading and error, and can include icons, custom content, and interactive elements. This component is designed to handle different message types and can be customized with various styling options.

## TypeScript Types

The following types represent the props that the ChatMessage component accepts. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the ChatMessage component
 */
type ChatMessageProps = {
  /**
   * The content of the chat message
   */
  children?: React.ReactNode;

  /**
   * Indicates the type of sender for the message
   * 'self': Messages from the current user
   * 'other': Messages from other users or agents
   */
  senderType: 'self' | 'other';

  /**
   * Type of message which affects styling and layout
   * 'default': Standard message in a sequence
   * 'last': Last message in a sequence (has different styling)
   * @default 'default'
   */
  messageType?: 'default' | 'last';

  /**
   * Element to display before the message (like an avatar or icon)
   * Typically used with senderType="other"
   */
  leading?: React.ReactNode;

  /**
   * Whether the message is in a loading state
   * @default false
   */
  isLoading?: boolean;

  /**
   * Text to display when the message is in loading state
   */
  loadingText?: string;

  /**
   * Validation state of the message
   */
  validationState?: 'error';

  /**
   * Text to display when the message is in an error state
   */
  errorText?: string;

  /**
   * Function called when the message is clicked
   */
  onClick?: () => void;

  /**
   * Content to render in the footer of the message
   */
  footerActions?: React.ReactNode;

  /**
   * How to handle word breaking in the message
   * @default 'normal'
   */
  wordBreak?: 'normal' | 'break-all' | 'break-word' | 'keep-all';
} & StyledPropsBlade &
  TestID &
  DataAnalyticsAttribute;
```

## Examples

### Comprehensive Chat Interface

This example demonstrates a complete chat interface with various ChatMessage types, states, interactions, and accessibility considerations.

```tsx
import React, { useState } from 'react';
import {
  ChatMessage,
  Box,
  Text,
  Card,
  CardBody,
  RadioGroup,
  Radio,
  ChipGroup,
  Chip,
  Button,
  RayIcon,
  ThumbsUpIcon,
  ThumbsDownIcon,
  SendIcon,
} from '@razorpay/blade/components';

const ComprehensiveChatExample = () => {
  const [messages, setMessages] = useState([
    {
      id: '1',
      text: 'Hello! How can I assist you with Razorpay today?',
      senderType: 'other',
      timestamp: '10:30 AM',
    },
    {
      id: '2',
      text: 'I need help setting up payment gateway',
      senderType: 'self',
      timestamp: '10:31 AM',
    },
    {
      id: '3',
      text: 'Sure, I can help with that. What platform are you integrating with?',
      senderType: 'other',
      timestamp: '10:32 AM',
    },
  ]);

  const [isLoading, setIsLoading] = useState(false);
  const [selectedOption, setSelectedOption] = useState('');
  const [failedMessage, setFailedMessage] = useState({
    id: '4',
    text: 'I am using React for a web application',
    senderType: 'self',
    failed: true,
    timestamp: '10:33 AM',
  });

  const handleRetry = () => {
    setFailedMessage((prev) => ({ ...prev, failed: false }));
    // Simulate sending message again
    setTimeout(() => {
      setMessages((prevMessages) => [
        ...prevMessages,
        {
          id: '4',
          text: 'I am using React for a web application',
          senderType: 'self',
          timestamp: '10:34 AM',
        },
      ]);

      // Simulate response after sending
      setIsLoading(true);
      setTimeout(() => {
        setIsLoading(false);
        setMessages((prevMessages) => [
          ...prevMessages,
          {
            id: '5',
            text:
              'Great! For React applications, you can use our React SDK. Would you like me to show you how to set it up?',
            senderType: 'other',
            timestamp: '10:35 AM',
          },
        ]);
      }, 2000);
    }, 500);
  };

  const handleFeedback = (value) => {
    console.log(`Feedback: ${value}`);
  };

  return (
    <Box
      maxWidth="600px"
      margin="auto"
      padding="spacing.5"
      aria-label="Chat conversation about payment gateway integration"
    >
      <Text
        size="small"
        color="surface.text.gray.muted"
        textAlign="center"
        marginBottom="spacing.4"
        aria-hidden="true"
      >
        Today
      </Text>

      <Box
        backgroundColor="surface.background.gray.subtle"
        padding="spacing.5"
        borderRadius="medium"
        display="flex"
        flexDirection="column"
        gap="spacing.4"
      >
        {/* Messages */}
        <Box display="flex" flexDirection="column" gap="spacing.3">
          {/* Regular messages */}
          {messages.map((message, index) => {
            const isLastFromSender =
              index === messages.length - 1 ||
              messages[index + 1]?.senderType !== message.senderType;

            const showLeadingIcon =
              message.senderType === 'other' &&
              (index === 0 || messages[index - 1]?.senderType !== 'other');

            return (
              <ChatMessage
                key={message.id}
                senderType={message.senderType === 'self' ? 'self' : 'other'}
                messageType={isLastFromSender ? 'last' : 'default'}
                leading={
                  showLeadingIcon ? (
                    <RayIcon size="xlarge" color="surface.icon.onSea.onSubtle" />
                  ) : undefined
                }
                wordBreak="break-word"
                marginLeft={message.senderType === 'other' && !showLeadingIcon ? '24px' : undefined}
                footerActions={
                  message.senderType === 'other' && index === messages.length - 1 ? (
                    <Box display="flex" justifyContent="flex-start" marginTop="spacing.2">
                      <ChipGroup label="">
                        <Chip value="helpful" icon={ThumbsUpIcon} />
                        <Chip value="not-helpful" icon={ThumbsDownIcon} />
                      </ChipGroup>
                    </Box>
                  ) : undefined
                }
                data-analytics={`chat-message-${message.id}`}
                aria-label={`${message.senderType === 'self' ? 'You' : 'Support agent'}: ${
                  message.text
                }`}
              >
                {message.text}
                <Text
                  size="xsmall"
                  color="surface.text.gray.muted"
                  display="block"
                  marginTop="spacing.2"
                  aria-hidden="true"
                >
                  {message.timestamp}
                </Text>
              </ChatMessage>
            );
          })}

          {/* Failed message */}
          {failedMessage.failed && (
            <ChatMessage
              senderType="self"
              messageType="last"
              validationState="error"
              errorText="Message not sent. Tap to retry."
              onClick={handleRetry}
              testID="failed-message"
              aria-label={`Failed message: ${failedMessage.text}. Tap to retry sending.`}
            >
              {failedMessage.text}
              <Text
                size="xsmall"
                color="surface.text.gray.muted"
                display="block"
                marginTop="spacing.2"
                aria-hidden="true"
              >
                {failedMessage.timestamp}
              </Text>
            </ChatMessage>
          )}

          {/* Loading state */}
          {isLoading && (
            <ChatMessage
              isLoading
              senderType="other"
              loadingText="Typing a response..."
              leading={<RayIcon size="xlarge" color="surface.icon.onSea.onSubtle" />}
              aria-label="Support agent is typing a response"
            />
          )}
        </Box>

        {/* Interactive question with radio options */}
        <ChatMessage
          senderType="other"
          leading={<RayIcon size="xlarge" color="surface.icon.onSea.onSubtle" />}
          messageType="last"
          aria-label="Support agent: What kind of business do you run?"
        >
          <Card>
            <CardBody>
              <Box display="flex" flexDirection="column" gap="spacing.3">
                <Text variant="body" size="medium">
                  What kind of business do you run?
                </Text>
                <RadioGroup
                  value={selectedOption}
                  onChange={({ value }) => setSelectedOption(value)}
                  aria-label="Business type options"
                >
                  <Radio value="ecommerce">E-commerce</Radio>
                  <Radio value="saas">SaaS</Radio>
                  <Radio value="marketplace">Marketplace</Radio>
                  <Radio value="other">Other</Radio>
                </RadioGroup>
                {selectedOption && (
                  <Button
                    variant="primary"
                    size="small"
                    icon={SendIcon}
                    iconPosition="right"
                    marginTop="spacing.2"
                    onClick={() => console.log(`Selected: ${selectedOption}`)}
                    aria-label={`Submit selected option: ${selectedOption}`}
                  >
                    Submit
                  </Button>
                )}
              </Box>
            </CardBody>
          </Card>
        </ChatMessage>
      </Box>
    </Box>
  );
};

export default ComprehensiveChatExample;
```

---

## Checkbox

## Component Name

Checkbox

## Description

Checkbox is a form control that allows users to select one or multiple options from a set of choices. It can be used individually or grouped together using CheckboxGroup for managing related options. Checkboxes support various states including checked, unchecked, indeterminate, disabled, and can display help text or error messages to guide users.

## Important Constraints

- When `Checkbox` is inside `CheckboxGroup`, it cannot have individual `validationState`, `name`, `defaultChecked`, `isChecked`, or `onChange` props - these must be set on the `CheckboxGroup` itself
- When `Checkbox` is inside `CheckboxGroup`, each `Checkbox` must have a unique `value` prop

## TypeScript Types

The following types represent the props that the Checkbox component and its subcomponents accept. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the Checkbox component
 */
type CheckboxProps = {
  /**
   * The label for the checkbox
   */
  children?: React.ReactNode;

  /**
   * The default state of the checkbox (uncontrolled)
   * @default false
   */
  defaultChecked?: boolean;

  /**
   * Error message to display when validation state is error
   */
  errorText?: string;

  /**
   * Help text to display below the checkbox
   */
  helpText?: string;

  /**
   * Whether the checkbox is checked (controlled)
   */
  isChecked?: boolean;

  /**
   * Whether the checkbox is disabled
   * @default false
   */
  isDisabled?: boolean;

  /**
   * Whether the checkbox is in an indeterminate state
   * @default false
   */
  isIndeterminate?: boolean;

  /**
   * Whether the checkbox is required
   * @default false
   */
  isRequired?: boolean;

  /**
   * Name of the checkbox for form submission
   */
  name?: string;

  /**
   * Callback fired when the checkbox state changes
   */
  onChange?: (event: { isChecked: boolean; value?: string; event?: React.ChangeEvent }) => void;

  /**
   * Size of the checkbox
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * The validation state of the checkbox
   */
  validationState?: 'error' | 'none';

  /**
   * Value of the checkbox for form submission
   */
  value?: string;
} & StyledPropsBlade &
  TestID;

/**
 * Props for the CheckboxGroup component
 */
type CheckboxGroupProps = {
  /**
   * The checkboxes to be grouped
   */
  children: React.ReactNode;

  /**
   * The default selected values (uncontrolled)
   */
  defaultValue?: string[];

  /**
   * Error message to display when validation state is error
   */
  errorText?: string;

  /**
   * Help text to display below the checkbox group
   */
  helpText?: string;

  /**
   * Whether the checkbox group is disabled
   * @default false
   */
  isDisabled?: boolean;

  /**
   * Whether the checkbox group is required
   * @default false
   */
  isRequired?: boolean;

  /**
   * The label for the checkbox group
   */
  label: string;

  /**
   * Position of the label relative to the checkbox group
   */
  labelPosition?: 'top' | 'left';

  /**
   * Name of the checkbox group for form submission
   */
  name?: string;

  /**
   * Indicator for whether the checkbox group is required or optional
   * @default 'none'
   */
  necessityIndicator?: 'none' | 'required' | 'optional';

  /**
   * Callback fired when any checkbox in the group changes
   */
  onChange?: (event: { values: string[]; name?: string }) => void;

  /**
   * Size of the checkboxes in the group
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * The validation state of the checkbox group
   */
  validationState?: 'error' | 'none';

  /**
   * The selected values (controlled)
   */
  value?: string[];
} & StyledPropsBlade &
  TestID;
```

## Examples

### Payment Setup Form with Checkboxes

This comprehensive example demonstrates a payment setup form with both single checkboxes and checkbox groups. It covers various use cases including:

- Controlled and uncontrolled checkboxes
- Required validation with error states
- Indeterminate state with "select all" functionality
- Different checkbox sizes
- Help text and error messaging
- Label positioning options for CheckboxGroup

```tsx
import React, { useState, useRef } from 'react';
import { Checkbox, CheckboxGroup, Box, Text, Button, Heading } from '@razorpay/blade/components';

const PaymentSetupForm = () => {
  // State for form submission
  const [formSubmitted, setFormSubmitted] = useState(false);

  // State for terms agreement (single controlled checkbox)
  const [termsAgreed, setTermsAgreed] = useState(false);

  // State for notification preferences (single checkboxes)
  const [emailNotifications, setEmailNotifications] = useState(true);
  const [smsNotifications, setSmsNotifications] = useState(false);

  // Ref for focusing checkbox
  const termsCheckboxRef = useRef(null);

  // State for payment methods (checkbox group with select all functionality)
  const paymentMethods = ['credit_card', 'debit_card', 'netbanking', 'upi', 'wallet'];
  const [selectedPaymentMethods, setSelectedPaymentMethods] = useState(['credit_card', 'upi']);

  // Calculate select all states
  const allMethodsSelected = selectedPaymentMethods.length === paymentMethods.length;
  const someMethodsSelected = selectedPaymentMethods.length > 0 && !allMethodsSelected;
  const noMethodsSelected = selectedPaymentMethods.length === 0;

  // Handlers for payment methods
  const handleSelectAllMethods = (event) => {
    if (event.isChecked) {
      setSelectedPaymentMethods([...paymentMethods]);
    } else {
      setSelectedPaymentMethods([]);
    }
  };

  const handlePaymentMethodsChange = (event) => {
    setSelectedPaymentMethods(event.values);
  };

  // Handler for form submission
  const handleSubmit = (e) => {
    e.preventDefault();
    setFormSubmitted(true);

    // Focus terms checkbox if not agreed
    if (!termsAgreed) {
      termsCheckboxRef.current?.focus();
      return;
    }

    // If validation passes, submit form data
    if (termsAgreed && !noMethodsSelected) {
      console.log('Form submitted successfully!', {
        termsAgreed,
        emailNotifications,
        smsNotifications,
        selectedPaymentMethods,
      });

      alert('Payment setup completed successfully!');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <Heading size="large">Payment Gateway Setup</Heading>

      {/* Section 1: Basic Business Preferences (Uncontrolled Checkboxes) */}
      <Box display="flex" flexDirection="column" gap="spacing.4">
        <Text size="medium" weight="semibold">
          Business Preferences
        </Text>

        <Checkbox
          defaultChecked
          name="international_payments"
          value="enabled"
          onChange={(e) => console.log('International payments:', e.isChecked)}
          helpText="Enable payments from international customers"
        >
          Accept International Payments
        </Checkbox>

        <Checkbox
          defaultChecked={false}
          name="test_mode"
          value="enabled"
          onChange={(e) => console.log('Test mode:', e.isChecked)}
          helpText="Process transactions in test mode with no real money movement"
        >
          Enable Test Mode
        </Checkbox>
      </Box>

      {/* Section 2: Payment Methods (Checkbox Group with Select All) */}
      <Box display="flex" flexDirection="column" gap="spacing.4">
        <Text size="medium" weight="semibold">
          Payment Methods
        </Text>

        <Checkbox
          isChecked={allMethodsSelected}
          isIndeterminate={someMethodsSelected}
          onChange={handleSelectAllMethods}
          validationState={formSubmitted && noMethodsSelected ? 'error' : 'none'}
          size="medium"
        >
          Select All Payment Methods
        </Checkbox>

        <CheckboxGroup
          name="payment_methods"
          helpText="Choose which payment methods to offer your customers"
          errorText="At least one payment method must be selected"
          validationState={formSubmitted && noMethodsSelected ? 'error' : 'none'}
          value={selectedPaymentMethods}
          onChange={handlePaymentMethodsChange}
          size="small"
        >
          <Checkbox value="credit_card" helpText="Visa, Mastercard, American Express, etc.">
            Credit Cards
          </Checkbox>
          <Checkbox value="debit_card" helpText="Visa Debit, Maestro, RuPay, etc.">
            Debit Cards
          </Checkbox>
          <Checkbox value="netbanking" helpText="Direct bank transfers">
            Netbanking
          </Checkbox>
          <Checkbox value="upi" helpText="Google Pay, PhonePe, Paytm UPI, etc.">
            UPI
          </Checkbox>
          <Checkbox value="wallet" helpText="Paytm, Amazon Pay, PhonePe, etc.">
            Wallets
          </Checkbox>
        </CheckboxGroup>
      </Box>

      {/* Section 3: Notification Preferences (Controlled Checkboxes) */}
      <Box display="flex" flexDirection="column" gap="spacing.4">
        <Text size="medium" weight="semibold">
          Notification Preferences
        </Text>

        <CheckboxGroup
          label="How would you like to receive notifications?"
          name="notification_preferences"
          labelPosition="left"
          necessityIndicator="optional"
          helpText="Select your preferred notification channels"
        >
          <Checkbox
            value="email"
            isChecked={emailNotifications}
            onChange={(e) => setEmailNotifications(e.isChecked)}
          >
            Email Notifications
          </Checkbox>

          <Checkbox
            value="sms"
            isChecked={smsNotifications}
            onChange={(e) => setSmsNotifications(e.isChecked)}
          >
            SMS Notifications
          </Checkbox>
        </CheckboxGroup>
      </Box>

      {/* Section 4: Advanced Settings (Disabled Checkboxes) */}
      <Box display="flex" flexDirection="column" gap="spacing.4">
        <Text size="medium" weight="semibold">
          Advanced Settings
        </Text>

        <CheckboxGroup
          label="Enterprise Features"
          name="enterprise_features"
          isDisabled
          helpText="Contact your account manager to enable these features"
        >
          <Checkbox value="recurring_billing">Recurring Billing</Checkbox>
          <Checkbox value="payment_links">Payment Links</Checkbox>
          <Checkbox value="subscription_management">Subscription Management</Checkbox>
        </CheckboxGroup>
      </Box>

      {/* Section 5: Terms and Conditions (Required Checkbox with Ref) */}
      <Box display="flex" flexDirection="column" gap="spacing.4">
        <Checkbox
          ref={termsCheckboxRef}
          isChecked={termsAgreed}
          onChange={(e) => setTermsAgreed(e.isChecked)}
          isRequired
          validationState={formSubmitted && !termsAgreed ? 'error' : 'none'}
          errorText="You must agree to the terms and conditions"
          helpText="By checking this box, you agree to our terms of service"
          size="large"
        >
          I agree to the Terms and Conditions
        </Checkbox>
      </Box>

      <Button type="submit" variant="primary" size="medium">
        Complete Setup
      </Button>
    </form>
  );
};

export default PaymentSetupForm;
```

### Product Configuration Form

This example showcases a product configuration form with checkboxes for customizing a product purchase. It demonstrates different Checkbox sizes and validation states.

```tsx
import React, { useState } from 'react';
import { Checkbox, CheckboxGroup, Box, Text, Button, Heading } from '@razorpay/blade/components';

const ProductConfigurationForm = () => {
  // State for selected features
  const [selectedFeatures, setSelectedFeatures] = useState(['basic_reporting']);

  // State for add-ons
  const [giftWrap, setGiftWrap] = useState(false);
  const [expressShipping, setExpressShipping] = useState(false);
  const [insuranceAdded, setInsuranceAdded] = useState(false);

  // State for validation
  const [showValidation, setShowValidation] = useState(false);

  // Validate and submit
  const handleSubmit = (e) => {
    e.preventDefault();
    setShowValidation(true);

    if (selectedFeatures.length > 0) {
      console.log('Configuration submitted:', {
        selectedFeatures,
        addOns: {
          giftWrap,
          expressShipping,
          insuranceAdded,
        },
      });

      alert('Product configured successfully!');
    }
  };

  return (
    <form>
      <Heading size="medium">Configure Your Product</Heading>

      {/* Product Features Section */}
      <CheckboxGroup
        label="Choose Product Features"
        name="product_features"
        necessityIndicator="required"
        helpText="Select at least one feature package"
        errorText="You must select at least one feature"
        validationState={showValidation && selectedFeatures.length === 0 ? 'error' : 'none'}
        value={selectedFeatures}
        onChange={(e) => setSelectedFeatures(e.values)}
        isRequired
      >
        <Checkbox value="basic_reporting" helpText="Includes standard reports and basic analytics">
          Basic Reporting
        </Checkbox>
        <Checkbox
          value="advanced_analytics"
          helpText="Unlock detailed user behavior tracking and custom reports"
        >
          Advanced Analytics
        </Checkbox>
        <Checkbox value="multi_user" helpText="Add up to 5 team members with custom permissions">
          Multi-User Access
        </Checkbox>
        <Checkbox value="api_access" helpText="Connect with our API for custom integrations">
          API Access
        </Checkbox>
      </CheckboxGroup>

      {/* Add-ons Section with Various Checkboxes */}
      <Box display="flex" flexDirection="column" gap="spacing.4">
        <Text size="medium" weight="semibold">
          Optional Add-ons
        </Text>

        <Checkbox
          isChecked={giftWrap}
          onChange={(e) => setGiftWrap(e.isChecked)}
          name="gift_wrap"
          helpText="Items will be wrapped in premium packaging"
          size="small"
        >
          Gift Wrapping (+â‚¹99)
        </Checkbox>

        <Checkbox
          isChecked={expressShipping}
          onChange={(e) => setExpressShipping(e.isChecked)}
          name="express_shipping"
          helpText="Guaranteed delivery within 24 hours"
          size="small"
        >
          Express Shipping (+â‚¹199)
        </Checkbox>

        <Checkbox
          isChecked={insuranceAdded}
          onChange={(e) => setInsuranceAdded(e.isChecked)}
          name="insurance"
          helpText="Protection against damage or loss during shipping"
          size="small"
        >
          Add Shipping Insurance (+â‚¹149)
        </Checkbox>
      </Box>

      {/* Disabled Options Based on Plan */}
      <Box display="flex" flexDirection="column" gap="spacing.4">
        <Text size="medium" weight="semibold">
          Enterprise Features
        </Text>
        <Text size="small" color="surface.text.gray.muted">
          The following features are only available with Enterprise plan
        </Text>

        <Checkbox
          isDisabled
          name="white_label"
          helpText="Remove all Razorpay branding from customer-facing elements"
        >
          White Labeling
        </Checkbox>

        <Checkbox
          isDisabled
          name="priority_support"
          helpText="24/7 dedicated support team with 1-hour response time"
        >
          Priority Support
        </Checkbox>
      </Box>

      <Button type="submit" variant="primary">
        Save Configuration
      </Button>
    </form>
  );
};

export default ProductConfigurationForm;
```

---

## Chip

## Component Name

Chip

## Description

Chip and ChipGroup components enable users to make selections, filter content, and trigger actions through selectable elements. ChipGroup manages collections of Chips that can be configured for single or multiple selection. Chips are compact, interactive elements that support icons, various colors, and sizes, making them ideal for selection interfaces and filters.

## Important Constraints

- `Chip` component can only be used within the context of a `ChipGroup` component
- `ChipGroup` component only accepts `Chip` components as children
- The `value` and `defaultValue` props must match the `selectionType` (string for "single", array for "multiple")

Make sure to only follow structure as given in the examples below. Fragments are also not allowed as children in these components.

## TypeScript Types

The following types represent the props that the Chip component and its subcomponents accept. These allow you to properly configure the components according to your needs.

```typescript
/**
 * Props for the Chip component
 */
type ChipProps = {
  /**
   * The content to display inside the chip
   */
  children?: React.ReactNode;

  /**
   * Sets the visual color of the chip, overriding the color set by parent ChipGroup
   * @default "primary"
   */
  color?: 'primary' | 'positive' | 'negative';

  /**
   * Icon to display within the chip
   */
  icon?: IconComponent;

  /**
   * Whether the chip is disabled
   * @default false
   */
  isDisabled?: boolean;

  /**
   * Value associated with the chip, used for selection state
   */
  value: string;

  /**
   * Callback fired when chip is clicked
   */
  onClick?: (event: React.MouseEvent<HTMLElement>) => void;
} & StyledPropsBlade &
  TestID;

/**
 * Props for the ChipGroup component
 */
type ChipGroupProps = {
  /**
   * Accessibility label describing the purpose of the chip group
   */
  accessibilityLabel: string;

  /**
   * Chips to be rendered within the group
   */
  children: React.ReactNode;

  /**
   * Sets the visual color that applies to all chips in the group (unless overridden)
   * @default "primary"
   */
  color?: 'primary' | 'positive' | 'negative';

  /**
   * Initial value(s) for uncontrolled usage
   */
  defaultValue?: string | string[];

  /**
   * Error text to display when validation state is error
   */
  errorText?: string;

  /**
   * Help text to display below the chip group
   */
  helpText?: string;

  /**
   * Whether the chip group is disabled
   * @default false
   */
  isDisabled?: boolean;

  /**
   * Whether the chip group is required
   * @default false
   */
  isRequired?: boolean;

  /**
   * Label for the chip group
   */
  label?: string;

  /**
   * Position of the label relative to the chip group
   * @default "top"
   */
  labelPosition?: 'top' | 'left';

  /**
   * Name of the chip group for form submission
   */
  name?: string;

  /**
   * Indicator for whether the chip group is required or optional
   * @default "none"
   */
  necessityIndicator?: 'none' | 'required' | 'optional';

  /**
   * Callback fired when selection changes
   */
  onChange?: (event: { name?: string; values: string[] }) => void;

  /**
   * Defines the selection behavior of the chip group
   * @default "single"
   */
  selectionType?: 'single' | 'multiple';

  /**
   * Size of all chips within the group
   * @default "medium"
   */
  size?: 'xsmall' | 'small' | 'medium' | 'large';

  /**
   * The validation state of the chip group
   * @default "none"
   */
  validationState?: 'error' | 'none';

  /**
   * Selected value(s) for controlled usage
   */
  value?: string | string[];
} & StyledPropsBlade &
  TestID;

/**
 * Type for Icon Component
 */
type IconComponent = React.ComponentType<IconProps>;
```

## Examples

### Independent Chips for Product Information

This example demonstrates using Chip components independently (without ChipGroup) to display product details. It showcases various chip features including different colors, disabled states, and icon-only variations.

```tsx
import React from 'react';
import {
  Box,
  Chip,
  Heading,
  Text,
  TagIcon,
  StarIcon,
  CheckCircleIcon,
  BoxIcon,
  CreditCardIcon,
  OffersIcon,
  CalendarIcon,
  InfoIcon,
  ShieldIcon,
  RefreshIcon,
  CloseIcon,
} from '@razorpay/blade/components';

const ProductDetailsCard = () => {
  return (
    <Box
      display="flex"
      flexDirection="column"
      gap="spacing.4"
      padding="spacing.6"
      maxWidth="600px"
      borderWidth="thin"
      borderStyle="solid"
      borderColor="surface.border.gray.normal"
      borderRadius="medium"
    >
      <Heading size="large">Wireless Bluetooth Headphones</Heading>
      <Text size="large" weight="semibold">
        â‚¹2,499
      </Text>

      {/* Features with different colors and icons */}
      <Box>
        <Text size="medium" weight="semibold" marginBottom="spacing.2">
          Features
        </Text>
        <Box display="flex" gap="spacing.2" flexWrap="wrap">
          <Chip value="24hr-battery" icon={CheckCircleIcon} color="positive">
            24hr Battery
          </Chip>
          <Chip value="noise-cancelling" icon={CheckCircleIcon} color="positive">
            Noise Cancelling
          </Chip>
          <Chip value="voice-assistant" icon={CheckCircleIcon} color="primary">
            Voice Assistant
          </Chip>
          <Chip value="bluetooth" icon={CheckCircleIcon} color="primary">
            Bluetooth 5.0
          </Chip>
        </Box>
      </Box>

      {/* Payment options mixing regular, disabled and icon-only chips */}
      <Box>
        <Text size="medium" weight="semibold" marginBottom="spacing.2">
          Payment & Delivery
        </Text>
        <Box display="flex" flexDirection="column" gap="spacing.3">
          {/* Payment methods row */}
          <Box display="flex" gap="spacing.2" flexWrap="wrap">
            <Chip value="credit-card" icon={CreditCardIcon}>
              Credit Card
            </Chip>
            <Chip value="upi">UPI</Chip>
            <Chip value="emi" icon={CreditCardIcon}>
              EMI
            </Chip>
            <Chip value="cod" isDisabled>
              Cash on Delivery
            </Chip>
          </Box>

          {/* Delivery options row */}
          <Box display="flex" gap="spacing.2" flexWrap="wrap">
            <Chip value="free-shipping" icon={BoxIcon} color="positive">
              Free Shipping
            </Chip>
            <Chip value="express" icon={CalendarIcon}>
              Express (2-3 days)
            </Chip>
            <Chip value="discount" icon={OffersIcon} color="primary">
              10% Off
            </Chip>
            <Chip value="international" icon={BoxIcon} isDisabled>
              International
            </Chip>
          </Box>

          {/* Row with icon-only chips for simple status indicators */}
          <Box display="flex" alignItems="center" gap="spacing.3">
            <Text size="small">Quick status:</Text>
            <Chip value="available" icon={CheckCircleIcon} color="positive" />
            <Chip value="warranty" icon={ShieldIcon} color="primary" />
            <Chip value="exchange" icon={RefreshIcon} />
            <Chip value="gift" icon={OffersIcon} isDisabled />
          </Box>
        </Box>
      </Box>
    </Box>
  );
};

export default ProductDetailsCard;
```

### Business Category Selection with ChipGroup

This example demonstrates a comprehensive form with different ChipGroup configurations, including single and multiple selection, various sizes, colors, icons, validation states, disabled groups, and icon-only chips.

```tsx
import React, { useState } from 'react';
import {
  Box,
  Chip,
  ChipGroup,
  Heading,
  Text,
  Button,
  AppStoreIcon,
  BuildingIcon,
  CreditCardIcon,
  WifiIcon,
  ShoppingBagIcon,
  StarIcon,
  ThumbsUpIcon,
  ThumbsDownIcon,
  CloseIcon,
} from '@razorpay/blade/components';

const BusinessRegistrationForm = () => {
  // Form state for different ChipGroup components
  const [businessType, setBusinessType] = useState('small-business');
  const [industries, setIndustries] = useState(['retail']);
  const [paymentMethods, setPaymentMethods] = useState(['cards', 'upi']);
  const [feedback, setFeedback] = useState('');

  // Validation state
  const [showValidation, setShowValidation] = useState(false);

  // Handle form submission
  const handleSubmit = (e) => {
    e.preventDefault();
    setShowValidation(true);

    if (businessType && industries.length > 0 && paymentMethods.length > 0) {
      console.log('Form submitted:', {
        businessType,
        industries,
        paymentMethods,
        feedback,
      });

      alert('Registration successful!');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <Heading size="large">Business Registration</Heading>

      {/* Single selection with label, default value, and different sizes */}
      <ChipGroup
        label="Business Type"
        accessibilityLabel="Select your business type from the options below"
        labelPosition="top"
        necessityIndicator="required"
        isRequired
        helpText="Select the type that best describes your business"
        value={businessType}
        onChange={({ values }) => setBusinessType(values[0])}
        selectionType="single"
        size="medium"
        validationState={showValidation && !businessType ? 'error' : 'none'}
        errorText="Business type is required"
      >
        <Chip value="proprietorship" icon={AppStoreIcon}>
          Proprietorship
        </Chip>
        <Chip value="small-business" icon={BuildingIcon}>
          Small Business
        </Chip>
        <Chip value="enterprise" icon={BuildingIcon}>
          Enterprise
        </Chip>
        <Chip value="partnership" icon={BuildingIcon}>
          Partnership
        </Chip>
      </ChipGroup>

      {/* Multiple selection with custom colors */}
      <ChipGroup
        label="Industry Categories"
        accessibilityLabel="Select all industries that apply to your business"
        labelPosition="left"
        helpText="You can select multiple industries"
        validationState={showValidation && industries.length === 0 ? 'error' : 'none'}
        errorText="At least one industry must be selected"
        necessityIndicator="required"
        isRequired
        value={industries}
        onChange={({ values }) => setIndustries(values)}
        selectionType="multiple"
        size="small"
      >
        <Chip value="retail" icon={ShoppingBagIcon}>
          Retail
        </Chip>
        <Chip value="finance" icon={CreditCardIcon} color="primary">
          Finance
        </Chip>
        <Chip value="technology" icon={WifiIcon} color="positive">
          Technology
        </Chip>
        <Chip value="hospitality" color="negative">
          Hospitality
        </Chip>
        <Chip value="education">Education</Chip>
      </ChipGroup>

      {/* Payment methods selection with disabled premium features */}
      <Box display="flex" flexDirection="column" gap="spacing.5">
        <ChipGroup
          label="Payment Methods"
          accessibilityLabel="Select payment methods you want to accept"
          helpText="Choose payment methods your business will accept"
          value={paymentMethods}
          onChange={({ values }) => setPaymentMethods(values)}
          selectionType="multiple"
          size="xsmall"
        >
          <Chip value="cards">Credit/Debit Cards</Chip>
          <Chip value="upi">UPI</Chip>
          <Chip value="netbanking">Netbanking</Chip>
          <Chip value="wallet">Wallets</Chip>
        </ChipGroup>

        <ChipGroup
          label="Premium Features (Available after approval)"
          accessibilityLabel="Premium features available after approval"
          helpText="These features will be available after your account is reviewed"
          isDisabled={true}
          selectionType="multiple"
          size="xsmall"
        >
          <Chip value="international">International Payments</Chip>
          <Chip value="subscription">Subscription Billing</Chip>
          <Chip value="analytics">Advanced Analytics</Chip>
        </ChipGroup>
      </Box>

      <Button type="submit" variant="primary" size="medium">
        Complete Registration
      </Button>
    </form>
  );
};

export default BusinessRegistrationForm;
```

### Interactive Product Filter with State Management

This example demonstrates a controlled ChipGroup implementation for an e-commerce product filter, showcasing a different layout and interaction pattern.

```tsx
import React, { useState, useRef } from 'react';
import {
  Box,
  Chip,
  ChipGroup,
  Heading,
  Text,
  Button,
  TagIcon,
  FilterIcon,
  CloseIcon,
} from '@razorpay/blade/components';

const ProductFilterInterface = () => {
  // State for filters
  const [categories, setCategories] = useState<string[]>([]);
  const [priceRanges, setPriceRanges] = useState<string>('');
  const [availability, setAvailability] = useState<string>('');
  const [sortOrder, setSortOrder] = useState<string>('recommended');

  // Ref for focusing a chip
  const newArrivalsRef = useRef<HTMLDivElement>(null);

  // Reset all filters
  const clearAllFilters = () => {
    setCategories([]);
    setPriceRanges('');
    setAvailability('');
    setSortOrder('recommended');
  };

  // Focus on a specific filter option
  const focusNewArrivals = () => {
    if (newArrivalsRef.current) {
      newArrivalsRef.current.focus();
      setAvailability('new-arrivals');
    }
  };

  return (
    <Box
      display="flex"
      flexDirection="column"
      gap="spacing.6"
      padding="spacing.6"
      maxWidth="800px"
      borderWidth="thin"
      borderStyle="solid"
      borderColor="surface.border.gray.normal"
      borderRadius="medium"
    >
      <Box display="flex" justifyContent="space-between" alignItems="center">
        <Heading size="medium">Product Filters</Heading>

        <Button variant="secondary" size="small" icon={CloseIcon} onClick={clearAllFilters}>
          Clear All
        </Button>
      </Box>

      {/* Categories - Multiple selection with color and status indicator */}
      <ChipGroup
        label="Categories"
        accessibilityLabel="Filter products by category"
        value={categories}
        onChange={({ values }) => setCategories(values)}
        selectionType="multiple"
        helpText={
          categories.length
            ? `${categories.length} categories selected`
            : 'Select categories to filter products'
        }
        size="small"
      >
        <Box display="flex" flexWrap="wrap" gap="spacing.3">
          <Chip value="electronics">Electronics</Chip>
          <Chip value="clothing">Clothing</Chip>
          <Chip value="home-decor">Home Decor</Chip>
          <Chip value="kitchen">Kitchen</Chip>
          <Chip value="books">Books</Chip>
          <Chip value="sports">Sports</Chip>
          <Chip value="beauty">Beauty</Chip>
          <Chip value="toys">Toys</Chip>
        </Box>
      </ChipGroup>

      {/* Price Range - Single selection with horizontal layout */}
      <ChipGroup
        label="Price Range"
        accessibilityLabel="Filter products by price range"
        value={priceRanges}
        onChange={({ values }) => setPriceRanges(values[0])}
        selectionType="single"
        size="xsmall"
        helpText="Select a price range to filter products"
        color="primary"
      >
        <Box display="flex" gap="spacing.2" flexWrap="wrap">
          <Chip value="under-500">Under â‚¹500</Chip>
          <Chip value="500-1000">â‚¹500 - â‚¹1000</Chip>
          <Chip value="1000-5000">â‚¹1000 - â‚¹5000</Chip>
          <Chip value="5000-10000">â‚¹5000 - â‚¹10000</Chip>
          <Chip value="over-10000">Over â‚¹10000</Chip>
        </Box>
      </ChipGroup>

      {/* Availability - Single selection with ref for focus */}
      <ChipGroup
        label="Availability"
        accessibilityLabel="Filter products by availability"
        value={availability}
        onChange={({ values }) => setAvailability(values[0])}
        selectionType="single"
        size="medium"
      >
        <Chip value="in-stock">In Stock</Chip>
        <Chip value="on-sale" color="positive">
          On Sale
        </Chip>
        <Chip ref={newArrivalsRef} value="new-arrivals">
          New Arrivals
        </Chip>
        <Chip value="pre-order">Pre-Order</Chip>
      </ChipGroup>
    </Box>
  );
};

export default ProductFilterInterface;
```

---

## Code

## Component Name

Code

## Description

The Code component is designed for displaying inline code snippets, token names, or variable names within text content. It provides a monospace font with optional highlighting and supports both web and React Native platforms. The component automatically handles proper text alignment and spacing, making it ideal for technical documentation, configuration guides, or any content that needs to display code-like text inline with regular content.

## Important Constraints

- `color` prop cannot be used without `isHighlighted={false}`

## TypeScript Types

The following types define the props that the Code component accepts. These types help you understand what properties you can pass to customize the Code component's appearance and behavior.

```typescript
type CodeCommonProps = {
  /**
   * Sets the color of the Heading component.
   */
  children: StringChildrenType;
  /**
   * Decides the fontSize and padding of Code
   *
   * @default small
   */
  size?: 'small' | 'medium';
  weight?: 'regular' | 'bold';
  isHighlighted?: boolean;
  color?: string;
} & TestID &
  StyledPropsBlade;

type CodeHighlightedProps = CodeCommonProps & {
  /**
   * Adds background color to highlight the text
   *
   * @default true
   */
  isHighlighted?: true;
  /**
   * color prop can only be added when `isHighlighted` is set to `false`
   */
  color?: undefined;
};

type CodeNonHighlightedProps = CodeCommonProps & {
  /**
   * Adds background color to highlight the text
   *
   * @default true
   */
  isHighlighted: false;
  /**
   * color prop to set color of text when `isHighlighted` is set to false
   */
  color?: string;
};

type CodeProps = CodeHighlightedProps | CodeNonHighlightedProps;
```

## Example

Here's a comprehensive example showcasing the Code component's various features and props:

```tsx
import { Code, Text, Box } from '@razorpay/blade/components';

function CodeExample() {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.4">
      {/* Basic usage with default highlighting */}
      <Text size="medium">
        Use environment variable <Code>RAZORPAY_API_KEY</Code> to configure the SDK
      </Text>

      {/* Code with custom size and weight */}
      <Text>
        The default export{' '}
        <Code size="medium" weight="bold" testID="export-code">
          RazorpayCheckout
        </Code>{' '}
        is available in the package
      </Text>

      {/* Non-highlighted code with custom color */}
      <Text>
        Status:{' '}
        <Code isHighlighted={false} color="feedback.text.positive.intense" weight="bold">
          COMPLETED
        </Code>
      </Text>

      {/* Multiple code snippets in a sentence */}
      <Text size="small">
        Replace <Code size="small">process.env.KEY_ID</Code> and{' '}
        <Code size="small">process.env.KEY_SECRET</Code> with your credentials
      </Text>

      {/* React Native specific layout */}
      <Box flexWrap="wrap" flexDirection="row" alignItems="flex-start">
        <Text>Configure webhook URL: </Text>
        <Code>https://your-domain.com/webhook</Code>
        <Text> in the dashboard</Text>
      </Box>

      {/* Technical documentation example */}
      <Text>
        Import the component using{' '}
        <Code size="medium">
          import {'{'} PaymentForm {'}'}
        </Code>{' '}
        and initialize with{' '}
        <Code size="medium" isHighlighted={false} color="interactive.text.primary.normal">
          new PaymentForm(config)
        </Code>
      </Text>
    </Box>
  );
}

export default CodeExample;
```

---

## Collapsible

## Component Name

Collapsible

## Description

Collapsible is a component that allows users to toggle the visibility of hidden content within a container. It provides an expandable/collapsible section that helps manage space efficiency in user interfaces. The component suite includes the main Collapsible container along with specialized trigger elements (CollapsibleButton, CollapsibleLink) and a content container (CollapsibleBody).

## Important Constraints

- `Collapsible` component only accepts `CollapsibleBody`, `CollapsibleButton`, and `CollapsibleLink` components as children

## TypeScript Types

The following types represent the props that the Collapsible component and its subcomponents accept. These allow you to properly configure the components according to your needs.

```typescript
/**
 * Props for the main Collapsible component
 */
type CollapsibleProps = {
  /**
   * Children of the Collapsible component should include a trigger element
   * (CollapsibleButton or CollapsibleLink) and a CollapsibleBody
   */
  children: React.ReactNode;

  /**
   * The default expanded state for uncontrolled usage
   * @default false
   */
  defaultIsExpanded?: boolean;

  /**
   * Direction in which the collapsible content expands
   * @default "bottom"
   */
  direction?: 'top' | 'bottom';

  /**
   * Whether the collapsible content is expanded (controlled mode)
   */
  isExpanded?: boolean;

  /**
   * Callback fired when the expanded state changes
   */
  onExpandChange?: (event: { isExpanded: boolean }) => void;
} & StyledPropsBlade &
  TestID;

/**
 * Props for the CollapsibleButton component
 */
type CollapsibleButtonProps = {
  /**
   * Content of the button
   */
  children: React.ReactNode;
} & StyledPropsBlade &
  TestID;

/**
 * Props for the CollapsibleLink component
 */
type CollapsibleLinkProps = {
  /**
   * Content of the link
   */
  children: React.ReactNode;
} & StyledPropsBlade &
  TestID;

/**
 * Props for the CollapsibleBody component
 */
type CollapsibleBodyProps = {
  /**
   * Content to be collapsed/expanded
   */
  children: React.ReactNode;
} & StyledPropsBlade &
  TestID;
```

## Examples

### Basic Usage: Uncontrolled Collapsible with Button Trigger

```tsx
import React from 'react';
import {
  Collapsible,
  CollapsibleButton,
  CollapsibleBody,
  Text,
  Box,
} from '@razorpay/blade/components';

const UncontrolledExample = () => {
  return (
    <Box maxWidth="500px">
      <Collapsible defaultIsExpanded={false}>
        <CollapsibleButton>Show More Information</CollapsibleButton>
        <CollapsibleBody>
          <Box padding="spacing.3">
            <Text>
              This is an uncontrolled Collapsible with a button trigger. The component manages its
              own expanded state internally using defaultIsExpanded.
            </Text>
          </Box>
        </CollapsibleBody>
      </Collapsible>
    </Box>
  );
};

export default UncontrolledExample;
```

### Controlled Collapsible with Read More Pattern

```tsx
import React, { useState } from 'react';
import {
  Collapsible,
  CollapsibleLink,
  CollapsibleBody,
  Text,
  Box,
  Button,
} from '@razorpay/blade/components';

const ControlledReadMoreExample = () => {
  // State for controlled collapsible
  const [detailsExpanded, setDetailsExpanded] = useState(false);

  return (
    <Box maxWidth="500px">
      <Text marginBottom="spacing.3">
        Collapsible components are perfect for implementing the "Read more" pattern. This is useful
        for long text content where you want to show just a preview initially.
      </Text>

      <Collapsible
        isExpanded={detailsExpanded}
        onExpandChange={({ isExpanded }) => setDetailsExpanded(isExpanded)}
      >
        <CollapsibleLink>{detailsExpanded ? 'Read less' : 'Read more'}</CollapsibleLink>
        <CollapsibleBody>
          <Box padding="spacing.3">
            <Text>
              This is a controlled Collapsible with a link trigger. External state management gives
              you complete control over the expanded state. Using CollapsibleLink instead of
              CollapsibleButton gives a more natural link appearance that's appropriate for in-line
              text expansions. This pattern helps keep interfaces clean while still providing access
              to the full content when needed.
            </Text>
          </Box>
        </CollapsibleBody>
      </Collapsible>
    </Box>
  );
};

export default ControlledReadMoreExample;
```

### Direction Control: Top Expansion

```tsx
import React from 'react';
import {
  Collapsible,
  CollapsibleButton,
  CollapsibleBody,
  Text,
  Box,
} from '@razorpay/blade/components';

const TopDirectionExample = () => {
  return (
    <Box
      maxWidth="500px"
      padding="spacing.4"
      borderWidth="thin"
      borderStyle="solid"
      borderColor="surface.border.gray.normal"
    >
      <Text marginBottom="spacing.4">
        The content below will expand upward instead of downward.
      </Text>

      <Collapsible direction="top">
        <CollapsibleButton>Expand Upward</CollapsibleButton>
        <CollapsibleBody>
          <Box padding="spacing.3" marginBottom="spacing.3">
            <Text>
              This content expands upward using direction="top". Useful when you need to prevent
              pushing content below out of view.
            </Text>
          </Box>
        </CollapsibleBody>
      </Collapsible>
    </Box>
  );
};

export default TopDirectionExample;
```

---

## Counter

## Component Name

Counter

## Description

Counter is a visual indicator that displays numerical values, tallies, or counts within a specific context. It provides a compact way to show non-interactive numerical data, with customizable appearance through size, color, and emphasis variations. Counters are useful for displaying notification counts, item quantities, or status indicators throughout an interface.

## TypeScript Types

The following types represent the props that the Counter component accepts. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the Counter component
 */
type CounterProps = {
  /**
   * The numerical value to display
   */
  value: number;

  /**
   * Maximum value to display before showing a "+" suffix
   * If value exceeds max, it will display "{max}+"
   * @example max={99} with value={120} would display "99+"
   */
  max?: number;

  /**
   * Visual color of the counter
   * @default "neutral"
   */
  color?: 'positive' | 'negative' | 'notice' | 'information' | 'neutral' | 'primary';

  /**
   * Visual emphasis/intensity of the counter
   * @default "subtle"
   */
  emphasis?: 'subtle' | 'intense';

  /**
   * Size of the counter
   * @default "medium"
   */
  size?: 'small' | 'medium' | 'large';
} & StyledPropsBlade &
  TestID;
```

## Example

This example demonstrates different variants of the Counter component with various sizes, colors, emphasis levels, and a max value with overflow handling.

```tsx
import React from 'react';
import { Counter, Box, Text } from '@razorpay/blade/components';

const CounterExample = () => {
  return (
    <Box padding="spacing.4">
      <Text marginBottom="spacing.4">Counter Component Examples</Text>

      <Box display="flex" flexWrap="wrap" gap="spacing.4">
        <Counter value={8} size="small" color="primary" />
        <Counter value={24} size="medium" color="positive" />
        <Counter value={42} size="small" color="negative" emphasis="intense" />
        <Counter value={1000} max={99} color="negative" emphasis="subtle" size="large" />
      </Box>
    </Box>
  );
};

export default CounterExample;
```

---

## CounterInput

# CounterInput

## Component Name

CounterInput

## Description

CounterInput is a specialized numerical input component that allows users to increment or decrement values using built-in plus/minus button controls alongside manual text input. It provides automatic value constraint enforcement with min/max limits, supports both controlled and uncontrolled usage patterns, and includes loading states with visual feedback. The component is designed for scenarios like quantity selection, subscription management, and any numerical value adjustment with clear boundaries.

## Usage Guidelines

### When to Use CounterInput

- **Small numerical values only** (typically 0-99)
- Quantity selection (cart items, subscription seats, etc.)
- Settings with clear boundaries (retry attempts, timeout values)
- Any scenario where users need to adjust small numbers with clear min/max constraints

### When NOT to Use CounterInput

- **Large numerical values (99+)** - Use a regular TextInput with `type="number"` instead
- Complex numerical input (decimals, currency, percentages) - Use specialized input components
- Values that don't benefit from increment/decrement buttons (IDs, phone numbers, etc.)

**Important:** CounterInput is optimized for small numbers and provides the best user experience when used for values typically under 100. For larger values, the increment/decrement interaction becomes inefficient and a standard numerical text input should be used instead.

## TypeScript Types

These types define the props that the CounterInput component accepts, along with its context types for internal state management.

```typescript
type CounterInputCommonProps = Pick<
  BaseInputProps,
  | 'labelPosition'
  | 'name'
  | 'onFocus'
  | 'onBlur'
  | 'isDisabled'
  | 'testID'
  | keyof DataAnalyticsAttribute
> & {
  /**
   * Accessibility label for the input (optional override)
   */
  accessibilityLabel?: string;
  /**
   * Label to be shown for the counter input
   */
  label?: string;

  /**
   * The numerical value of the counter input
   */
  value?: number;

  /**
   * The default numerical value when component is uncontrolled
   */
  defaultValue?: number;

  /**
   * Minimum allowed value. When reached, the decrement button will be disabled
   * @default 0
   */
  min?: number;

  /**
   * Maximum allowed value. When reached, the increment button will be disabled
   * If not provided, the increment button will not be disabled
   */
  max?: number;

  /**
   * Visual emphasis of the counter input
   * @default 'subtle'
   */
  emphasis?: 'subtle' | 'intense';

  /**
   * Size of the counter input
   * @default 'medium'
   */
  size?: 'xsmall' | 'medium' | 'large';

  /**
   * Decides whether to show a loading spinner and disable interaction
   * @default false
   */
  isLoading?: boolean;

  /**
   * Event handler called when the value changes via increment, decrement, or manual input
   */
  onChange?: (args: { value: number }) => void;
} & StyledPropsBlade &
  MotionMetaProp;

export type CounterInputProps = CounterInputCommonProps;

type CounterInputContextType = {
  /**
   * Size of the counter input
   */
  size?: CounterInputProps['size'];
  /**
   * Visual emphasis of the counter input
   */
  emphasis?: CounterInputProps['emphasis'];
  /**
   * Whether the counter input is disabled
   */
  isDisabled?: boolean;
  /**
   * Whether the counter input is in loading state
   */
  isLoading?: boolean;
  /**
   * Color of the counter input
   */
  color?: BaseTextProps['color'];
  /**
   * Disabled color text of the counter input
   */
  disabledTextColor?: BaseTextProps['color'];
  /**
   * Whether the counter input is inside an input group
   */
  isInsideCounterInput?: boolean;
};

export type { CounterInputContextType };
```

## Examples

### Comprehensive CounterInput Example

```tsx
import React from 'react';
import { CounterInput, Box } from '@razorpay/blade/components';
import { useState } from 'react';

function CounterInputExample(): React.ReactElement {
  const [values, setValues] = useState({
    xsmall: 1,
    medium: 5,
    large: 10,
    intense: 3,
    loading: 5,
    disabled: 3,
    uncontrolled: 7,
  });
  const [isLoading, setIsLoading] = useState(false);

  const handleChange = (key: string) => ({ value }: { value: number }) => {
    setValues((prev) => ({ ...prev, [key]: value }));
  };

  const handleLoadingChange = ({ value }: { value: number }) => {
    setIsLoading(true);
    setValues((prev) => ({ ...prev, loading: value }));

    // Simulate API call
    setTimeout(() => {
      setIsLoading(false);
    }, 1500);
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.4">
      {/* Size and Emphasis Variations */}
      <CounterInput
        label="XSmall Size"
        size="xsmall"
        emphasis="subtle"
        value={values.xsmall}
        onChange={handleChange('xsmall')}
        min={0}
        max={20}
        name="xsmall-counter"
        testID="xsmall-counter"
      />

      <CounterInput
        label="Medium Size (Default)"
        size="medium"
        emphasis="subtle"
        value={values.medium}
        onChange={handleChange('medium')}
        min={0}
        max={20}
        labelPosition="top"
      />

      <CounterInput
        label="Large Size with Left Label"
        size="large"
        emphasis="intense"
        labelPosition="left"
        value={values.large}
        onChange={handleChange('large')}
        min={0}
        max={20}
        onFocus={() => console.log('Large counter focused')}
        onBlur={() => console.log('Large counter blurred')}
      />

      <CounterInput
        accessibilityLabel="Counter without visible label using intense emphasis"
        emphasis="intense"
        value={values.intense}
        onChange={handleChange('intense')}
        min={0}
        max={20}
      />

      {/* Loading, Disabled, and Min/Max States */}
      <CounterInput
        label="Loading State Counter"
        value={values.loading}
        onChange={handleLoadingChange}
        isLoading={isLoading}
        min={1}
        max={10}
        emphasis="intense"
        size="medium"
      />

      <CounterInput
        label="Disabled Counter"
        value={values.disabled}
        onChange={handleChange('disabled')}
        isDisabled={true}
        min={0}
        max={20}
        emphasis="subtle"
      />

      <CounterInput
        label="Uncontrolled with Default Value"
        defaultValue={7}
        min={5}
        max={15}
        onChange={({ value }: { value: number }) => console.log('Value changed:', value)}
        name="uncontrolled-counter"
      />
    </Box>
  );
}
```

---

## DatePicker

## Component Name

DatePicker

## Description

DatePicker is a component for selecting dates or date ranges with an intuitive calendar interface. It supports single date selection or date range selection modes, with features such as date constraints, presets for quick selection, and validation states. Users can also type dates directly into the input field with automatic formatting and validation. The component also offers a FilterChipDatePicker variant for use in filtering interfaces, making it versatile for various date selection scenarios.

## Important Constraints

- Range DatePicker (`selectionType="range"`) only supports `pickerType="day"` - other picker types like "month" or "year" cannot be used with range selection

## TypeScript Types

The following types represent the props that the DatePicker component and its variants accept. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Selection types for DatePicker
 */
type DatePickerSelectionType = 'single' | 'range';

/**
 * Type for single date value
 */
type DateValue = Date | null;

/**
 * Type for date range value
 */
type DatesRangeValue = [DateValue, DateValue];

/**
 * Common props for both single and range DatePicker
 */
type DatePickerCommonProps<T extends DatePickerSelectionType> = {
  /**
   * Selection type for the date picker
   */
  selectionType: T;

  /**
   * Callback fired when date selection changes
   */
  onChange?: (date: T extends 'single' ? DateValue : DatesRangeValue) => void;

  /**
   * Whether the calendar is open
   */
  isOpen?: boolean;

  /**
   * Default open state (uncontrolled)
   */
  defaultIsOpen?: boolean;

  /**
   * Callback fired when the open state changes
   */
  onOpenChange?: (e: { isOpen: boolean }) => void;

  /**
   * Presets for quick selection (only applicable for range selection)
   */
  presets?: Array<{
    /**
     * Display label for the preset
     */
    label: string;
    /**
     * Function that returns a date range based on current date
     */
    value: (currentDate: Date) => [Date, Date];
  }>;

  /**
   * Minimum selectable date
   */
  minDate?: Date;

  /**
   * Maximum selectable date
   */
  maxDate?: Date;

  /**
   * Function to determine if a date should be excluded from selection
   */
  excludeDate?: (date: Date) => boolean;

  /**
   * Type of picker view (default: 'date')
   */
  picker?: 'date' | 'month' | 'year';

  /**
   * Default picker view (uncontrolled)
   */
  defaultPicker?: 'date' | 'month' | 'year';

  /**
   * Callback when picker view changes
   */
  onPickerChange?: (picker: 'date' | 'month' | 'year') => void;

  /**
   * First day of the week (0 = Sunday, 1 = Monday, etc.)
   */
  firstDayOfWeek?: 0 | 1 | 2 | 3 | 4 | 5 | 6;

  /**
   * Allow selecting a single date in range mode
   */
  allowSingleDateInRange?: boolean;

  /**
   * Whether to show the footer with apply/cancel buttons
   * @default true
   */
  showFooterActions?: boolean;

  /**
   * Custom React element to render in the footer above/side of action buttons
   * Can be used to add custom content like informational text, links, or other components
   */
  footer?: React.ReactElement;

  /**
   * Sets the date format to be displayed in the input field
   * @default 'DD/MM/YYYY'
   */
  format?: 'DD/MM/YYYY' | 'MMM' | 'MMMM' | 'YYYY';

  /**
   * Locale for date formatting and calendar text
   */
  locale?: string;

  /**
   * Events for navigation
   */
  onNext?: () => void;
  onNextDecade?: () => void;
  onNextMonth?: () => void;
  onNextYear?: () => void;
  onPrevious?: () => void;
  onPreviousDecade?: () => void;
  onPreviousMonth?: () => void;
  onPreviousYear?: () => void;
  onMonthSelect?: (month: Date) => void;
  onYearSelect?: (year: Date) => void;
} & StyledPropsBlade &
  TestID;

/**
 * Props for single selection DatePicker
 */
type SingleDatePickerProps = DatePickerCommonProps<'single'> & {
  /**
   * Selected date (controlled)
   */
  value?: DateValue;

  /**
   * Default selected date (uncontrolled)
   */
  defaultValue?: DateValue;

  /**
   * Label for the input
   */
  label?: string;

  /**
   * Accessibility label for screen readers
   */
  accessibilityLabel?: string;

  /**
   * Input size
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * Whether the input is disabled
   */
  isDisabled?: boolean;

  /**
   * Whether the input is required
   */
  isRequired?: boolean;

  /**
   * Auto focus the input on mount
   */
  autoFocus?: boolean;

  /**
   * Position of the label
   */
  labelPosition?: 'top' | 'left';

  /**
   * Whether to display the necessity indicator
   */
  necessityIndicator?: 'required' | 'optional' | 'none';

  /**
   * Help text to display below the input
   */
  helpText?: string;

  /**
   * Error text to display when validation state is 'error'
   */
  errorText?: string;

  /**
   * Success text to display when validation state is 'success'
   */
  successText?: string;

  /**
   * Validation state of the input
   */
  validationState?: 'error' | 'success' | 'none';

  /**
   * Name for the input for form submission
   */
  name?: string;
};

/**
 * Props for range selection DatePicker
 */
type RangeDatePickerProps = DatePickerCommonProps<'range'> & {
  /**
   * Selected date range (controlled)
   */
  value?: DatesRangeValue;

  /**
   * Default selected date range (uncontrolled)
   */
  defaultValue?: DatesRangeValue;

  /**
   * Labels for the start and end date inputs
   */
  label?: { start: string; end?: string };

  /**
   * Accessibility labels for screen readers
   */
  accessibilityLabel?: { start: string; end?: string };

  /**
   * Input size
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * Whether the inputs are disabled
   */
  isDisabled?: boolean;

  /**
   * Whether the inputs are required
   */
  isRequired?: boolean;

  /**
   * Auto focus the input on mount
   */
  autoFocus?: boolean;

  /**
   * Position of the label
   */
  labelPosition?: 'top' | 'left';

  /**
   * Whether to display the necessity indicator
   */
  necessityIndicator?: 'required' | 'optional' | 'none';

  /**
   * Help text to display below the inputs
   */
  helpText?: string | { start: string; end?: string };

  /**
   * Error text to display when validation state is 'error'
   */
  errorText?: string | { start: string; end?: string };

  /**
   * Success text to display when validation state is 'success'
   */
  successText?: string | { start: string; end?: string };

  /**
   * Validation state of the inputs
   */
  validationState?: 'error' | 'success' | 'none';

  /**
   * Names for the inputs for form submission
   */
  name?: { start: string; end?: string };
};

/**
 * Union type for DatePicker props based on selection type
 */
type DatePickerProps<T extends DatePickerSelectionType = 'single'> = T extends 'single'
  ? SingleDatePickerProps
  : RangeDatePickerProps;

/**
 * Props for FilterChipDatePicker component
 */
type FilterChipDatePickerProps<T extends DatePickerSelectionType = 'single'> = Omit<
  DatePickerProps<T>,
  'label' | 'accessibilityLabel' | 'size' | 'labelPosition'
> & {
  /**
   * Label for the filter chip
   */
  label: string;

  /**
   * Callback when clear button is clicked
   */
  onClearButtonClick?: () => void;
};
```

## Examples

### Single Date Selection

This example demonstrates a comprehensive single date picker with validation, constraints, and date exclusion.

```tsx
import React, { useState } from 'react';
import { DatePicker, Box, Text } from '@razorpay/blade/components';
import dayjs from 'dayjs';

const SingleDatePickerExample = () => {
  const [date, setDate] = useState<Date | null>(new Date());

  return (
    <Box display="flex" flexDirection="column" gap="spacing.8">
      <Box>
        <Text weight="semibold" marginBottom="spacing.3">
          Standard Configuration
        </Text>
        <DatePicker
          selectionType="single"
          label="Event date"
          labelPosition="left" // Left position for label
          size="medium"
          value={date}
          onChange={setDate}
          necessityIndicator="required"
          isRequired
          helpText="Choose a date for the event"
          // Date constraints
          minDate={dayjs().subtract(1, 'month').toDate()}
          maxDate={dayjs().add(1, 'month').toDate()}
          // Weekend exclusion
          excludeDate={(date) => {
            const day = dayjs(date).day();
            return day === 0 || day === 6; // Exclude weekends
          }}
        />

        <Text size="small" marginTop="spacing.2">
          Selected: {date ? dayjs(date).format('DD MMM YYYY') : 'None'}
        </Text>
      </Box>
    </Box>
  );
};

export default SingleDatePickerExample;
```

### Size Variants and Controlled State

This example shows different size variants of the DatePicker (small, medium, large) and how to control the DatePicker's open state programmatically.

```tsx
import React, { useState } from 'react';
import { DatePicker, Box, Text, Button } from '@razorpay/blade/components';
import dayjs from 'dayjs';

const SizeVariantsExample = () => {
  const [date, setDate] = useState<Date | null>(new Date());
  const [disabledDate, setDisabledDate] = useState<Date | null>(
    dayjs().subtract(1, 'week').toDate(),
  );
  const [isSingleOpen, setIsSingleOpen] = useState(false);

  return (
    <Box>
      <Text weight="semibold" marginBottom="spacing.3">
        Size Variants, Controlled DatePicker and showFooterActions as false
      </Text>
      <Box display="flex" gap="spacing.4" alignItems="flex-start">
        <DatePicker
          selectionType="single"
          label="Small"
          size="medium"
          value={date}
          onChange={setDate}
          isOpen={isSingleOpen}
          onOpenChange={({ isOpen }) => setIsSingleOpen(isOpen)}
          showFooterActions={false}
          footer={
            <Text size="small" color="surface.text.gray.muted">
              This section only displays records from the last 45 days. For earlier data, please
              download a report from the Reports section.
            </Text>
          }
        />

        <DatePicker
          selectionType="single"
          label="Large (Disabled)"
          size="large"
          isDisabled
          value={disabledDate}
        />
      </Box>

      <Box display="flex" gap="spacing.4" marginTop="spacing.3">
        <Button size="small" variant="secondary" onClick={() => setIsSingleOpen(!isSingleOpen)}>
          {isSingleOpen ? 'Close Calendar' : 'Open Calendar'}
        </Button>

        <Button
          size="small"
          variant="secondary"
          onClick={() => setDate(dayjs().add(1, 'week').toDate())}
        >
          Set to Next Week
        </Button>
      </Box>
    </Box>
  );
};

export default SizeVariantsExample;
```

### Month and Year Pickers

This example demonstrates alternative picker views for selecting months and years instead of specific dates.

```tsx
import React, { useState } from 'react';
import { DatePicker, Box, Text } from '@razorpay/blade/components';
import dayjs from 'dayjs';

const MonthYearPickerExample = () => {
  const [date, setDate] = useState<Date | null>(new Date());

  return (
    <Box>
      <Text weight="semibold" marginBottom="spacing.3">
        Month and Year Pickers
      </Text>
      <Box display="flex" gap="spacing.6">
        <DatePicker
          selectionType="single"
          label="Month"
          picker="month"
          value={date}
          onChange={(selectedDate) => {
            console.log('Selected month:', dayjs(selectedDate).format('MMMM YYYY'));
            setDate(selectedDate);
          }}
        />

        <DatePicker
          selectionType="single"
          label="Year"
          picker="year"
          value={date}
          onChange={(selectedDate) => {
            console.log('Selected year:', dayjs(selectedDate).format('YYYY'));
            setDate(selectedDate);
          }}
        />
      </Box>

      <Text size="small" marginTop="spacing.3">
        Selected: {date ? dayjs(date).format('MMMM YYYY') : 'None'}
      </Text>
    </Box>
  );
};

export default MonthYearPickerExample;
```

### Date Range Selection

This example demonstrates date range selection with presets and validation.

```tsx
import React, { useState } from 'react';
import { DatePicker, Box, Text, Button } from '@razorpay/blade/components';
import dayjs from 'dayjs';

const DateRangeExample = () => {
  // Date range with validation
  const [dateRange, setDateRange] = useState<[Date | null, Date | null]>([
    dayjs().subtract(7, 'days').toDate(),
    new Date(),
  ]);
  const [hasRangeError, setHasRangeError] = useState(false);
  const [isRangeOpen, setIsRangeOpen] = useState(false);

  // Define preset options for quick selection
  const datePresets = [
    {
      label: 'Last 7 days',
      value: (today: Date): [Date, Date] => {
        const sevenDaysAgo = new Date(today);
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        return [sevenDaysAgo, today];
      },
    },
    {
      label: 'Last 30 days',
      value: (today: Date): [Date, Date] => {
        const thirtyDaysAgo = new Date(today);
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        return [thirtyDaysAgo, today];
      },
    },
    {
      label: 'This month',
      value: (today: Date): [Date, Date] => {
        const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        return [firstDayOfMonth, today];
      },
    },
  ];

  // Handle range change with validation
  const handleRangeChange = (dates: [Date | null, Date | null]) => {
    setDateRange(dates);

    // Validate: range cannot be more than 7 days
    if (dates[0] && dates[1]) {
      const daysDiff = dayjs(dates[1]).diff(dates[0], 'day');
      setHasRangeError(daysDiff > 7);
    } else {
      setHasRangeError(false);
    }
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.8">
      {/* Comprehensive date range picker */}
      <Box>
        <Text weight="semibold" marginBottom="spacing.3">
          Complete Range DatePicker
        </Text>
        <DatePicker
          selectionType="range"
          label={{ start: 'Start Date', end: 'End Date' }}
          value={dateRange}
          onChange={handleRangeChange}
          validationState={hasRangeError ? 'error' : 'none'}
          errorText={{
            start: 'Range cannot exceed 7 days',
            end: 'Please select a shorter range',
          }}
          helpText={{ start: 'Select a date range or use preset options' }}
          presets={datePresets}
          isOpen={isRangeOpen}
          onOpenChange={({ isOpen }) => setIsRangeOpen(isOpen)}
          isRequired
          necessityIndicator="required"
          size="medium"
        />

        <Text
          size="small"
          marginTop="spacing.3"
          color={hasRangeError ? 'feedback.text.negative.intense' : undefined}
        >
          Selected: {dateRange[0] ? dayjs(dateRange[0]).format('DD MMM YYYY') : 'None'} -
          {dateRange[1] ? dayjs(dateRange[1]).format('DD MMM YYYY') : 'None'}
          {hasRangeError && ' (Error: Range too long)'}
        </Text>

        <Box display="flex" gap="spacing.4" marginTop="spacing.3">
          <Button size="small" variant="secondary" onClick={() => setIsRangeOpen(!isRangeOpen)}>
            {isRangeOpen ? 'Close Calendar' : 'Open Calendar'}
          </Button>

          <Button
            size="small"
            variant="secondary"
            onClick={() =>
              setDateRange([dayjs().startOf('month').toDate(), dayjs().endOf('month').toDate()])
            }
          >
            Set to Current Month
          </Button>
        </Box>
      </Box>
    </Box>
  );
};

export default DateRangeExample;
```

### FilterChipDatePicker

This example demonstrates the FilterChipDatePicker variant for filters and data selection interfaces.

```tsx
import React, { useState } from 'react';
import { FilterChipDatePicker, Box, Text } from '@razorpay/blade/components';
import dayjs from 'dayjs';

const FilterChipDatePickerExample = () => {
  // FilterChip states
  const [singleDate, setSingleDate] = useState<Date | null>(null);
  const [dateRange, setDateRange] = useState<[Date | null, Date | null]>([null, null]);

  // Common presets
  const datePresets = [
    {
      label: 'Last 7 days',
      value: (date: Date): [Date, Date] => [dayjs(date).subtract(7, 'days').toDate(), date],
    },
    {
      label: 'This month',
      value: (date: Date): [Date, Date] => [
        dayjs(date).startOf('month').toDate(),
        dayjs(date).endOf('month').toDate(),
      ],
    },
  ];

  return (
    <Box>
      <Text weight="semibold" marginBottom="spacing.3">
        FilterChipDatePicker Variants
      </Text>
      <Box display="flex" gap="spacing.4" alignItems="flex-start">
        <Box>
          <Text size="small" marginBottom="spacing.2">
            Single Selection
          </Text>
          <FilterChipDatePicker
            label="Created Date"
            selectionType="single"
            value={singleDate}
            onChange={(date) => setSingleDate(date as Date)}
          />
        </Box>

        <Box>
          <Text size="small" marginBottom="spacing.2">
            Range Selection with Presets
          </Text>
          <FilterChipDatePicker
            label="Date Range"
            selectionType="range"
            value={dateRange}
            onChange={(date) => setDateRange(date as [Date | null, Date | null])}
            presets={datePresets}
            onClearButtonClick={() => setDateRange([null, null])}
          />
        </Box>
      </Box>

      <Box marginTop="spacing.3">
        <Text size="small">
          Single Date: {singleDate ? dayjs(singleDate).format('DD MMM YYYY') : 'None'}
        </Text>
        <Text size="small">
          Date Range: {dateRange[0] ? dayjs(dateRange[0]).format('DD MMM YYYY') : 'None'} -
          {dateRange[1] ? dayjs(dateRange[1]).format('DD MMM YYYY') : 'None'}
        </Text>
      </Box>
    </Box>
  );
};

export default FilterChipDatePickerExample;
```

### Localization

This example demonstrates how to use the DatePicker with different locales for international applications.

```tsx
import React from 'react';
import { DatePicker, Box, Text } from '@razorpay/blade/components';
import { I18nProvider } from '@razorpay/i18nify-react';

const LocalizationExample = () => {
  return (
    <Box>
      <Text weight="semibold" marginBottom="spacing.3">
        DatePicker Localization
      </Text>
      <Box display="flex" gap="spacing.6" flexWrap="wrap">
        {/* Hindi locale */}
        <Box width="250px">
          <Text size="small" marginBottom="spacing.2">
            Hindi
          </Text>
          <I18nProvider initData={{ locale: 'hi-IN' }}>
            <DatePicker selectionType="single" label="à¤¤à¤¾à¤°à¥€à¤– à¤šà¥à¤¨à¥‡à¤‚" size="medium" />
          </I18nProvider>
        </Box>

        {/* Malay locale */}
        <Box width="250px">
          <Text size="small" marginBottom="spacing.2">
            Malay
          </Text>
          <I18nProvider initData={{ locale: 'ms-MY' }}>
            <DatePicker selectionType="single" label="Pilih Tarikh" size="medium" />
          </I18nProvider>
        </Box>
      </Box>
    </Box>
  );
};

export default LocalizationExample;
```

---

## Display

## Component Name

Display

## Description

The Display component is designed for creating high-impact, eye-catching typography sections, particularly suited for landing pages. It renders with the largest text sizes in the typography system and automatically uses semantic h1 tags on web platforms. The component offers various sizes and weights with carefully crafted letter spacing, making it perfect for hero sections, banners, and other prominent content areas where visual impact is crucial.

## TypeScript Types

The following types define the props that the Display component accepts. These types help you understand what properties you can pass to customize the Display component's appearance and behavior.

```typescript
type DisplayProps = {
  as?: 'span' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
  /**
   * Overrides the color of the Display component.
   *
   * **Note** This takes priority over `type` and `contrast` prop to decide color of title
   */
  color?: string;
  size?: 'small' | 'medium' | 'large' | 'xlarge';
  weight?: 'regular' | 'medium' | 'semibold';
  children: React.ReactNode;
  textAlign?: string;
  textDecorationLine?: string;
} & TestID &
  StyledPropsBlade;
```

## Example

Here's a comprehensive example showcasing the Display component's various features and props:

```tsx
import { Display, Box } from '@razorpay/blade/components';

function DisplayExample() {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.8">
      {/* Hero section with largest display */}
      <Display
        size="xlarge"
        weight="semibold"
        color="surface.text.primary.normal"
        textAlign="center"
      >
        Transform Your Business
      </Display>

      {/* Feature highlight with mixed styles */}
      <Display size="large">
        Powerful{' '}
        <Display as="span" size="large" color="feedback.text.information.intense" weight="medium">
          Payment Solutions
        </Display>
      </Display>

      {/* Pricing section with emphasis */}
      <Display size="medium">
        Starting at just{' '}
        <Display as="span" size="medium" color="feedback.text.positive.intense">
          25% Off on Premium Plans
        </Display>
        <Display as="span" size="small" weight="regular">
          *
        </Display>
      </Display>

      {/* Call to action with custom alignment */}
      <Display size="small" weight="medium" textAlign="left" color="surface.text.primary.normal">
        Get Started Today
      </Display>

      {/* Multi-line display text with decoration */}
      <Display size="medium" textDecorationLine="underline" color="surface.text.gray.normal">
        Trusted by 10M+{' '}
        <Display as="span" size="medium" color="surface.text.primary.normal">
          Businesses
        </Display>
      </Display>
    </Box>
  );
}

export default DisplayExample;
```

---

## Divider

## Component Name

Divider

## Description

Divider is a visual element used to separate or divide content within a layout. It provides a clear visual distinction between different sections of content, enhancing readability and organization. The component supports both horizontal and vertical orientations, making it versatile for various UI patterns and layout requirements.

## TypeScript Types

The following types represent the props that the Divider component accepts. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the Divider component
 */
type DividerProps = {
  /**
   * Sets the orientation of divider
   * @default 'horizontal'
   */
  orientation?: 'horizontal' | 'vertical';

  /**
   * Sets the style of divider
   * @default 'solid'
   */
  dividerStyle?: 'solid' | 'dashed';

  /**
   * Sets the variant of divider
   * @default 'muted'
   */
  variant?: 'normal' | 'subtle' | 'muted';

  /**
   * Sets the thickness of divider
   * @default 'thin'
   */
  thickness?: 'thinner' | 'thin' | 'thick' | 'thicker';

  /**
   * Sets the height of divider. Divider uses Flex by default, use height only when parent is not flex.
   */
  height?: CSSObject['height'];

  /**
   * Sets the width of divider. Divider uses Flex by default, use width only when parent is not flex.
   */
  width?: CSSObject['width'];
} & StyledPropsBlade &
  TestID;
```

## Examples

### Horizontal Divider

This example shows the default horizontal divider that separates text sections with vertical spacing.

```tsx
import { Divider, Box, Text } from '@razorpay/blade/components';

const HorizontalDividerExample = () => (
  <Box>
    <Text>Section One</Text>
    <Divider marginY="spacing.3" />
    <Text>Section Two</Text>
  </Box>
);
```

### Vertical Divider

This example demonstrates a vertical divider that separates inline content horizontally within a flex container.

```tsx
import { Divider, Box, Text } from '@razorpay/blade/components';

const VerticalDividerExample = () => (
  <Box display="flex" alignItems="center" height="40px">
    <Text>Left</Text>
    <Divider orientation="vertical" marginX="spacing.4" height="100%" />
    <Text>Right</Text>
  </Box>
);
```

### Styled Divider

This example shows how to customize dividers with different colors and thicknesses to create visual hierarchies.

```tsx
import { Divider, Box, Text } from '@razorpay/blade/components';

const StyledDividerExample = () => (
  <Box>
    <Text>Regular divider below</Text>
    <Divider marginY="spacing.2" />

    <Text>Colored divider below</Text>
    <Divider marginY="spacing.2" variant="normal" thickness="thick" />
  </Box>
);
```

### Divider with Different Styles and Variants

This example demonstrates divider styles (solid/dashed), variants (normal/subtle/muted), and thickness options.

```tsx
import { Divider, Box, Text } from '@razorpay/blade/components';

const DividerVariantsExample = () => (
  <Box>
    <Text>Dashed divider</Text>
    <Divider dividerStyle="dashed" marginY="spacing.2" />

    <Text>Subtle variant with thick thickness</Text>
    <Divider variant="subtle" thickness="thick" marginY="spacing.2" />

    <Text>Dashed with normal variant</Text>
    <Divider dividerStyle="dashed" variant="normal" thickness="thicker" marginY="spacing.2" />
  </Box>
);
```

---

## DonutChart

# DonutChart

## Description

DonutChart is a circular data visualization component built on top of Recharts with Blade design system styling. It displays data as segments of a donut-shaped chart with customizable radius, colors, and center text. The component supports both full circle and semicircle variants, making it ideal for displaying proportional data, percentages, and categorical information in an intuitive visual format.

## Important Constraints

- `ChartDonut` component must be wrapped inside `ChartDonutWrapper` component
- `data` prop is required and must be an array of objects with consistent structure
- `dataKey` and `nameKey` props are required to specify which properties to use for values and labels
- `ChartDonutCell` components should be used to customize individual segment colors
- `radius` prop only accepts 'small', 'medium', or 'large' values
- `type` prop only accepts 'circle' or 'semicircle' values
- `colorTheme` prop currently only supports 'categorical' value
- Center text positioning is automatically calculated based on radius size and presence of legend

## TypeScript Types

These are the props that the DonutChart component and its subcomponents accept:

```typescript
type ChartDonutProps = {
  /**
   * The data key of the Donut chart.
   */
  dataKey: RechartsPieProps['dataKey'];
  /**
   * The name key of the Donut chart.
   */
  nameKey: RechartsPieProps['name'];
  /**
   * The x coordinate of the Donut chart.
   */
  cx?: RechartsPieProps['cx'];
  cy?: RechartsPieProps['cy'];
  /**
   * The radius of the Donut chart.
   */
  radius?: ChartRadius;
  /**
   * The children of the Donut chart.
   */
  children?: React.ReactNode;
  /**
   * The data of the Donut chart.
   */
  data: data[];
  /**
   * The color theme of the chart.
   * @default 'categorical'
   */
  colorTheme?:  'categorical';;
  /**
   * The type of the Donut chart.
   */
  type?: 'circle' | 'semicircle';
};

type Content = {
  value?: string;
  label?: string;
};

type ChartDonutWrapperProps = {
  /**
   * Content to be displayed at center of donut chart
   */
  content?: Content | React.ReactNode;
  children?: React.ReactNode;
} & BoxProps;


 ChartDonutCellProps = CellProps & {
  color?: ChartsCategoricalColorToken | ChartSequentialColorToken;
};

type ChartRadius = 'small' | 'medium' | 'large';

type data = {
  [key: string]: unknown;
};

type colorTheme = 'categorical';

type ChartsCategoricalColorToken = `data.background.categorical.${ChartColorCategories}.${keyof ChartCategoricalEmphasis}`;

type ChartSequentialColorToken = `data.background.sequential.${Exclude<
  ChartColorCategories,
  'gray'
>}.${keyof ChartSequentialEmphasis}`;
```

## Example

### Basic Donut Chart with Custom Colors and Center Text

```tsx
import React from 'react';
import { 
  ChartDonut,
  ChartDonutWrapper,
  ChartDonutCell,
  ChartTooltip,
  ChartLegend,
} from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';

function DonutChartExample() {
  const chartData = [
    { name: 'Desktop', value: 400, percentage: 40 },
    { name: 'Mobile', value: 300, percentage: 30 },
    { name: 'Tablet', value: 200, percentage: 20 },
    { name: 'Other', value: 100, percentage: 10 },
  ];

  return (
    <Box display="flex" justifyContent="center" alignItems="center" width="100%" height="400px">
      <ChartDonutWrapper 
        content={{ value: '1000', label: 'Total Users' }} 
        width="500px" 
        height="400px"
        testID="donut-chart-wrapper"
      >
        <ChartDonut 
          dataKey="value" 
          nameKey="name" 
          data={chartData} 
          radius="medium"
          type="circle"
          colorTheme="categorical"
        >
          <ChartDonutCell color="data.background.categorical.blue.moderate" />
          <ChartDonutCell color="data.background.categorical.green.moderate" />
          <ChartDonutCell color="data.background.categorical.gold.moderate" />
          <ChartDonutCell color="data.background.categorical.purple.moderate" />
        </ChartDonut>
        <ChartTooltip />
        <ChartLegend />
      </ChartDonutWrapper>
    </Box>
  );
}

export default DonutChartExample;
```

---

## Drawer

## Component Name

Drawer

## Description

The Drawer component is a panel that slides in from the right side of the screen over existing content in the viewport. It helps in providing additional details or context and can also be used to promote product features. Drawers support stacking functionality, allowing up to two drawers to be open at once with a neat UI treatment showing the previous drawer peeking from behind.

## Important Constraints

- `Drawer` component only accepts `DrawerHeader`, `DrawerBody`, and `DrawerFooter` components as children

## TypeScript Types

The following types represent the props that the Drawer component and its subcomponents accept. These props allow consumers to configure the drawer behavior, appearance, and content.

```typescript
/**
 * Props for the Drawer component
 */
type DrawerProps = {
  /**
   * Controls the state of the drawer, indicating whether it is open or closed
   */
  isOpen: boolean;

  /**
   * Callback function triggered when the drawer is dismissed or closed.
   *
   * **Note**: onDismiss gets triggered immediately on close button click. Use onUnmount if you want to perform actions after the animations are complete
   */
  onDismiss: () => void;

  /**
   * Callback function triggered when the drawer is unmounted.
   *
   * Unlike onDismiss, this gets called after the animations are complete
   */
  onUnmount?: () => void;

  /**
   * Show or hide overlay.
   *
   * Also decides if clicking outside on overlay closes the drawer or not
   */
  showOverlay?: boolean;

  /**
   * children node.
   *
   * Supports DrawerHeader, DrawerBody, and DrawerFooter
   */
  children: React.ReactNode;

  /**
   * zIndex property of drawer
   *
   * @default 1001
   */
  zIndex?: number;

  /**
   * Accessibility label for the drawer
   */
  accessibilityLabel?: string;

  /**
   * Ref to the element that should receive focus when opening the drawer.
   */
  initialFocusRef?: React.MutableRefObject<any>;

  /**
   * If `true`, the DrawerBody will be rendered only when it becomes active.
   * Set to `false` to keep DrawerBody in DOM
   *
   * @default true
   */
  isLazy?: boolean;
} & DataAnalyticsAttribute &
  TestID;

/**
 * Props for the DrawerHeader component
 */
type DrawerHeaderProps = {
  /**
   * Title of the Drawer
   */
  title?: string;

  /**
   * Subtitle of the Drawer
   */
  subtitle?: string;

  /**
   * Leading element
   *
   * DrawerHeaderIcon or DrawerHeaderAsset
   */
  leading?: React.ReactNode;

  /**
   * Title suffix element
   *
   * DrawerHeaderBadge
   */
  titleSuffix?: React.ReactNode;

  /**
   * Trailing element
   *
   * Link, Button[]
   */
  trailing?: React.ReactNode;

  /**
   * Children elements to be rendered inside the header
   */
  children?: React.ReactElement | React.ReactElement[];

  /**
   * Background color of the header
   *
   * Use this for adding gradients
   */
  color?: FeedbackColors;

  /**
   * Whether to show the divider below the header
   * @default true
   */
  showDivider?: boolean;
} & DataAnalyticsAttribute;

/**
 * Props for the DrawerFooter component
 */
type DrawerFooterProps = {
  /**
   * Content of the footer
   */
  children: React.ReactNode;

  /**
   * Whether to show the divider above the footer
   * @default true
   */
  showDivider?: boolean;
} & DataAnalyticsAttribute;
```

## Example

### Basic Drawer

This example shows a basic drawer with standard header and body content. It demonstrates how to control the drawer's open state and handle dismissal.

```tsx
import React, { useState } from 'react';
import {
  Drawer,
  DrawerBody,
  DrawerHeader,
  DrawerFooter,
  Box,
  Button,
  Badge,
  TextInput,
  Heading,
  Text,
  DownloadIcon,
} from '@razorpay/blade/components';

const BasicDrawer = () => {
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  const [showFooter, setShowFooter] = useState(true);

  const handleOpenDrawer = () => setIsDrawerOpen(true);
  const handleCloseDrawer = () => setIsDrawerOpen(false);

  return (
    <Box>
      <Box display="flex" gap="spacing.4" marginBottom="spacing.4">
        <Button onClick={handleOpenDrawer}>Open Drawer</Button>
        <Button variant="secondary" onClick={() => setShowFooter(!showFooter)}>
          {showFooter ? 'Hide Footer' : 'Show Footer'}
        </Button>
      </Box>

      <Drawer
        isOpen={isDrawerOpen}
        onDismiss={handleCloseDrawer}
        accessibilityLabel="Vendor payment details drawer"
      >
        <DrawerHeader
          title="Vendor Payment Details"
          titleSuffix={<Badge color="positive">New</Badge>}
          subtitle="See your payment details here"
          trailing={<Button icon={DownloadIcon} accessibilityLabel="Download details" />}
        />
        <DrawerBody>
          <Box display="flex" alignItems="center">
            <Heading>Starters' CFP Private Limited</Heading>
            <Badge size="small" color="primary" marginLeft="spacing.3">
              Vendor
            </Badge>
          </Box>

          <Box marginTop="spacing.6" marginBottom="spacing.8">
            <TextInput
              label="Email"
              type="email"
              placeholder="Enter your email"
              accessibilityLabel="Email address input"
            />
            <TextInput
              marginTop="spacing.4"
              label="Phone Number"
              type="telephone"
              placeholder="Enter your phone number"
              accessibilityLabel="Phone number input"
            />
          </Box>

          <Box>
            <Button accessibilityLabel="Process payout">Payout</Button>
            <Button
              marginLeft="spacing.2"
              variant="tertiary"
              accessibilityLabel="Send invitation to vendor"
            >
              Invite Vendor
            </Button>
          </Box>
        </DrawerBody>

        {showFooter && (
          <DrawerFooter>
            <Box display="flex" gap="spacing.3">
              <Button
                variant="tertiary"
                isFullWidth
                onClick={handleCloseDrawer}
                accessibilityLabel="Cancel and close drawer"
              >
                Cancel
              </Button>
              <Button variant="primary" isFullWidth accessibilityLabel="Process payment for vendor">
                Process Payment
              </Button>
            </Box>
          </DrawerFooter>
        )}
      </Drawer>
    </Box>
  );
};

export default BasicDrawer;
```

### Drawer with Custom Header Content

This example demonstrates how to create a drawer with custom header content, including a colored background and rich content layout.

```tsx
import React, { useState } from 'react';
import {
  Drawer,
  DrawerBody,
  DrawerHeader,
  Box,
  Button,
  IconButton,
  Badge,
  TextInput,
  Heading,
  Text,
  Amount,
  CheckIcon,
  MoreHorizontalIcon,
  DownloadIcon,
} from '@razorpay/blade/components';

const CustomHeaderDrawer = () => {
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);

  return (
    <Box>
      <Button onClick={() => setIsDrawerOpen(true)}>Open Drawer</Button>

      <Drawer isOpen={isDrawerOpen} onDismiss={() => setIsDrawerOpen(false)}>
        <DrawerHeader
          color="positive"
          title="Settlements"
          trailing={
            <IconButton
              icon={MoreHorizontalIcon}
              accessibilityLabel="Options"
              onClick={() => console.log('Options Clicked')}
              size="large"
            />
          }
        >
          <Box marginTop="spacing.6" textAlign="center">
            <Amount
              value={26000}
              currency="INR"
              size="2xlarge"
              type="heading"
              weight="semibold"
              suffix="decimals"
            />
          </Box>

          <Box display="flex" justifyContent="center" gap="spacing.4" marginTop="spacing.4">
            <Badge icon={CheckIcon} size="medium" color="positive" emphasis="intense">
              Captured
            </Badge>
          </Box>

          <Box
            display="flex"
            alignItems="center"
            justifyContent="center"
            gap="spacing.2"
            marginTop="spacing.6"
            paddingX="spacing.4"
          >
            <Text size="large" textAlign="center">
              Payment was successfully captured. To be settled in your bank account by{' '}
              <Text as="span" size="large" weight="semibold" color="feedback.text.positive.intense">
                Jan 20, 2025
              </Text>
            </Text>
          </Box>

          <Box marginTop="spacing.4" textAlign="center">
            <Text size="small" weight="medium" color="surface.text.gray.muted">
              Created on Jan 11, 2025
            </Text>
          </Box>
        </DrawerHeader>

        <DrawerBody>
          <Box marginBottom="spacing.8">
            <Heading marginBottom="spacing.4">Transaction Details</Heading>
            <Text>
              This payment will be processed according to your settlement cycles. You can check the
              status of your settlements in the Settlements tab.
            </Text>
          </Box>

          <Button accessibilityLabel="View detailed settlement information">
            View All Settlements
          </Button>
        </DrawerBody>
      </Drawer>
    </Box>
  );
};

export default CustomHeaderDrawer;
```

---

## Dropdown

## Component Name

Dropdown

## Description

Dropdown is a versatile component that displays a floating overlay with content beneath a trigger element. It supports various trigger types (buttons, links, inputs) and content patterns including selection menus, filter chips, and autocomplete. Dropdown offers controlled and uncontrolled modes, with built-in positioning logic to ensure the overlay appears in the optimal location regardless of available space.

## Important Constraints

- `Dropdown` component only accepts specific trigger components and overlay components as children: `SelectInput`, `SearchInput`, `DropdownButton`, `DropdownIconButton`, `DropdownLink`, `DropdownOverlay`, `AutoComplete`, `BottomSheet`, `FilterChipSelectInput`, `InputDropdownButton`

## TypeScript Types

The following types represent the props that the Dropdown component and its subcomponents accept.

```typescript
/**
 * Props for the Dropdown component
 */
type DropdownProps = {
  /**
   * The type of selection the dropdown supports
   * @default 'single'
   */
  selectionType?: 'single' | 'multiple';

  /**
   * Children of the dropdown (typically a trigger and overlay)
   */
  children: React.ReactNode;

  /**
   * Controls whether the dropdown is open (controlled mode)
   */
  isOpen?: boolean;

  /**
   * Controls whether the dropdown is initially open (uncontrolled mode)
   */
  defaultIsOpen?: boolean;

  /**
   * Callback fired when the open state changes
   */
  onOpenChange?: (isOpen: boolean) => void;

  /**
   * If true, dropdown will close when clicking outside
   * @default true
   */
  shouldCloseOnClickOutside?: boolean;

  /**
   * If true, dropdown will close when pressing the escape key
   * @default true
   */
  shouldCloseOnEscape?: boolean;
} & StyledPropsBlade &
  TestID;

/**
 * Props for the DropdownOverlay component
 */
type DropdownOverlayProps = {
  /**
   * Children of the overlay
   */
  children: React.ReactNode;

  /**
   * Width of the overlay
   */
  width?: string | number;

  /**
   * Maximum width of the overlay
   */
  maxWidth?: string | number;

  /**
   * Maximum height of the overlay
   */
  maxHeight?: string | number;
} & StyledPropsBlade;

/**
 * Props for the DropdownButton component
 */
type DropdownButtonProps = {
  /**
   * Children of the button (typically text content)
   */
  children: React.ReactNode;

  /**
   * The variant of the button
   * @default 'primary'
   */
  variant?: 'primary' | 'secondary' | 'tertiary';

  /**
   * Size of the button
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * Whether the button is disabled
   * @default false
   */
  isDisabled?: boolean;
} & StyledPropsBlade;

/**
 * Props for the DropdownLink component
 */
type DropdownLinkProps = {
  /**
   * Children of the link (typically text content)
   */
  children: React.ReactNode;

  /**
   * Icon to display with the link
   */
  icon?: IconComponent;

  /**
   * Position of the icon
   * @default 'left'
   */
  iconPosition?: 'left' | 'right';

  /**
   * Whether the link is disabled
   * @default false
   */
  isDisabled?: boolean;
} & StyledPropsBlade;

/**
 * Props for the DropdownIconButton component
 */
type DropdownIconButtonProps = {
  /**
   * Icon to display in the button
   */
  icon: IconComponent;

  /**
   * Accessibility label for the button
   */
  accessibilityLabel: string;

  /**
   * Size of the icon button
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * Whether the button is disabled
   * @default false
   */
  isDisabled?: boolean;
} & StyledPropsBlade;

/**
 * Props for the DropdownHeader component
 */
type DropdownHeaderProps = {
  /**
   * Title of the header
   */
  title?: string;

  /**
   * Subtitle of the header
   */
  subtitle?: string;

  /**
   * Content to display at the start of the header
   */
  leading?: React.ReactNode;

  /**
   * Content to display at the end of the header
   */
  trailing?: React.ReactNode;

  /**
   * Content to display after the title
   */
  titleSuffix?: React.ReactNode;

  /**
   * Children of the header (typically for custom content)
   */
  children?: React.ReactNode;
} & StyledPropsBlade;

/**
 * Props for the DropdownFooter component
 */
type DropdownFooterProps = {
  /**
   * Children of the footer
   */
  children: React.ReactNode;
} & StyledPropsBlade;

/**
 * Props for the FilterChipSelectInput component
 */
type FilterChipSelectInputProps = {
  /**
   * Label text for the filter chip
   */
  label: string;

  /**
   * Current value(s) selected
   */
  value?: string | string[];

  /**
   * Callback when selection changes
   */
  onChange?: (value: string | string[]) => void;

  /**
   * Callback when clear button is clicked
   */
  onClearButtonClick?: (value: string | string[]) => void;

  /**
   * Whether the filter chip is disabled
   * @default false
   */
  isDisabled?: boolean;
} & StyledPropsBlade;

/**
 * Props for the FilterChipGroup component
 */
type FilterChipGroupProps = {
  /**
   * Children of the filter chip group (typically FilterChipSelectInput components)
   */
  children: React.ReactNode;
} & StyledPropsBlade;

/**
 * Type for the Icon component
 */
type IconComponent = React.ComponentType<any>;
```

## Examples

### Basic Dropdown with Button Trigger

This example shows a simple dropdown with a button trigger and action list items.

```tsx
import React, { useState } from 'react';
import {
  Dropdown,
  DropdownButton,
  DropdownOverlay,
  ActionList,
  ActionListItem,
  ActionListItemIcon,
  CheckIcon,
  ClockIcon,
  CloseIcon,
} from '@razorpay/blade/components';

const BasicDropdownExample = () => {
  const [status, setStatus] = useState<string | undefined>();

  return (
    <Dropdown>
      {/* Button trigger with dynamic text based on selection */}
      <DropdownButton variant="tertiary" size="medium">
        Status: {status || 'Select'}
      </DropdownButton>

      <DropdownOverlay width="240px">
        <ActionList>
          <ActionListItem
            onClick={({ name }) => setStatus(name)}
            leading={<ActionListItemIcon icon={CheckIcon} />}
            isSelected={status === 'approve'}
            title="Approve"
            value="approve"
          />

          <ActionListItem
            onClick={({ name }) => setStatus(name)}
            leading={<ActionListItemIcon icon={ClockIcon} />}
            isSelected={status === 'in-progress'}
            title="In Progress"
            value="in-progress"
          />

          <ActionListItem
            onClick={({ name }) => setStatus(name)}
            leading={<ActionListItemIcon icon={CloseIcon} />}
            isSelected={status === 'reject'}
            title="Reject"
            value="reject"
            intent="negative"
          />
        </ActionList>
      </DropdownOverlay>
    </Dropdown>
  );
};
```

### Dropdown with Select Input (Single and Multiple Selection)

This example demonstrates a form-style dropdown for selecting values, supporting both single and multiple selection modes.

```tsx
import React, { useState } from 'react';
import {
  Dropdown,
  DropdownOverlay,
  DropdownHeader,
  DropdownFooter,
  ActionList,
  ActionListItem,
  SelectInput,
  Button,
  Box,
  CheckIcon,
  ClockIcon,
  CloseIcon,
} from '@razorpay/blade/components';

const SelectDropdownExample = () => {
  // Single selection state
  const [singleValue, setSingleValue] = useState<string>('');

  // Multiple selection state
  const [multiValues, setMultiValues] = useState<string[]>([]);

  // Controlled open state for multiple selection dropdown
  const [isMultiOpen, setIsMultiOpen] = useState(false);

  return (
    <Box display="flex" flexDirection="column" gap="spacing.6">
      {/* Single Selection Dropdown */}
      <Dropdown>
        <SelectInput
          label="Select City"
          placeholder="Choose a city"
          value={singleValue}
          onChange={(args) => {
            if (args) {
              setSingleValue(args.values[0]);
            }
          }}
          helpText="Select your preferred city"
          size="medium"
        />
        <DropdownOverlay>
          <ActionList>
            <ActionListItem title="Mumbai" value="mumbai" />
            <ActionListItem title="Bangalore" value="bangalore" />
            <ActionListItem title="Delhi" value="delhi" />
            <ActionListItem title="Chennai" value="chennai" />
            <ActionListItem title="Hyderabad" value="hyderabad" />
          </ActionList>
        </DropdownOverlay>
      </Dropdown>

      {/* Multiple Selection Dropdown with Header and Footer */}
      <Dropdown selectionType="multiple" isOpen={isMultiOpen} onOpenChange={setIsMultiOpen}>
        <SelectInput
          label="Select Multiple Cities"
          placeholder="Choose cities"
          value={multiValues}
          onChange={(args) => {
            if (args) {
              setMultiValues(args.values);
            }
          }}
          maxRows="multiple" // Show multiple selected values as tags
          validationState={multiValues.length === 0 ? 'error' : 'none'}
          errorText="Please select at least one city"
          isRequired
        />

        <DropdownOverlay width="300px">
          <DropdownHeader title="Available Cities" subtitle="Select one or more" />

          <ActionList>
            <ActionListItem title="Mumbai" value="mumbai" />
            <ActionListItem title="Bangalore" value="bangalore" />
            <ActionListItem title="Delhi" value="delhi" />
            <ActionListItem title="Chennai" value="chennai" />
            <ActionListItem title="Hyderabad" value="hyderabad" />
          </ActionList>

          <DropdownFooter>
            <Box display="flex" justifyContent="space-between" width="100%">
              <Button variant="tertiary" size="small" onClick={() => setMultiValues([])}>
                Clear All
              </Button>
              <Button size="small" onClick={() => setIsMultiOpen(false)}>
                Apply
              </Button>
            </Box>
          </DropdownFooter>
        </DropdownOverlay>
      </Dropdown>
    </Box>
  );
};
```

### AutoComplete Dropdown

This example demonstrates the AutoComplete dropdown for searching and selecting options with filtering capabilities.

```tsx
import React, { useState } from 'react';
import {
  Dropdown,
  DropdownOverlay,
  DropdownHeader,
  ActionList,
  ActionListItem,
  AutoComplete,
  Box,
  CheckIcon,
  ClockIcon,
  CloseIcon,
  TextInput,
} from '@razorpay/blade/components';

const AutoCompleteDropdownExample = () => {
  const fruits = [
    'Apples',
    'Apricots',
    'Avocados',
    'Bananas',
    'Blueberries',
    'Cherries',
    'Cranberries',
    'Grapes',
    'Lemons',
    'Mangoes',
    'Oranges',
    'Peaches',
    'Pears',
    'Pineapples',
    'Strawberries',
  ];

  const [query, setQuery] = useState('');
  const [selectedFruits, setSelectedFruits] = useState<string[]>([]);

  // Filter fruits based on search query
  const filteredFruits = query
    ? fruits.filter((fruit) => fruit.toLowerCase().includes(query.toLowerCase()))
    : fruits;

  // Toggle selection of a fruit
  const toggleFruit = (fruit: string) => {
    if (selectedFruits.includes(fruit)) {
      setSelectedFruits(selectedFruits.filter((f) => f !== fruit));
    } else {
      setSelectedFruits([...selectedFruits, fruit]);
    }
  };

  return (
    <Box maxWidth="300px">
      <Dropdown selectionType="multiple">
        <AutoComplete
          label="Select Fruits"
          placeholder="Search fruits..."
          value={selectedFruits}
          onChange={(args) => {
            if (args) {
              setSelectedFruits(args.values);
            }
          }}
          maxRows="multiple"
          size="medium"
        />

        <DropdownOverlay>
          <DropdownHeader>
            <TextInput
              label="Search Fruits"
              value={query}
              onChange={({ value }) => setQuery(value)}
              autoFocus
            />
          </DropdownHeader>

          <ActionList>
            {filteredFruits.map((fruit) => (
              <ActionListItem
                key={fruit}
                title={fruit}
                value={fruit}
                isSelected={selectedFruits.includes(fruit)}
                onClick={() => toggleFruit(fruit)}
              />
            ))}

            {filteredFruits.length === 0 && (
              <Box padding="spacing.4" textAlign="center">
                No matching fruits found
              </Box>
            )}
          </ActionList>
        </DropdownOverlay>
      </Dropdown>
    </Box>
  );
};
```

---

## Elevate

## Component Name

Elevate

## Description

Elevate is a motion component that animates the CSS `box-shadow` property to highlight elements. It enables smooth visual elevation transitions through hover, focus, or programmatic control. Elevate is designed to enhance interactive feedback and visual hierarchy in block-level components like Cards and Boxes, providing subtle depth cues to improve user experience.

## TypeScript Types

The following types represent the props that the Elevate component accepts. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the Elevate component
 */
type ElevateProps = {
  /**
   * Content to be elevated
   */
  children: React.ReactNode;

  /**
   * Controls whether the element is in the highlighted state
   * @default false
   */
  isHighlighted?: boolean;

  /**
   * Events that trigger the motion animation
   * @default []
   */
  motionTriggers?: MotionTrigger[];
} & StyledPropsBlade &
  TestID;

/**
 * Motion triggers for animation components
 */
type MotionTrigger = 'hover' | 'focus' | 'press' | 'on-animate-interactions';
```

## Examples

### Multiple Triggers for Accessibility

This example shows how to use multiple triggers (hover and focus) to improve accessibility.

```tsx
import React from 'react';
import { Elevate, Card, CardBody, Heading, Text, Button } from '@razorpay/blade/components';

const AccessibleElevateExample = () => {
  return (
    <Elevate motionTriggers={['hover', 'focus']}>
      <Card width="300px" elevation="none">
        <CardBody>
          <Heading size="small" marginBottom="spacing.2">
            Multiple Triggers
          </Heading>
          <Text marginBottom="spacing.4">
            This card elevates on both hover and focus, improving accessibility. Try focusing the
            button below to see the elevation effect.
          </Text>
          <Button>Focus me</Button>
        </CardBody>
      </Card>
    </Elevate>
  );
};

export default AccessibleElevateExample;
```

### Controlled Elevation State

This example demonstrates how to control the elevation state programmatically using the `isHighlighted` prop.

```tsx
import React, { useState } from 'react';
import { Elevate, Card, CardBody, Box, Button, Heading, Text } from '@razorpay/blade/components';

const ControlledElevateExample = () => {
  const [isHighlighted, setIsHighlighted] = useState(false);

  return (
    <Box display="flex" flexDirection="column" gap="spacing.4">
      <Button onClick={() => setIsHighlighted(!isHighlighted)} variant="secondary">
        {isHighlighted ? 'Remove Elevation' : 'Add Elevation'}
      </Button>

      <Elevate isHighlighted={isHighlighted}>
        <Card width="300px" elevation="none">
          <CardBody>
            <Heading size="small" marginBottom="spacing.2">
              Controlled Elevation
            </Heading>
            <Text>
              This card's elevation is controlled programmatically through the isHighlighted prop.
              Click the button above to toggle the elevation.
            </Text>
          </CardBody>
        </Card>
      </Elevate>
    </Box>
  );
};

export default ControlledElevateExample;
```

### Coordinated Animation with AnimateInteractions

This example shows how to combine Elevate with other motion components for coordinated animations.

```tsx
import React from 'react';
import {
  Elevate,
  Card,
  CardBody,
  Box,
  Button,
  Heading,
  Text,
  AnimateInteractions,
  Move,
  ExternalLinkIcon,
} from '@razorpay/blade/components';

const CoordinatedAnimationExample = () => {
  return (
    <AnimateInteractions motionTriggers={['hover']}>
      <Box display="contents">
        <Elevate>
          <Card
            width="400px"
            padding="spacing.0"
            backgroundColor="surface.background.gray.moderate"
            elevation="none"
          >
            <CardBody>
              <Box padding="spacing.6">
                <Heading as="h2" weight="regular">
                  Payment Pages
                </Heading>
                <Heading marginY="spacing.4" size="large" as="h3">
                  Accept payments without coding on a custom branded store
                </Heading>
                <Text>
                  Hover over this card to see coordinated animations. While the card elevates, the
                  button container below moves into view - demonstrating how multiple motion
                  components can work together.
                </Text>
              </Box>

              <Move motionTriggers={['on-animate-interactions']}>
                <Box display="flex" gap="spacing.4" justifyContent="flex-end" padding="spacing.6">
                  <Button variant="secondary" icon={ExternalLinkIcon} iconPosition="right">
                    Know More
                  </Button>
                  <Button>Sign Up</Button>
                </Box>
              </Move>
            </CardBody>
          </Card>
        </Elevate>
      </Box>
    </AnimateInteractions>
  );
};

export default CoordinatedAnimationExample;
```

---

## EmptyState

# EmptyState

## Description

EmptyState component provides a consistent way to display empty states across applications with optional visual assets, titles, descriptions, and action elements. It offers different size variants with appropriate spacing and typography scaling, making it suitable for various contexts from small cards to full-page empty states. The component supports custom illustrations, images, icons, and flexible content layouts while maintaining design consistency and accessibility standards.

## TypeScript Types

These are the props that the EmptyState component accepts:

````typescript
export type EmptyStateProps = {
  /**
   * Asset slot for custom illustrations, images, or any visual element.
   * Supports PNGs, custom brand illustrations, SVGs, animated gifs, lottie components etc.
   *
   * @example
   * ```jsx
   * // Custom image
   * <EmptyState asset={<img src="/custom-illustration.png" alt="No data" />} />
   *
   * // Custom component
   * <EmptyState asset={<CustomIllustration />} />
   * ```
   */
  asset?: React.ReactNode;

  /**
   * Primary heading text for the empty state
   */
  title?: string;

  /**
   * Supporting description text providing context and guidance
   */
  description?: string;

  /**
   * Children content for actions, links, or any custom content.
   */
  children?: React.ReactNode;

  /**
   * Size variant affecting the overall scale of the component
   * @default medium
   */
  size?: EmptyStateSize;
} & TestID &
  StyledPropsBlade &
  DataAnalyticsAttribute;

export type EmptyStateSize = 'small' | 'medium' | 'large' | 'xlarge';
````

## Examples

### Complete EmptyState with Interactive Functionality

```tsx
import { useState } from 'react';
import { EmptyState } from '@razorpay/blade/components';
import { Button } from '@razorpay/blade/components';
import { Link } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';

const ErrorEmptyState = () => {
  const [isRetrying, setIsRetrying] = useState(false);

  const handleRetry = async () => {
    setIsRetrying(true);
    try {
      await new Promise((resolve) => setTimeout(resolve, 2000));
      window.location.reload();
    } finally {
      setIsRetrying(false);
    }
  };

  return (
    <EmptyState
      size="medium"
      asset={
        <img
          src="/network-error-illustration.png"
          alt="Failed to load data"
          width="90"
          height="90"
        />
      }
      title="Failed to load dashboard data"
      description="We couldn't retrieve your transaction data due to a network issue. Please check your connection and try again, or contact support if the problem persists."
      testID="dashboard-error-empty-state"
      data-analytics-section="dashboard"
      data-analytics-action="error-state-view"
    >
      <Box display="flex" flexDirection="column" gap="spacing.4" alignItems="center">
        <Box display="flex" flexDirection="row" gap="spacing.3">
          <Button onClick={handleRetry} isLoading={isRetrying}>
            Try Again
          </Button>
          <Button variant="secondary" onClick={() => window.history.back()}>
            Go Back
          </Button>
        </Box>
        <Link href="/support" size="small">
          Contact Support
        </Link>
      </Box>
    </EmptyState>
  );
};
```

### Simple EmptyState with Blade Icon

```tsx
import { EmptyState } from '@razorpay/blade/components';
import { Button } from '@razorpay/blade/components';
import { EcommerceIcon } from '@razorpay/blade/components';

const SimpleEmptyState = () => {
  return (
    <EmptyState
      size="xlarge"
      asset={<EcommerceIcon size="2xlarge" color="surface.icon.gray.muted" />}
      title="Your cart is empty"
      description="Browse our products and add items you'd like to purchase."
      testID="cart-empty-state"
      data-analytics-section="shopping-cart"
    >
      <Button size="large" onClick={() => console.log('Navigate to products')}>
        Start Shopping
      </Button>
    </EmptyState>
  );
};
```

---

## Fade

## Component Name

Fade

## Description

The Fade component is a motion preset that animates the opacity of its children, allowing them to smoothly appear or disappear. It provides seamless transitions that enhance the user experience by softening abrupt content changes. Fade can be triggered by various interactions such as mounting, visibility changes, or viewport entry, making it versatile for creating engaging interfaces.

## TypeScript Types

The following types represent the props that the Fade component accepts. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the Fade component
 */
type FadeProps = {
  /**
   * Content to be animated with fade effect
   */
  children: React.ReactNode;

  /**
   * Controls whether the element is visible (for controlled usage)
   */
  isVisible?: boolean;

  /**
   * Type of fade animation
   * @default 'inout'
   */
  type?: 'in' | 'out' | 'inout';

  /**
   * Events that trigger the motion animation
   * @default []
   */
  motionTriggers?: MotionTrigger[];

  /**
   * Whether to unmount the children when hidden
   * @default false
   */
  shouldUnmountWhenHidden?: boolean;
} & StyledPropsBlade &
  TestID;

/**
 * Motion triggers for animation components
 */
type MotionTrigger = 'hover' | 'focus' | 'press' | 'mount' | 'in-view' | 'on-animate-interactions';
```

## Examples

### Controlled Fade Animation

This example demonstrates the controlled usage of the Fade component with a toggle button to show/hide content.

```tsx
import React, { useState } from 'react';
import { Fade, Box, Button, Card, CardBody, Heading, Text } from '@razorpay/blade/components';

const ControlledFadeExample = () => {
  const [isVisible, setIsVisible] = useState(true);

  return (
    <Box
      backgroundColor="surface.background.gray.intense"
      padding="spacing.8"
      borderRadius="medium"
      minHeight="300px"
    >
      <Button marginBottom="spacing.4" onClick={() => setIsVisible(!isVisible)} variant="secondary">
        {isVisible ? 'Hide Content' : 'Show Content'}
      </Button>

      <Fade isVisible={isVisible} type="inout" shouldUnmountWhenHidden={false}>
        <Card>
          <CardBody>
            <Heading size="medium" marginBottom="spacing.3">
              Fade Animation Demo
            </Heading>
            <Text>
              This content fades in and out when the toggle button is clicked. The
              shouldUnmountWhenHidden prop is set to false, so the component remains in the DOM even
              when hidden.
            </Text>
          </CardBody>
        </Card>
      </Fade>
    </Box>
  );
};

export default ControlledFadeExample;
```

### Viewport-Triggered Fade Animation

This example shows how to trigger fade animations when elements enter the viewport, useful for creating scroll animations.

```tsx
import React from 'react';
import { Fade, Box, Card, CardBody, Heading, Text } from '@razorpay/blade/components';

const ViewportFadeExample = () => {
  return (
    <Box
      maxHeight="400px"
      overflow="auto"
      padding="spacing.6"
      backgroundColor="surface.background.gray.intense"
      borderRadius="medium"
    >
      {/* Spacer to enable scrolling */}
      <Box height="700px" display="flex" alignItems="center" justifyContent="center">
        <Text size="large" weight="semibold">
          Scroll down to see the fade effect
        </Text>
      </Box>

      {/* Content that fades in when scrolled into view */}
      <Fade motionTriggers={['in-view']} type="in">
        <Card>
          <CardBody>
            <Heading size="medium" marginBottom="spacing.3">
              Appears on Scroll
            </Heading>
            <Text>
              This card fades in when it enters the viewport as you scroll down. The 'in-view'
              motion trigger activates the animation when the element becomes visible in the
              viewport.
            </Text>
          </CardBody>
        </Card>
      </Fade>

      {/* Additional space after the content */}
      <Box height="200px" />
    </Box>
  );
};

export default ViewportFadeExample;
```

### Page Transition with Routing

This example demonstrates using Fade for smooth transitions between routes in a single-page application.

```tsx
import React from 'react';
import {
  Fade,
  Card,
  CardBody,
  CardHeader,
  CardHeaderLeading,
  Box,
  Text,
} from '@razorpay/blade/components';
import { Route, Switch, useLocation } from 'react-router-dom';

const PageTransitionExample = () => {
  // Access location object to trigger fade on route changes
  const location = useLocation();

  return (
    <Box padding="spacing.4">
      <Switch location={location}>
        <Route path="/dashboard">
          <Fade key="dashboard" motionTriggers={['mount']} type="in">
            <Card>
              <CardHeader>
                <CardHeaderLeading title="Dashboard" subtitle="View your account summary" />
              </CardHeader>
              <CardBody>
                <Text>
                  This is the dashboard page that fades in when navigated to. Each route uses a Fade
                  component to create a smooth transition effect.
                </Text>
              </CardBody>
            </Card>
          </Fade>
        </Route>

        <Route path="/profile">
          <Fade key="profile" motionTriggers={['mount']} type="in">
            <Card>
              <CardHeader>
                <CardHeaderLeading
                  title="User Profile"
                  subtitle="Manage your personal information"
                />
              </CardHeader>
              <CardBody>
                <Text>
                  This is the profile page that fades in when navigated to. Using a unique key with
                  the Fade component ensures the animation plays for each route change.
                </Text>
              </CardBody>
            </Card>
          </Fade>
        </Route>

        <Route path="/">
          <Fade key="home" motionTriggers={['mount']} type="in">
            <Card>
              <CardHeader>
                <CardHeaderLeading title="Home" subtitle="Welcome to the application" />
              </CardHeader>
              <CardBody>
                <Text>
                  This is the home page with a fade-in animation. The mount trigger ensures the
                  content fades in when the route loads.
                </Text>
              </CardBody>
            </Card>
          </Fade>
        </Route>
      </Switch>
    </Box>
  );
};

export default PageTransitionExample;
```

### Working with Refs

This example shows how to use the Fade component with refs to maintain functionality like auto-focusing elements that appear.

```tsx
import React, { useState, useRef, useEffect } from 'react';
import { Fade, Box, Button, TextInput } from '@razorpay/blade/components';

const FadeWithRefExample = () => {
  const [isVisible, setIsVisible] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  // Focus the input when it becomes visible
  useEffect(() => {
    if (isVisible && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isVisible]);

  return (
    <Box minHeight="200px" padding="spacing.6">
      <Button marginBottom="spacing.4" onClick={() => setIsVisible(!isVisible)}>
        {isVisible ? 'Hide Form' : 'Show Form'}
      </Button>

      <Fade isVisible={isVisible} type="inout" shouldUnmountWhenHidden={true}>
        <TextInput
          ref={inputRef}
          label="Email Address"
          placeholder="Enter your email"
          helpText="This input is auto-focused when it appears"
        />
      </Fade>
    </Box>
  );
};

export default FadeWithRefExample;
```

---

## FileUpload

## Component Name

FileUpload

## Description

The FileUpload component is used to handle file attachments, including drag-and-drop interactions. It supports both single and multiple file uploads, with built-in validation for file types, sizes, and counts. The component can operate in controlled or uncontrolled modes, making it versatile for various scenarios from simple form inputs to complex upload workflows with progress indicators and previews.

## Important Constraints

- Custom text props (`actionButtonText`, `dropAreaText`) and dimensions (`height`, `width`) can only be used when `size` is "variable"

Make sure to only follow structure as given in the examples below. Fragments are also not allowed as children in these components.

## TypeScript Types

The following types represent the props that the FileUpload component accepts. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the FileUpload component
 */
type FileUploadProps = {
  /**
   * The upload type - single or multiple files
   * @default 'single'
   */
  uploadType?: 'single' | 'multiple';

  /**
   * Label for the upload component
   */
  label?: string;

  /**
   * Additional help text below the component
   */
  helpText?: string;

  /**
   * Error text to display when validation fails
   */
  errorText?: string;

  /**
   * Success text to display after successful upload
   */
  successText?: string;

  /**
   * Accepted file types (e.g., '.jpg, .png, .pdf')
   */
  accept?: string;

  /**
   * Maximum number of files allowed
   */
  maxCount?: number;

  /**
   * Maximum size of each file in bytes
   */
  maxSize?: number;

  /**
   * List of files (for controlled component)
   */
  fileList?: BladeFileList;

  /**
   * Whether to disable the component
   * @default false
   */
  isDisabled?: boolean;

  /**
   * Whether the field is required
   * @default false
   */
  isRequired?: boolean;

  /**
   * Indicator for required/optional state
   * @default 'none'
   */
  necessityIndicator?: 'required' | 'optional' | 'none';

  /**
   * Callback when files are selected through the input or dropped
   */
  onChange?: (info: { fileList: BladeFileList }) => void;

  /**
   * Callback when files are dropped on the dropzone
   */
  onDrop?: (info: { fileList: BladeFileList }) => void;

  /**
   * Callback when the preview button is clicked
   */
  onPreview?: (info: { file: BladeFile }) => void;

  /**
   * Callback when the remove button is clicked
   */
  onRemove?: (info: { file: BladeFile; fileList: BladeFileList }) => void;

  /**
   * Callback when file upload is started
   */
  onUpload?: (info: { file: BladeFile; fileList: BladeFileList }) => void;

  /**
   * Validation state of the component
   * @default 'none'
   */
  validationState?: 'error' | 'success' | 'none';

  /**
   * Size variant of the component
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * Position of the label
   * @default 'top'
   */
  labelPosition?: 'top' | 'left';
} & StyledPropsBlade &
  TestID;

/**
 * File object for the FileUpload component
 */
type BladeFile = File & {
  /**
   * Unique identifier for the file
   */
  id: string;

  /**
   * Status of the file upload
   */
  status?: 'uploading' | 'success' | 'error';

  /**
   * Error text to display when upload fails
   */
  errorText?: string;

  /**
   * Upload progress percentage (0-100)
   */
  progress?: number;

  /**
   * Whether to show the file preview
   */
  showPreview?: boolean;

  /**
   * URL for file preview (if available)
   */
  previewUrl?: string;
};

/**
 * List of BladeFile objects
 */
type BladeFileList = BladeFile[];
```

## Examples

### Single File Upload with Form

A basic example of single file upload integrated in a form with validation.

```tsx
import React, { useState } from 'react';
import { FileUpload, TextInput, Button, Box } from '@razorpay/blade/components';

const SingleFileUploadExample = () => {
  const [name, setName] = useState('');
  const [fileList, setFileList] = useState([]);
  const [validationState, setValidationState] = useState<'none' | 'error'>('none');

  const handleFileChange = ({ fileList }) => {
    setFileList(fileList);

    // Simple validation based on whether files are selected
    if (fileList.length > 0) {
      setValidationState('none');
    } else {
      setValidationState('none');
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(`Form submitted: Name: ${name}, File: ${fileList[0]?.name || 'None'}`);
  };

  return (
    <Box padding="spacing.4">
      <form onSubmit={handleSubmit}>
        <TextInput
          label="Name"
          value={name}
          onChange={({ value }) => setName(value)}
          marginBottom="spacing.3"
          isRequired
        />

        <FileUpload
          uploadType="single"
          label="Profile Image"
          helpText="Upload a profile picture (JPEG or PNG, max 2MB)"
          accept=".jpg,.jpeg,.png"
          maxSize={2 * 1024 * 1024}
          isRequired
          validationState={validationState}
          errorText="Please upload a valid image file"
          fileList={fileList}
          onChange={handleFileChange}
          onRemove={() => {
            setFileList([]);
            setValidationState('none');
          }}
          marginBottom="spacing.3"
        />

        <Button type="submit" isDisabled={!name || fileList.length === 0}>
          Submit
        </Button>
      </form>
    </Box>
  );
};

export default SingleFileUploadExample;
```

### Multiple File Upload

An example showing how to use the multiple file upload functionality with progress indicators.

```tsx
import React, { useState } from 'react';
import { FileUpload, Box } from '@razorpay/blade/components';
import type { BladeFile, BladeFileList } from '@razorpay/blade/components';

const MultipleFileUploadExample = () => {
  const [fileList, setFileList] = useState<BladeFileList>([]);

  // Simulate file upload with progress
  const simulateUpload = (file: BladeFile) => {
    // Set initial uploading state
    setFileList((prevList) =>
      prevList.map((f) => (f.id === file.id ? { ...f, status: 'uploading', progress: 0 } : f)),
    );

    // Simulate progress with intervals
    let progress = 0;
    const interval = setInterval(() => {
      progress += 10;

      if (progress <= 100) {
        // Update progress
        setFileList((prevList) => prevList.map((f) => (f.id === file.id ? { ...f, progress } : f)));
      } else {
        // Complete the upload
        clearInterval(interval);
        setFileList((prevList) =>
          prevList.map((f) => (f.id === file.id ? { ...f, status: 'success' } : f)),
        );
      }
    }, 500);
  };

  const handleFileChange = ({ fileList: newFileList }) => {
    // Find files that need to be uploaded (no status)
    const filesToUpload = newFileList.filter((file) => !file.status);

    // Update file list first
    setFileList(newFileList);

    // Start simulated upload for new files
    filesToUpload.forEach(simulateUpload);
  };

  return (
    <Box padding="spacing.4">
      <FileUpload
        uploadType="multiple"
        label="Document Upload"
        helpText="Upload up to 3 documents (PDF or DOC, max 5MB each)"
        accept=".pdf,.doc,.docx"
        maxCount={3}
        maxSize={5 * 1024 * 1024}
        fileList={fileList}
        onChange={handleFileChange}
        onRemove={({ file: removedFile }) =>
          setFileList(fileList.filter((file) => removedFile.name !== file.name))
        }
        size="medium"
      />
    </Box>
  );
};

export default MultipleFileUploadExample;
```

---

## Heading

## Component Name

Heading

## Description

The Heading component is designed for creating section headings in a page's hierarchy. It automatically maps different sizes to appropriate HTML heading tags (h1-h6) while maintaining consistent styling. The component supports various sizes, weights, and customization options, making it ideal for creating clear visual hierarchies in your content structure. It's built with accessibility in mind, automatically applying the correct semantic heading tags based on the size prop.

## TypeScript Types

The following types define the props that the Heading component accepts. These types help you understand what properties you can pass to customize the Heading component's appearance and behavior.

```typescript
type HeadingProps = {
  as?: 'span' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
  /**
   * Overrides the color of the Heading component.
   *
   * **Note** This takes priority over `type` and `contrast` prop to decide color of heading
   */
  color?: string;
  weight?: 'regular' | 'semibold';
  children: React.ReactNode;
  textAlign?: string;
  textDecorationLine?: string;
  size?: 'small' | 'medium' | 'large' | 'xlarge' | '2xlarge';
} & TestID &
  StyledPropsBlade;
```

## Example

Here's a comprehensive example showcasing the Heading component's various features and props, demonstrating different sizes, colors, weights, and semantic variations to create page hierarchy:

```tsx
import { Heading, Box, Text } from '@razorpay/blade/components';

function HeadingExample() {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.6">
      {/* Main page heading with largest size */}
      <Heading size="2xlarge" color="surface.text.primary.normal" textAlign="center">
        Welcome to Our Platform
      </Heading>

      {/* Section heading with custom color and weight */}
      <Heading size="xlarge" weight="regular" color="surface.text.primary.normal">
        Features Overview
      </Heading>

      {/* Subsection heading with mixed styles */}
      <Heading size="large">
        Discover our{' '}
        <Heading as="span" size="large" color="feedback.text.information.intense">
          Premium
        </Heading>{' '}
        Solutions
      </Heading>

      {/* Semantic override with as prop */}
      <Heading as="h2" size="medium" weight="semibold" textAlign="left">
        Getting Started Guide
      </Heading>

      {/* Small heading with decoration */}
      <Heading size="small" textDecorationLine="underline" color="surface.text.gray.normal">
        Important Notes
      </Heading>

      {/* Heading with superscript */}
      <Box display="flex" alignItems="flex-start">
        <Heading size="medium">
          Special Offer
          <Heading as="span" size="small" color="feedback.text.positive.intense">
            *
          </Heading>
        </Heading>
      </Box>
    </Box>
  );
}

export default HeadingExample;
```

---

## IconButton

## Component Name

IconButton

## Description

The IconButton component provides an accessible way to trigger actions using only icons. It is designed for interfaces where space is limited or when a visual-only control is preferred, such as close buttons for modals, action buttons in cards, or compact toolbar controls. IconButton maintains proper accessibility with required labels while offering various visual styles.

## Important Constraints

- `size="large"` is not allowed with `isHighlighted={true}`

## TypeScript Types

The following types represent the props that the IconButton component accepts. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the IconButton component
 */
type IconButtonProps = {
  /**
   * The icon to display
   * Accepts an icon component from Blade
   */
  icon: IconComponent;

  /**
   * Size of the IconButton
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * Visual emphasis of the IconButton
   * @default 'intense'
   */
  emphasis?: 'intense' | 'subtle';

  /**
   * Whether the IconButton is disabled
   * @default false
   */
  isDisabled?: boolean;

  /**
   * Accessible label for the IconButton
   * Required for accessibility
   */
  accessibilityLabel: string;

  /**
   * Function called when the IconButton is clicked
   */
  onClick?: React.MouseEventHandler<HTMLButtonElement>;
} & StyledPropsBlade &
  DataAnalyticsAttribute;

/**
 * Type for icon components
 */
type IconComponent = React.ComponentType<{
  size?: 'small' | 'medium' | 'large';
  color?: string;
}>;
```

## Examples

### Basic IconButton Usage

This example demonstrates the basic usage of the IconButton component with different variations of size, emphasis, and state.

```tsx
import React from 'react';
import { IconButton, Box, Text, CloseIcon, EditIcon, InfoIcon } from '@razorpay/blade/components';

const IconButtonBasicExample = () => {
  return (
    <Box padding="spacing.5">
      <Box
        backgroundColor="surface.background.gray.subtle"
        padding="spacing.4"
        borderRadius="medium"
      >
        <Box display="flex" gap="spacing.4">
          {/* Default */}
          <IconButton
            icon={CloseIcon}
            accessibilityLabel="Close dialog"
            onClick={() => console.log('Close clicked')}
          />

          {/* With size and emphasis */}
          <IconButton
            icon={EditIcon}
            size="small"
            emphasis="subtle"
            accessibilityLabel="Edit item"
            onClick={() => console.log('Edit clicked')}
          />

          {/* Disabled state */}
          <IconButton
            icon={InfoIcon}
            isDisabled
            accessibilityLabel="Information"
            onClick={() => console.log('Info clicked')}
            data-analytics="info-click"
          />
        </Box>
      </Box>
    </Box>
  );
};

export default IconButtonBasicExample;
```

---

## Icons

## Component Name

Icons

## Description

Blade provides a collection of pre-designed icons that can be used throughout your application. Icons are available in 6 different sizes and can be customized with various colors to match your design requirements. They are primarily designed to be used within other components like Button or Badge, but can also be used standalone when needed.

## TypeScript Types

The following types represent the props that the Icon components accept. These allow you to properly configure the icons according to your needs.

```typescript
/**
 * Props for all Icon components
 */
type IconProps = {
  /**
   * The color of the icon
   * @default 'surface.icon.gray.normal'
   */
  color?: string;

  /**
   * The size of the icon
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large' | 'xlarge' | '2xlarge';
} & StyledPropsBlade &
  TestID;
```

## Examples

### Icon Usage

This example demonstrates comprehensive icon usage with all core props and integration with other components.

```tsx
import React from 'react';
import {
  Box,
  Heading,
  Text,
  Button,
  Badge,
  TextInput,
  ArrowRightIcon,
  CheckCircleIcon,
  CloseIcon,
  InfoIcon,
  AlertTriangleIcon,
  PlusIcon,
  CreditCardIcon,
  SearchIcon,
  DownloadIcon,
  UserIcon,
} from '@razorpay/blade/components';

const IconsExample = () => {
  return (
    <Box padding="spacing.4" display="flex" flexDirection="column" gap="spacing.6">
      {/* Different sizes with semantic colors */}
      <ArrowRightIcon size="small" color="surface.icon.primary.normal" />
      <CheckCircleIcon size="medium" color="feedback.icon.positive.subtle" />
      <CloseIcon size="large" color="feedback.icon.negative.intense" />
      <AlertTriangleIcon size="2xlarge" color="surface.icon.gray.subtle" />
    </Box>
  );
};

export default IconsExample;
```

---

## Indicator

## Component Name

Indicator

## Description

Indicators are visual elements that describe the condition of an entity. They are used to convey semantic meaning, such as statuses and semantical categories. Indicators can appear with or without text labels and in different emphasis levels (subtle or intense). They provide visual feedback to users through color-coded dot indicators and can be combined with other components through absolute positioning.

## TypeScript Types

The following types define the props that the Indicator component accepts. These types should be used when implementing the Indicator component in your application.

```typescript
type IndicatorProps = {
  /**
   * Sets the color tone
   *
   * @default neutral
   */
  color?: FeedbackColors | 'primary';

  /**
   * Sets the emphasis of the indicator
   *
   * If set to intense it will show a background circle
   *
   * @default subtle
   */
  emphasis?: 'subtle' | 'intense';

  /**
   * Size of the indicator
   *
   * @default medium
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * A text label to show alongside the indicator dot
   */
  children?: StringChildrenType;

  /**
   * a11y label for screen readers
   */
  accessibilityLabel?: string;
} & TestID &
  DataAnalyticsAttribute &
  StyledPropsBlade;
```

Where:

- `FeedbackColors` is a union type of possible feedback colors
- `StringChildrenType` represents text content that can be passed as children
- `TestID` provides test identifiers for testing frameworks
- `DataAnalyticsAttribute` adds data attributes for analytics tracking
- `StyledPropsBlade` includes styled-system props for flexible styling

## Example

This example demonstrates different variations of the Indicator component showing positive, negative, and notice states with different emphasis levels and text options.

```tsx
import { Indicator, Box } from '@razorpay/blade/components';

function IndicatorExample() {
  return (
    <Box display="flex" flexDirection="row" gap="spacing.4" alignItems="center">
      {/* Basic usage with text */}
      <Indicator accessibilityLabel="Status positive" color="positive" size="medium">
        Success
      </Indicator>

      {/* Without text */}
      <Indicator accessibilityLabel="Status negative" color="negative" />

      {/* With intense emphasis */}
      <Indicator accessibilityLabel="Status notice" color="notice" emphasis="intense" />
    </Box>
  );
}
```

---

## InfoGroup

# InfoGroup

## Description

InfoGroup is a structured component for displaying key-value pairs in a consistent, organized format. It provides a standardized way to present information such as transaction details, user data, or any related data pairs with proper visual hierarchy and alignment. The component supports both horizontal and vertical orientations, customizable alignment options, interactive elements, and responsive grid layouts for optimal data presentation across different use cases.

## TypeScript Types

These types define the props that InfoGroup component and its subcomponents accept. Use these to understand the available configuration options when implementing InfoGroup in your application.

```typescript
import type { IconComponent } from '@razorpay/blade/components';
import type { StringChildrenType, TestID } from '@razorpay/blade/utils';
import type { StyledPropsBlade } from '@razorpay/blade/components';
import type { BoxProps } from '@razorpay/blade/components';

export type InfoGroupProps = {
  /**
   * Defines how Key and Value are arranged â€” side by side or stacked
   * @default 'horizontal'
   */
  itemOrientation?: 'horizontal' | 'vertical';

  /**
   * Shows the size of the component
   * @default 'medium'
   */
  size?: 'xsmall' | 'small' | 'medium' | 'large';

  /**
   * Defines the alignment of the value content
   * @default 'left'
   */
  valueAlign?: 'left' | 'right';

  /**
   * Controls whether vertical dividers are rendered
   * @default false
   */
  isHighlighted?: boolean;

  /**
   * Custom grid template columns for the InfoGroup layout
   *
   * @default 'max-content 1fr' for horizontal itemOrientation
   * @default 'repeat(min(4, ${React.Children.count(children)}), 1fr)' for vertical itemOrientation
   */
  gridTemplateColumns?: BoxProps['gridAutoColumns'];

  /**
   * Children should be InfoItem components
   */
  children: React.ReactNode;
} & TestID &
  StyledPropsBlade &
  Pick<
    BoxProps,
    | 'width'
    | 'maxWidth'
    | 'minWidth'
    | 'paddingLeft'
    | 'paddingRight'
    | 'paddingTop'
    | 'paddingBottom'
    | 'padding'
    | 'paddingX'
    | 'paddingY'
  >;

export type InfoItemProps = {
  /**
   * Content should be InfoItemKey and InfoItemValue components
   */
  children: React.ReactNode;

  /**
   * Controls whether vertical dividers are rendered for this item
   * @default false
   */
  isHighlighted?: boolean;
} & TestID;

type TitlePeripheralProps = {
  /**
   * Leading element - can be icon component, avatar, or any React element
   */
  leading?: IconComponent | React.ReactElement;

  /**
   * Trailing element - can be icon component, avatar, or any React element
   */
  trailing?: IconComponent | React.ReactElement;

  /**
   * Additional help text to provide context
   */
  helpText?: string;

  /**
   * Truncates text after specified number of lines
   * @default undefined
   */
  truncateAfterLines?: number;
};

export type InfoItemKeyProps = {
  /**
   * Content of the key.
   */
  children?: StringChildrenType;
} & TitlePeripheralProps &
  TestID;

export type InfoItemValueProps = {
  /**
   * Content of the value - text string, components, or other ReactNode
   */
  children?: React.ReactNode;
} & TitlePeripheralProps &
  TestID;

type TestID = {
  /**
   * Test id that can be used to select element in testing environments
   *
   * Checkout https://testing-library.com/docs/queries/bytestid/
   */
  testID?: string;
};

type StringChildrenType = React.ReactText | React.ReactText[];
```

## Examples

### Basic InfoGroup with Horizontal Layout

This example demonstrates the most common usage of InfoGroup with horizontal layout where keys and values are displayed side by side.

Use this layout for displaying detailed information in forms, dashboards, or detail views.

```tsx
import {
  InfoGroup,
  InfoItem,
  InfoItemKey,
  InfoItemValue,
  Amount,
} from '@razorpay/blade/components';

function BasicInfoGroup() {
  return (
    <InfoGroup itemOrientation="horizontal" size="medium" valueAlign="left" maxWidth="600px">
      <InfoItem>
        <InfoItemKey>Account Holder</InfoItemKey>
        <InfoItemValue>Saurabh Daware</InfoItemValue>
      </InfoItem>
      <InfoItem>
        <InfoItemKey>Payment Method</InfoItemKey>
        <InfoItemValue>Credit Card</InfoItemValue>
      </InfoItem>
      <InfoItem>
        <InfoItemKey>Transaction Amount</InfoItemKey>
        <InfoItemValue>
          <Amount weight="semibold" color="surface.text.gray.subtle" value={123456} size="medium" />
        </InfoItemValue>
      </InfoItem>
      <InfoItem>
        <InfoItemKey>Transaction Date</InfoItemKey>
        <InfoItemValue>Dec 15, 2023</InfoItemValue>
      </InfoItem>
      <InfoItem>
        <InfoItemKey>Status</InfoItemKey>
        <InfoItemValue>Completed</InfoItemValue>
      </InfoItem>
    </InfoGroup>
  );
}
```

### Vertical Layout with Grid Configuration

This example shows how to use InfoGroup in vertical orientation. With key and value stacked vertically.

```tsx
import {
  InfoGroup,
  InfoItem,
  InfoItemKey,
  InfoItemValue,
  Amount,
  UserIcon,
  BankIcon,
  CheckIcon,
} from '@razorpay/blade/components';

function VerticalInfoGroup() {
  return (
    <InfoGroup
      // adds item in vertical orientation. key and value will be stacked vertically
      itemOrientation="vertical"
      size="medium"
      isHighlighted={true}
      // places items in 3 columns
      gridTemplateColumns="repeat(3, 1fr)"
      maxWidth="900px"
    >
      <InfoItem>
        <InfoItemKey leading={UserIcon}>Account Holder</InfoItemKey>
        <InfoItemValue>Saurabh Daware</InfoItemValue>
      </InfoItem>

      <InfoItem>
        <InfoItemKey leading={BankIcon}>Payment ID</InfoItemKey>
        <InfoItemValue>pay_MK7DGqwYXEwx9Q</InfoItemValue>
      </InfoItem>

      <InfoItem>
        <InfoItemKey leading={BankIcon}>Transaction Amount</InfoItemKey>
        <InfoItemValue>
          <Amount weight="semibold" color="surface.text.gray.subtle" value={575025} size="medium" />
        </InfoItemValue>
      </InfoItem>

      <InfoItem>
        <InfoItemKey leading={UserIcon}>Customer Email</InfoItemKey>
        <InfoItemValue>saurabh.daware@example.com</InfoItemValue>
      </InfoItem>

      <InfoItem>
        <InfoItemKey leading={CheckIcon}>Payment Status</InfoItemKey>
        <InfoItemValue trailing={CheckIcon}>Authorized</InfoItemValue>
      </InfoItem>

      <InfoItem>
        <InfoItemKey leading={BankIcon}>Settlement Date</InfoItemKey>
        <InfoItemValue>Dec 16, 2023</InfoItemValue>
      </InfoItem>
    </InfoGroup>
  );
}
```

---

## InputGroup

# InputGroup

## Description

InputGroup is a form layout component that organizes related form inputs with consistent spacing and alignment. It provides a structured way to group multiple input fields together with optional labels, help text, and validation states. The component supports responsive layouts and can handle complex form structures with multiple rows and column distributions. InputGroup automatically manages the context for child inputs, ensuring consistent sizing and disabled states across all grouped inputs.

## TypeScript Types

Below are the props that the InputGroup component and its subcomponents accept:

```typescript
import type { DataAnalyticsAttribute } from '~utils/types';
import type { StyledPropsBlade } from '~components/Box/styledProps';
import type { BaseInputProps } from '~components/Input/BaseInput/BaseInput';
import type { MotionMetaProp } from '~components/BaseMotion';

/**
 * Props for the InputGroup component.
 */
type InputGroupProps = {
  /**
   * Label for the entire input group.
   */
  label?: string;
  /**
   * Position of the label relative to the group.
   *
   * @default 'top'
   */
  labelPosition?: BaseInputProps['labelPosition'];
  /**
   * Controls the size of the input group and its child inputs.
   *
   * @default 'medium'
   */
  size?: BaseInputProps['size'];
  /**
   * Help text displayed at the bottom of the group.
   */
  helpText?: string;
  /**
   * Error message that appears when validationState is 'error'.
   */
  errorText?: string;
  /**
   * Success message that appears when validationState is 'success'.
   */
  successText?: string;
  /**
   * Current validation state of the input group.
   *
   * @default 'none'
   */
  validationState?: BaseInputProps['validationState'];
  /**
   * Disables all inputs within the group.
   *
   * @default false
   */
  isDisabled?: boolean;
  /**
   * Should be InputRow components or other valid inputs.
   */
  children: React.ReactNode;
  /**
   * Test ID for automation
   */
  testID?: string;
} & DataAnalyticsAttribute &
  StyledPropsBlade &
  MotionMetaProp;

/**
 * Props for the InputRow component.
 */
type InputRowProps = {
  /**
   * CSS grid template columns value (e.g., "1fr 2fr" or "200px 1fr").
   * Controls how space is distributed between child inputs.
   */
  gridTemplateColumns?: string;
  /**
   * Input components to render in this row.
   */
  children: React.ReactNode;
  /**
   * Test ID for automation
   */
  testID?: string;
};

type InputGroupContextType = {
  isInsideInputGroup: boolean;
  isDisabled?: BaseInputProps['isDisabled'];
  size?: BaseInputProps['size'];
};
```

## Examples

### Payment Form with Validation

Create a payment information form with format validation, different input types, and error handling.

```tsx
import { InputGroup, InputRow } from '@razorpay/blade/components/InputGroup';
import { TextInput } from '@razorpay/blade/components/Input/TextInput';
import { PasswordInput } from '@razorpay/blade/components/Input/PasswordInput';
import { Button } from '@razorpay/blade/components/Button';
import { Box } from '@razorpay/blade/components/Box';
import { useState } from 'react';

function PaymentForm() {
  const [formData, setFormData] = useState({
    cardNumber: '',
    expiryDate: '',
    cvv: '',
    cardholderName: '',
  });

  const handleInputChange = (field, value) => {
    setFormData((prev) => ({ ...prev, [field]: value || '' }));
  };

  const isFieldEmpty = (field) => !formData[field] || formData[field].trim() === '';
  const hasErrors = Object.values(formData).some((value) => !value || value.trim() === '');

  return (
    <Box>
      <InputGroup
        label="Payment Information"
        helpText="Enter your card details to process payment"
        size="large"
        labelPosition="top"
        validationState={hasErrors ? 'error' : 'success'}
        errorText={hasErrors ? 'Please fill in all required fields' : ''}
        successText={!hasErrors ? 'All fields completed' : ''}
        testID="payment-form"
      >
        <InputRow gridTemplateColumns="1fr">
          <TextInput
            label="Card Number"
            placeholder="1234 5678 9012 3456"
            value={formData.cardNumber}
            format="#### #### #### ####"
            onChange={({ value }) => handleInputChange('cardNumber', value)}
            validationState={isFieldEmpty('cardNumber') ? 'error' : 'success'}
            errorText={isFieldEmpty('cardNumber') ? 'Card number is required' : ''}
            accessibilityLabel="Enter your credit card number"
          />
        </InputRow>
        <InputRow gridTemplateColumns="1fr 1fr">
          <TextInput
            label="Expiry Date"
            placeholder="MM/YY"
            value={formData.expiryDate}
            format="##/##"
            onChange={({ value }) => handleInputChange('expiryDate', value)}
            validationState={isFieldEmpty('expiryDate') ? 'error' : 'success'}
            errorText={isFieldEmpty('expiryDate') ? 'Expiry date is required' : ''}
            accessibilityLabel="Enter card expiry date"
          />
          <PasswordInput
            label="CVV"
            placeholder="123"
            value={formData.cvv}
            maxCharacters={3}
            onChange={({ value }) => handleInputChange('cvv', value)}
            validationState={isFieldEmpty('cvv') ? 'error' : 'success'}
            errorText={isFieldEmpty('cvv') ? 'CVV is required' : ''}
            accessibilityLabel="Enter card CVV"
          />
        </InputRow>
        <InputRow gridTemplateColumns="1fr">
          <TextInput
            label="Cardholder Name"
            placeholder="John Doe"
            value={formData.cardholderName}
            onChange={({ value }) => handleInputChange('cardholderName', value)}
            validationState={isFieldEmpty('cardholderName') ? 'error' : 'success'}
            errorText={isFieldEmpty('cardholderName') ? 'Cardholder name is required' : ''}
            accessibilityLabel="Enter cardholder name"
          />
        </InputRow>
      </InputGroup>
      <Box display="flex" justifyContent="flex-end" marginTop="spacing.4">
        <Button variant="primary" isDisabled={hasErrors}>
          Submit Payment
        </Button>
      </Box>
    </Box>
  );
}
```

### Business Onboarding Form with Responsive Layout

Create a comprehensive business onboarding form with conditional layouts that adapt to different screen sizes.

```tsx
import { InputGroup, InputRow } from '@razorpay/blade/components/InputGroup';
import { TextInput } from '@razorpay/blade/components/Input/TextInput';
import { SelectInput } from '@razorpay/blade/components/Input/DropdownInputTriggers';
import { Dropdown, DropdownOverlay } from '@razorpay/blade/components/Dropdown';
import { ActionList, ActionListItem } from '@razorpay/blade/components/ActionList';
import { Button } from '@razorpay/blade/components/Button';
import { Box } from '@razorpay/blade/components/Box';
import { useIsMobile } from '@razorpay/blade/utils/useIsMobile';

function BusinessOnboardingForm() {
  const isMobile = useIsMobile();

  return (
    <Box>
      <InputGroup
        label="Merchant Onboarding"
        helpText="Complete your business details to start accepting payments"
        size="medium"
        labelPosition="left"
        validationState="none"
        testID="business-onboarding"
      >
        {isMobile ? (
          <>
            <InputRow gridTemplateColumns="1fr">
              <TextInput
                placeholder="Business Name"
                label="Business Name"
                accessibilityLabel="Enter your business name"
              />
            </InputRow>
            <InputRow gridTemplateColumns="1fr">
              <TextInput
                placeholder="Trading Name"
                label="Trading Name"
                accessibilityLabel="Enter your trading name"
              />
            </InputRow>
          </>
        ) : (
          <InputRow gridTemplateColumns="1fr 1fr">
            <TextInput
              placeholder="Business Name"
              label="Business Name"
              accessibilityLabel="Enter your business name"
            />
            <TextInput
              placeholder="Trading Name"
              label="Trading Name"
              accessibilityLabel="Enter your trading name"
            />
          </InputRow>
        )}
        <InputRow gridTemplateColumns="1fr">
          <TextInput
            placeholder="Business Email"
            label="Business Email"
            accessibilityLabel="Enter your business email address"
          />
        </InputRow>
        {isMobile ? (
          <>
            <InputRow gridTemplateColumns="1fr">
              <TextInput
                placeholder="PAN Number"
                label="Business PAN"
                accessibilityLabel="Enter business PAN number"
              />
            </InputRow>
            <InputRow gridTemplateColumns="1fr">
              <TextInput
                placeholder="GST Number"
                label="GSTIN"
                accessibilityLabel="Enter GST identification number"
              />
            </InputRow>
          </>
        ) : (
          <InputRow gridTemplateColumns="1fr 1fr">
            <TextInput
              placeholder="PAN Number"
              label="Business PAN"
              accessibilityLabel="Enter business PAN number"
            />
            <TextInput
              placeholder="GST Number"
              label="GSTIN"
              accessibilityLabel="Enter GST identification number"
            />
          </InputRow>
        )}
        <InputRow gridTemplateColumns="1fr">
          <Dropdown selectionType="single">
            <SelectInput
              label="Business Category"
              placeholder="Select Business Category"
              name="businessCategory"
              onChange={({ name, values }) => console.log({ name, values })}
              accessibilityLabel="Select your business category"
            />
            <DropdownOverlay>
              <ActionList>
                <ActionListItem title="E-commerce" value="ecommerce" />
                <ActionListItem title="Education" value="education" />
                <ActionListItem title="Healthcare" value="healthcare" />
                <ActionListItem title="Food & Beverage" value="food_beverage" />
                <ActionListItem title="Financial Services" value="financial" />
                <ActionListItem title="Others" value="others" />
              </ActionList>
            </DropdownOverlay>
          </Dropdown>
        </InputRow>
      </InputGroup>
      <Box display="flex" justifyContent="flex-end" marginTop="spacing.4">
        <Button variant="primary">Start Onboarding</Button>
      </Box>
    </Box>
  );
}
```

---

## LineChart

## Component Name

LineChart

## Description

LineChart is a data visualization component built on top of Recharts with Blade design system styling that renders line charts for displaying trends and patterns in continuous data over time. It consists of ChartLineWrapper as the main container and ChartLine components for individual data series, along with supporting chart components like axes, grids, tooltips, and legends. The component supports multiple line series, various line styles (solid, dashed, dotted), stepped lines, null value handling, reference lines, and customizable colors while maintaining accessibility and responsive design principles.

## Important Constraints

- `ChartLineWrapper` component only accepts `ChartLine`, `ChartXAxis`, `ChartYAxis`, `ChartCartesianGrid`, `ChartTooltip`, `ChartLegend`, and `ChartReferenceLine` components as children
- `dataKey` prop is required for `ChartLine` component and must match a key in the data array
- `data` prop is required for `ChartLineWrapper` and must be an array of objects
- `color` prop only accepts chart categorical color tokens in the format `data.background.categorical.{colorName}.{emphasis}`
- Currently only supports `colorTheme="default"` - other color themes will fallback to default

## TypeScript Types

The following types represent the props that the LineChart component and its subcomponents accept. These types allow you to properly configure the component according to your needs.

```typescript
interface ChartLineProps {
  /**
   * The type of the line.
   *  @default : 'linear'
   */
  type?: 'step' | 'stepAfter' | 'stepBefore' | 'linear' | 'monotone';
  /**
   * The dot of the line.
   */
  dot?: RechartsLineProps['dot'];
  /**
   * The active dot we shows at line chart
   */
  activeDot?: RechartsLineProps['activeDot'];
  /**
   * If we don't have data for some points should we connect the line or should skip it.
   */
  connectNulls?: boolean;
  /**
   * Include this particular line in legend.
   *  @default : true
   */
  showLegend?: boolean;
  /**
   *  The data key of the x-axis
   */
  dataKey: string;
  /**
   * Name of the line in line chart.
   * if no provided, we will use the data key as the name.
   */
  name?: string;
  /**
   * Color of the line in line chart.
   * if no provided, we will pick colors from the default theme colors.
   */
  color?: ChartsCategoricalColorToken;
  /**
   * Style of the line in line chart.
   * @default: solid
   */
  strokeStyle?: 'dotted' | 'dashed' | 'solid';
}

type data = {
  [key: string]: unknown;
};

type ChartLineWrapperProps = {
  /**
   * The color theme of the line chart.
   */
  colorTheme?:  'categorical';
  /**
   * Chart data to be rendered
   */
  data: data[];
  children: React.ReactNode;
} & BoxProps;

type ChartReferenceLineProps = {
  /**
   * The y-coordinate of the reference line.
   */
  y?: RechartsReferenceLineProps['y'];
  /**
   * The x-coordinate  of the reference line.
   */
  x?: RechartsReferenceLineProps['x'];
  /**
   * The label of the reference line.
   */
  label: string;
};

type ChartXAxisProps = Omit<RechartsXAxisProps, 'tick' | 'label' | 'dataKey' | 'stroke'> & {
  /**
   * The label of the x-axis.
   */
  label?: string;
  /**
   * The data key of the x-axis.
   */
  dataKey?: string;
};

type ChartYAxisProps = Omit<RechartsYAxisProps, 'tick' | 'label' | 'dataKey' | 'stroke'> & {
  /**
   * The label of the y-axis.
   */
  label?: string;
  /**
   * The data key of the y-axis.
   */
  dataKey?: string;
};

type ChartTooltipProps = ComponentProps<typeof RechartsTooltip>;


type Layout = 'horizontal' | 'vertical';
type Align = 'left' | 'right';

type ChartTooltipProps = ComponentProps<typeof RechartsTooltip>;
type ChartLegendProps = ComponentProps<typeof RechartsLegend> & {
  layout?: Layout;
  align?: Align;
};


type ChartCartesianGridProps = ComponentProps<typeof RechartsCartesianGrid>;

type ChartsCategoricalColorToken = `data.background.categorical.${ChartColorCategories}.${keyof ChartCategoricalEmphasis}`;

type colorTheme = 'categorical';
```

## Examples

### Basic Line Chart with Multiple Series

A comprehensive example showing a line chart with multiple data series, axis labels, grid, tooltip, legend, and reference line with different stroke styles and colors.

```typescript
import React from 'react';
import {
  ChartLine,
  ChartLineWrapper,
  ChartXAxis,
  ChartYAxis,
  ChartCartesianGrid,
  ChartTooltip,
  ChartLegend,
  ChartReferenceLine,
} from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';

function BasicLineChart() {
  const data = [
    { month: 'Jan', revenue: 4000, expenses: 2400 },
    { month: 'Feb', revenue: 3000, expenses: 1398 },
    { month: 'Mar', revenue: 2000, expenses: 9800 },
    { month: 'Apr', revenue: 2780, expenses: 3908 },
    { month: 'May', revenue: 1890, expenses: 4800 },
    { month: 'Jun', revenue: 2390, expenses: 3800 },
  ];

  return (
    <Box width="100%" height="400px">
      <ChartLineWrapper data={data}>
        <ChartCartesianGrid />
        <ChartXAxis dataKey="month" label="Month" />
        <ChartYAxis label="Amount ($)" />
        <ChartTooltip />
        <ChartLegend />
        <ChartLine
          dataKey="revenue"
          name="Revenue"
          strokeStyle="solid"
          color="data.background.categorical.emerald.moderate"
        />
        <ChartLine
          dataKey="expenses"
          name="Expenses"
          strokeStyle="solid"
          color="data.background.categorical.crimson.moderate"
        />
        <ChartReferenceLine y={3000} label="Target: $3000" />
      </ChartLineWrapper>
    </Box>
  );
}

export default BasicLineChart;
```

---

## Link

## Component Name

Link

## Description

The Link component is used for navigating between pages or triggering in-page actions. It supports both anchor-style links for navigation and button-style links for actions. Links can be customized with different sizes, colors, and icon positions to match your design requirements, and they can be used standalone or inline within text content.

## Important Constraints

- At least one of `icon` or text content is required to render a link

## TypeScript Types

The following types represent the props that the Link component accepts. These allow you to properly configure the component according to your needs.

```typescript
/**
 * Props for the Link component
 */
type LinkProps = {
  /**
   * Content to be displayed in the link
   */
  children?: React.ReactNode;

  /**
   * URL that the link points to
   */
  href?: string;

  /**
   * Visual style of the link
   * @default 'anchor'
   */
  variant?: 'anchor' | 'button';

  /**
   * URL target attribute
   */
  target?: string;

  /**
   * URL rel attribute
   */
  rel?: string;

  /**
   * Color scheme for the link
   * @default 'primary'
   */
  color?: 'primary' | 'white' | 'neutral' | 'negative' | 'positive';

  /**
   * Size of the link text
   * @default 'medium'
   */
  size?: 'xsmall' | 'small' | 'medium' | 'large';

  /**
   * Icon to display with the link
   */
  icon?: React.ComponentType<IconProps>;

  /**
   * Position of the icon relative to text
   * @default 'left'
   */
  iconPosition?: 'left' | 'right';

  /**
   * Whether the link is disabled
   * @default false
   */
  isDisabled?: boolean;

  /**
   * Function called when the link is clicked
   */
  onClick?: (event: React.MouseEvent<HTMLAnchorElement | HTMLButtonElement>) => void;
} & StyledPropsBlade &
  TestID;

/**
 * Props for all Icon components
 */
type IconProps = {
  /**
   * The color of the icon
   * @default 'surface.icon.gray.normal'
   */
  color?: string;

  /**
   * The size of the icon
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large' | 'xlarge' | '2xlarge';
};
```

## Examples

### Standard Link Usage

```tsx
import React from 'react';
import {
  Box,
  Heading,
  Link,
  InfoIcon,
  DownloadIcon,
  ArrowRightIcon,
} from '@razorpay/blade/components';

const StandardLinkExample = () => {
  return (
    <Box padding="spacing.5">
      <Heading size="medium" marginBottom="spacing.5">
        Link Component
      </Heading>

      <Box display="flex" gap="spacing.4" flexWrap="wrap" alignItems="center">
        <Link
          href="https://razorpay.com"
          target="_blank"
          rel="noopener noreferrer"
          icon={ArrowRightIcon}
          iconPosition="right"
          color="primary"
          size="medium"
          aria-label="Visit Razorpay website"
        >
          Razorpay Website
        </Link>

        <Link href="#" color="negative" size="small" icon={InfoIcon} iconPosition="left">
          Important Notice
        </Link>

        <Link
          href="#"
          icon={DownloadIcon}
          iconPosition="left"
          onClick={() => console.log('Download clicked')}
          size="large"
        >
          Download Report
        </Link>

        <Link
          variant="button"
          isDisabled={true}
          color="neutral"
          onClick={() => console.log('This will not be called')}
        >
          Unavailable Action
        </Link>

        <Link href="#" color="positive">
          Positive Link
        </Link>

        <Box
          backgroundColor="surface.background.cloud.intense"
          padding="spacing.3"
          borderRadius="medium"
        >
          <Link href="#" color="white">
            White Link
          </Link>
        </Box>

        <Link
          variant="button"
          icon={InfoIcon}
          aria-label="Get more information"
          onClick={() => console.log('Info clicked')}
        />

        <Link href="#" variant="anchor" icon={DownloadIcon} aria-label="Download resources" />
      </Box>
    </Box>
  );
};

export default StandardLinkExample;
```

### Inline Link Usage

```tsx
import React from 'react';
import { Box, Text, Heading, Link, ArrowRightIcon } from '@razorpay/blade/components';

const InlineLinkExample = () => {
  return (
    <Box padding="spacing.5">
      <Heading size="medium" marginBottom="spacing.5">
        Inline Link Usage
      </Heading>

      <Box>
        <Text marginBottom="spacing.3">
          Read our{' '}
          <Link href="/terms" color="primary">
            Terms of Service
          </Link>{' '}
          and
          <Link href="/privacy" color="primary" marginLeft="spacing.1">
            Privacy Policy
          </Link> for more information.
        </Text>

        <Text>
          Forgot your password?{' '}
          <Link variant="button" size="small">
            Reset it here
          </Link>
        </Text>

        <Text marginTop="spacing.3">
          For more details, please visit our{' '}
          <Link href="/help" icon={ArrowRightIcon} iconPosition="right">
            Help Center
          </Link>
          or contact our <Link href="/support" size="small" color="primary">
            Support Team
          </Link>.
        </Text>
      </Box>
    </Box>
  );
};

export default InlineLinkExample;
```

---

## List

## Component Name

List

## Description

The List component displays a set of related items in a structured format. This is blade's equivalent of `ul` and `ol` HTML elements. It supports ordered, unordered, and ordered-filled variants with customizable sizes and styling. Lists can be nested for hierarchical data representation and include specialized item types for links, code snippets, and formatted text, making them versatile for various content presentation needs.

## Important Constraints

- `List` component only accepts `ListItem` components as children
- `ListItem` component only accepts `List`, `ListItemLink`, `ListItemCode`, `ListItemText` components or strings as children
- List nesting is limited to a maximum of 3 levels
- Icons can only be used with unordered lists (`variant="unordered"`)

Make sure to only follow structure as given in the examples below. Fragments are also not allowed as children in these components.

## TypeScript Types

The following types represent the props that the List component and its subcomponents accept. These allow you to properly configure the components according to your needs.

```typescript
/**
 * Props for the List component
 */
type ListProps = {
  /**
   * List display style
   * @default 'unordered'
   */
  variant?: 'unordered' | 'ordered' | 'ordered-filled';

  /**
   * Size of the list
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';

  /**
   * Content to be rendered inside the list
   */
  children: React.ReactNode;

  /**
   * Custom icon for list items
   */
  icon?: React.ComponentType<IconProps>;

  /**
   * Color of the custom icon
   */
  iconColor?: string;
} & StyledPropsBlade &
  TestID;

/**
 * Props for the ListItem component
 */
type ListItemProps = {
  /**
   * Content to be rendered inside the list item
   */
  children: React.ReactNode;
} & StyledPropsBlade &
  TestID;

/**
 * Props for the ListItemText component
 */
type ListItemTextProps = {
  /**
   * Content to be rendered inside the list item text
   */
  children: React.ReactNode;

  /**
   * HTML element to render
   * @default 'p'
   */
  as?: React.ElementType;

  /**
   * Text color
   */
  color?: string;

  /**
   * Font weight
   */
  weight?: 'regular' | 'medium' | 'semibold';
} & StyledPropsBlade &
  TestID;

/**
 * Props for the ListItemLink component
 */
type ListItemLinkProps = {
  /**
   * Content to be rendered inside the list item link
   */
  children: React.ReactNode;

  /**
   * URL that the link points to
   */
  href?: string;
} & StyledPropsBlade &
  TestID;

/**
 * Props for the ListItemCode component
 */
type ListItemCodeProps = {
  /**
   * Content to be rendered inside the code element
   */
  children: React.ReactNode;
} & StyledPropsBlade &
  TestID;

/**
 * Props for all Icon components
 */
type IconProps = {
  /**
   * The color of the icon
   */
  color?: string;

  /**
   * The size of the icon
   */
  size?: 'small' | 'medium' | 'large' | 'xlarge' | '2xlarge';
};
```

## Examples

### Ordered Filled List with Links

This example demonstrates the ordered-filled variant with links for step-by-step instructions.

```tsx
import React from 'react';
import { Box, List, ListItem, ListItemLink, Heading } from '@razorpay/blade/components';

const OrderedFilledListExample = () => {
  return (
    <Box padding="spacing.5">
      <Heading size="large">Ordered Filled List</Heading>

      <List variant="ordered-filled" size="medium">
        <ListItem>
          <ListItemLink href="#integration">Build Integration:</ListItemLink> Use the sample codes
          to integrate the Razorpay Web Standard Checkout on your website.
        </ListItem>
        <ListItem>
          <ListItemLink href="#testing">Test Integration:</ListItemLink> Test the integration to
          ensure it was successful.
        </ListItem>
        <ListItem>
          <ListItemLink href="#golive">Go-live Checklist:</ListItemLink> Check the go-live checklist
          before taking the integration live.
        </ListItem>
      </List>
    </Box>
  );
};

export default OrderedFilledListExample;
```

### Advanced List Features

This example demonstrates advanced list features including custom icons, code snippets, and styled text elements.

```tsx
import React from 'react';
import {
  Box,
  List,
  ListItem,
  ListItemText,
  ListItemLink,
  ListItemCode,
  Heading,
  BookmarkIcon,
} from '@razorpay/blade/components';

const AdvancedListExample = () => {
  return (
    <Box padding="spacing.5">
      <Heading size="large">Advanced List Features</Heading>

      <List
        variant="unordered"
        size="medium"
        icon={BookmarkIcon}
        iconColor="interactive.icon.primary.normal"
      >
        <ListItem>
          <ListItemLink href="#resources">Documentation Resources</ListItemLink>
          <List variant="ordered" size="medium">
            <ListItem>
              Install with: <ListItemCode>npm install @razorpay/blade</ListItemCode>
            </ListItem>
            <ListItem>
              <ListItemText>
                Check
                <ListItemText as="span" weight="semibold" color="feedback.text.positive.intense">
                  {' successful '}
                </ListItemText>
                installation
              </ListItemText>
            </ListItem>
          </List>
        </ListItem>
        <ListItem>
          <ListItemLink href="#payment-methods">Payment Methods</ListItemLink>
          <List variant="ordered" size="small">
            <ListItem>
              <ListItemText>
                UPI status is
                <ListItemText as="span" color="feedback.text.positive.intense">
                  {' active '}
                </ListItemText>
              </ListItemText>
            </ListItem>
            <ListItem>
              <ListItemText>
                Card status is
                <ListItemText as="span" color="feedback.text.notice.intense">
                  {' pending '}
                </ListItemText>
              </ListItemText>
            </ListItem>
            <ListItem>
              Add test cards: <ListItemCode>4111 1111 1111 1111</ListItemCode>
            </ListItem>
          </List>
        </ListItem>
        <ListItem>
          <ListItemLink href="#troubleshooting">Troubleshooting</ListItemLink>
          <List variant="unordered" size="small">
            <ListItem>
              Check console logs with: <ListItemCode>console.log(error)</ListItemCode>
            </ListItem>
            <ListItem>
              <ListItemText>
                Payment errors are marked as
                <ListItemText as="span" weight="semibold" color="feedback.text.negative.intense">
                  {' failed '}
                </ListItemText>
              </ListItemText>
            </ListItem>
          </List>
        </ListItem>
      </List>
    </Box>
  );
};

export default AdvancedListExample;
```

---

## ListView

## Component Name

ListView

## Description

ListView is a pattern component that provides a structured way to display tabular data with powerful filtering capabilities. It combines search functionality, quick filters, and advanced filtering options with a table display in a unified interface. This component is designed for data-heavy applications that require efficient data navigation and manipulation.

## TypeScript Types

These types define the props that the ListView component and its subcomponents accept. Understanding these types will help you properly implement the ListView pattern in your application.

```typescript
type ListViewCommonProps = {
  children: React.ReactNode;
};

type ListViewProps = ListViewCommonProps & TestID & DataAnalyticsAttribute;

type ListViewFilterProps = {
  children?: React.ReactNode;
  /**
   * Quick Filters Component
   */
  quickFilters: React.ReactNode;
  /**
   * Search value for search input
   * @deprecated Use `actions` prop instead. This will be removed in a future major version.
   */
  searchValue?: string;
  /**
   * Placeholder for search input
   * @deprecated Use `actions` prop instead. This will be removed in a future major version.
   */
  searchValuePlaceholder?: string;
  /**
   * Name for search input
   * @deprecated Use `actions` prop instead. This will be removed in a future major version.
   */
  searchName?: string;
  /**
   * onChange handler for search input
   * @deprecated Use `actions` prop instead. This will be removed in a future major version.
   */
  onSearchChange?: ({ name, value }: { name?: string; value?: string }) => void;
  /**
   *  onClear handler for search input
   * @deprecated Use `actions` prop instead. This will be removed in a future major version.
   */
  onSearchClear?: () => void;
  /**
   * it will show/hide the quick filters
   * @deprecated use showFilters instead
   */
  showQuickFilters?: boolean;
  /**
   * it will show/hide the filters
   * @deprecated Filters are now always expanded. This prop will be removed in a future version.
   * @default true
   */
  showFilters?: boolean;
  /**
   * onChange handler for showQuickFilters
   * @deprecated use onShowFiltersChange instead
   */
  onShowQuickFiltersChange?: (showQuickFilters: boolean) => void;
  /**
   * onChange handler for showFilters
   * @deprecated Filters are now always expanded. This prop will be removed in a future version.
   */
  onShowFiltersChange?: (showFilters: boolean) => void;
  /**
   * @default 0
   * you only need this if quick filters are controlled.
   */
  selectedFiltersCount?: number;
  /**
   * searchTrailing : trailing element for search input
   * @deprecated Use `actions` prop instead. This will be removed in a future major version.
   */
  searchTrailing?: React.ReactNode;
  /**
   * Actions slot for search input and action buttons
   * This will replace searchValue, onSearchChange, onSearchClear, searchValuePlaceholder, searchName, searchTrailing, and actionButtonGroup in a future major version.
   */
  actions?: React.ReactNode;
} & TestID &
  DataAnalyticsAttribute;

type ListViewSelectedFiltersType = {
  [key: string]: string[] | string | number[];
};

type ListViewFiltersContextType = {
  /**
   *  Number of Selected Filters
   */
  selectedFiltersCount: number;
  /**
   *  Selected Filters
   */
  listViewSelectedFilters: ListViewSelectedFiltersType;
  /**
   *  Selected Filters
   */
  setListViewSelectedFilters: React.Dispatch<React.SetStateAction<ListViewSelectedFiltersType>>;
};
```

## Example

Below is a comprehensive example demonstrating how to use the ListView component with various filtering options, search functionality, and table display:

```tsx
import React, { useState } from 'react';
import {
  Amount,
  ListView,
  ListViewFilters,
  Box,
  QuickFilterGroup,
  QuickFilter,
  FilterChipGroup,
  Dropdown,
  DropdownOverlay,
  Counter,
  FilterChipSelectInput,
  ActionList,
  ActionListItem,
  FilterChipDatePicker,
  Table,
  TableHeader,
  TableCell,
  TableRow,
  TableHeaderRow,
  TableHeaderCell,
  TableBody,
  TableFooter,
  TableFooterRow,
  TableFooterCell,
  TablePagination,
  TableEditableCell,
  Button,
  IconButton,
  CheckIcon,
  CloseIcon,
  Code,
  Badge,
  SearchInput,
  Link,
  SelectInput,
} from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';

// Define data types for strong typing
type PaymentItem = {
  id: string;
  paymentId: string;
  amount: number;
  status: 'Completed' | 'Pending' | 'Failed';
  date: Date;
  method: string;
  account: string;
};

type TableData<T> = {
  nodes: T[];
};

function ListViewExample() {
  // Sample data for the table
  const nodes: PaymentItem[] = [
    ...Array.from({ length: 20 }, (_, i) => ({
      id: (i + 1).toString(),
      paymentId: `rzp${Math.floor(Math.random() * 1000000)}`,
      amount: Number((Math.random() * 10000).toFixed(2)),
      status: ['Completed', 'Pending', 'Failed'][
        Math.floor(Math.random() * 3)
      ] as PaymentItem['status'],
      date: new Date(2023, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1),
      method: ['Bank Transfer', 'Credit Card', 'PayPal'][Math.floor(Math.random() * 3)],
      account: Math.floor(Math.random() * 1000000000).toString(),
    })),
  ];

  const data: TableData<PaymentItem> = { nodes };

  // State management for filters and search
  const [listViewTableData, setListViewTableData] = useState(data);
  const [selectedQuickFilter, setSelectedQuickFilter] = useState<string>('All');
  const [searchValue, setSearchValue] = useState<string>('');
  const [methodFilter, setMethodFilter] = useState<string>('');
  const [filterDateRange, setFilterDateRange] = useState<[Date, Date] | undefined>(undefined);

  // Mobile responsive hook
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint({
    breakpoints: theme.breakpoints,
  });
  const isMobile = matchedDeviceType === 'mobile';

  // Filter utility functions
  const getQuickFilterValueCount = (value: string): number => {
    if (value === 'All') {
      return data.nodes.length;
    }
    return data.nodes.filter((node) => node.status === value).length;
  };

  const getQuickFilterData = (
    data: TableData<PaymentItem>,
    value?: string,
  ): TableData<PaymentItem> => {
    if (!value || value === 'All') {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => node.status === value) };
  };

  const getSearchedData = (
    data: TableData<PaymentItem>,
    value?: string,
  ): TableData<PaymentItem> => {
    if (!value) {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => node.paymentId.includes(value)) };
  };

  const getMethodFilterData = (
    data: TableData<PaymentItem>,
    value?: string,
  ): TableData<PaymentItem> => {
    if (!value) {
      return { nodes: data.nodes };
    }
    return { nodes: data.nodes.filter((node) => node.method === value) };
  };

  const getFilterRangeData = (
    data: TableData<PaymentItem>,
    value?: [Date, Date],
  ): TableData<PaymentItem> => {
    if (!value?.[0]) {
      return { nodes: data.nodes };
    }
    return {
      nodes: data.nodes.filter((node) => {
        if (!value?.[0] || !value?.[1]) return false;
        return node.date >= value[0] && node.date <= value[1];
      }),
    };
  };

  // Search handlers
  const handleSearchChange = (value?: string): void => {
    const quickFilterData = getQuickFilterData(data, selectedQuickFilter);
    const searchValueData = getSearchedData(quickFilterData, value);
    const methodFilterData = getMethodFilterData(searchValueData, methodFilter);
    const dateRangeFilterData = getFilterRangeData(methodFilterData, filterDateRange);
    setListViewTableData(dateRangeFilterData);
    setSearchValue(value || '');
  };

  const handleSearchClear = (): void => {
    const quickFilterData = getQuickFilterData(data, selectedQuickFilter);
    const methodFilterData = getMethodFilterData(quickFilterData, methodFilter);
    const dateRangeFilterData = getFilterRangeData(methodFilterData, filterDateRange);
    setListViewTableData(dateRangeFilterData);
    setSearchValue('');
  };

  return (
    <Box height="100%" testID="payment-list-view">
      {isMobile && (
        <SearchInput
          label=""
          value={searchValue}
          placeholder="Search by Payment ID"
          onChange={({ value }) => handleSearchChange(value)}
          onClearButtonClick={handleSearchClear}
        />
      )}
      <ListView>
        <ListViewFilters
          quickFilters={
            <QuickFilterGroup
              selectionType="single"
              onChange={({ values }) => {
                const value = values[0];
                const quickFilterData = getQuickFilterData(data, value);
                const searchValueData = getSearchedData(quickFilterData, searchValue);
                const methodFilterData = getMethodFilterData(searchValueData, methodFilter);
                const dateRangeFilterData = getFilterRangeData(methodFilterData, filterDateRange);

                setListViewTableData(dateRangeFilterData);
                setSelectedQuickFilter(value);
              }}
              defaultValue="All"
              value={selectedQuickFilter}
            >
              {['All', 'Pending', 'Failed', 'Completed'].map((status) => (
                <QuickFilter
                  key={status}
                  title={status}
                  value={status}
                  trailing={<Counter value={getQuickFilterValueCount(status)} color="neutral" />}
                />
              ))}
            </QuickFilterGroup>
          }
          selectedFiltersCount={
            (methodFilter ? 1 : 0) +
            (filterDateRange?.[0] ? 1 : 0) +
            (selectedQuickFilter !== 'All' ? 1 : 0)
          }
          actions={
            !isMobile && (
              <Box width="280px">
                <SearchInput
                  label=""
                  value={searchValue}
                  placeholder="Search by Payment ID"
                  onChange={({ value }) => handleSearchChange(value)}
                  onClearButtonClick={handleSearchClear}
                  trailing={
                    <Dropdown selectionType="single">
                      <SelectInput label="" placeholder="Filter by method" labelPosition="top" />
                      <DropdownOverlay>
                        <ActionList>
                          <ActionListItem title="All Methods" value="all" />
                          <ActionListItem title="Bank Transfer" value="bank" />
                          <ActionListItem title="Credit Card" value="card" />
                          <ActionListItem title="UPI" value="upi" />
                        </ActionList>
                      </DropdownOverlay>
                    </Dropdown>
                  }
                />
              </Box>
            )
          }
        >
          <FilterChipGroup
            onClearButtonClick={() => {
              const quickFilterData = getQuickFilterData(data, 'All');
              const searchValueData = getSearchedData(quickFilterData, searchValue);
              setListViewTableData(searchValueData);
              setMethodFilter('');
              setFilterDateRange(undefined);
              setSelectedQuickFilter('All');
            }}
          >
            <Dropdown selectionType="single">
              <FilterChipSelectInput
                label="Payment Method"
                value={methodFilter}
                onChange={({ values }) => {
                  const value = values[0];
                  const quickFilterData = getQuickFilterData(data, selectedQuickFilter);
                  const searchValueData = getSearchedData(quickFilterData, searchValue);
                  const methodFilterData = getMethodFilterData(searchValueData, value);
                  const dateRangeFilterData = getFilterRangeData(methodFilterData, filterDateRange);

                  setListViewTableData(dateRangeFilterData);
                  setMethodFilter(value);
                }}
                onClearButtonClick={() => {
                  const quickFilterData = getQuickFilterData(data, selectedQuickFilter);
                  const searchValueData = getSearchedData(quickFilterData, searchValue);
                  const dateRangeFilterData = getFilterRangeData(searchValueData, filterDateRange);
                  setListViewTableData(dateRangeFilterData);
                  setMethodFilter('');
                }}
              />
              <DropdownOverlay>
                <ActionList>
                  {['Bank Transfer', 'Credit Card', 'PayPal'].map((method) => (
                    <ActionListItem
                      key={method}
                      title={method}
                      value={method}
                      isSelected={methodFilter === method}
                    />
                  ))}
                </ActionList>
              </DropdownOverlay>
            </Dropdown>

            <FilterChipDatePicker
              label="Date Range"
              selectionType="range"
              value={filterDateRange}
              onChange={(value) => {
                const quickFilterData = getQuickFilterData(data, selectedQuickFilter);
                const searchValueData = getSearchedData(quickFilterData, searchValue);
                const methodFilterData = getMethodFilterData(searchValueData, methodFilter);
                const dateRangeFilterData = getFilterRangeData(
                  methodFilterData,
                  value as [Date, Date],
                );
                setListViewTableData(dateRangeFilterData);
                setFilterDateRange(value as [Date, Date]);
              }}
              onClearButtonClick={() => {
                const quickFilterData = getQuickFilterData(data, selectedQuickFilter);
                const searchValueData = getSearchedData(quickFilterData, searchValue);
                const methodFilterData = getMethodFilterData(searchValueData, methodFilter);
                setListViewTableData(methodFilterData);
                setFilterDateRange(undefined);
              }}
            />
          </FilterChipGroup>
        </ListViewFilters>

        <Table
          data={listViewTableData}
          defaultSelectedIds={['1', '3']}
          onSelectionChange={(selectedIds) => console.log('Selected rows:', selectedIds)}
          isFirstColumnSticky
          selectionType="single"
          rowDensity="compact"
          pagination={
            <TablePagination
              onPageChange={console.log}
              defaultPageSize={10}
              onPageSizeChange={console.log}
              showPageSizePicker
              showPageNumberSelector
            />
          }
        >
          {(tableData) => (
            <>
              <TableHeader>
                <TableHeaderRow>
                  <TableHeaderCell headerKey="PAYMENT_ID">Payment ID</TableHeaderCell>
                  <TableHeaderCell headerKey="AMOUNT">Amount</TableHeaderCell>
                  <TableHeaderCell headerKey="ACCOUNT">Account</TableHeaderCell>
                  <TableHeaderCell headerKey="DATE">Date</TableHeaderCell>
                  <TableHeaderCell headerKey="METHOD">Method</TableHeaderCell>
                  <TableHeaderCell headerKey="STATUS">Status</TableHeaderCell>
                </TableHeaderRow>
              </TableHeader>
              <TableBody>
                {tableData.map((tableItem, index) => (
                  <TableRow
                    key={tableItem.id}
                    item={tableItem}
                    hoverActions={
                      <>
                        <Button variant="tertiary" size="xsmall">
                          View Details
                        </Button>
                        <IconButton
                          icon={CheckIcon}
                          isHighlighted
                          accessibilityLabel="Approve payment"
                          onClick={() => {
                            console.log('Approved', tableItem.id);
                          }}
                        />
                        <IconButton
                          icon={CloseIcon}
                          isHighlighted
                          accessibilityLabel="Reject payment"
                          onClick={() => {
                            console.log('Rejected', tableItem.id);
                          }}
                        />
                      </>
                    }
                    onClick={() => {
                      console.log('Row clicked:', tableItem);
                    }}
                  >
                    <TableCell>
                      <Code size="small">{tableItem.paymentId}</Code>
                    </TableCell>
                    <TableEditableCell
                      accessibilityLabel="Edit payment amount"
                      placeholder="Enter amount"
                      successText="Amount is valid"
                      defaultValue={tableItem.amount.toString()}
                    />
                    <TableCell>
                      <Link size="small" color="neutral" target="_blank" href={`/`}>
                        {tableItem.account}
                      </Link>
                    </TableCell>
                    <TableCell>
                      {tableItem.date?.toLocaleDateString('en-IN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                      })}
                    </TableCell>
                    <TableCell>{tableItem.method}</TableCell>
                    <TableCell>
                      <Badge
                        size="xsmall"
                        color={
                          tableItem.status === 'Completed'
                            ? 'positive'
                            : tableItem.status === 'Pending'
                            ? 'notice'
                            : 'negative'
                        }
                      >
                        {tableItem.status}
                      </Badge>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
              <TableFooter>
                <TableFooterRow>
                  <TableFooterCell>Total</TableFooterCell>
                  <TableFooterCell>
                    <Amount value={tableData.reduce((sum, item) => sum + item.amount, 0)} />
                  </TableFooterCell>
                  <TableFooterCell>-</TableFooterCell>
                  <TableFooterCell>-</TableFooterCell>
                  <TableFooterCell>-</TableFooterCell>
                  <TableFooterCell>-</TableFooterCell>
                </TableFooterRow>
              </TableFooter>
            </>
          )}
        </Table>
      </ListView>
    </Box>
  );
}

export default ListViewExample;
```

### Multiple Selection Example

Here's an example demonstrating multiple selection in ListView's quick filters:

```tsx
import React, { useState } from 'react';
import {
  ListView,
  ListViewFilters,
  Box,
  QuickFilterGroup,
  QuickFilter,
  Counter,
  Table,
  SearchInput,
  TableHeader,
  TableCell,
  TableRow,
  TableHeaderRow,
  TableHeaderCell,
  TableBody,
  Badge,
  Amount,
  Code,
  TableEditableCell,
  Link,
} from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';

// Define data types for strong typing
type PaymentItem = {
  id: string;
  paymentId: string;
  amount: number;
  status: 'Completed' | 'Pending' | 'Failed';
  date: Date;
  method: string;
  account: string;
};

type TableData<T> = {
  nodes: T[];
};
function MultiSelectListViewExample() {
  // Sample data similar to the first example
  const nodes: PaymentItem[] = [
    ...Array.from({ length: 20 }, (_, i) => ({
      id: (i + 1).toString(),
      paymentId: `rzp${Math.floor(Math.random() * 1000000)}`,
      amount: Number((Math.random() * 10000).toFixed(2)),
      status: ['Completed', 'Pending', 'Failed'][
        Math.floor(Math.random() * 3)
      ] as PaymentItem['status'],
      date: new Date(2023, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1),
      method: ['Bank Transfer', 'Credit Card', 'PayPal'][Math.floor(Math.random() * 3)],
      account: Math.floor(Math.random() * 1000000000).toString(),
    })),
  ];

  const data: TableData<PaymentItem> = { nodes };

  // State management
  const [listViewTableData, setListViewTableData] = useState(data);
  const [selectedQuickFilters, setSelectedQuickFilters] = useState<string[]>([]);
  const [searchValue, setSearchValue] = useState<string>('');
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint({
    breakpoints: theme.breakpoints,
  });
  const isMobile = matchedDeviceType === 'mobile';

  // Filter function for multiple selected status values
  const getMultipleStatusFilterData = (
    data: TableData<PaymentItem>,
    values: string | string[],
  ): TableData<PaymentItem> => {
    if (!values || values.length === 0) {
      return { nodes: data.nodes };
    }
    return {
      nodes: data.nodes.filter((node) => values.includes(node.status)),
    };
  };
  const handleSearchChange = (value?: string): void => {
    // Apply search logic here similar to first example
    setSearchValue(value || '');
  };

  const handleSearchClear = (): void => {
    // Apply search clear logic here similar to first example
    setSearchValue('');
  };

  return (
    <Box height="100%">
      {isMobile && (
        <SearchInput
          label=""
          value={searchValue}
          placeholder="Search payments"
          onChange={({ value }) => handleSearchChange(value)}
          onClearButtonClick={handleSearchClear}
        />
      )}

      <ListView>
        <ListViewFilters
          quickFilters={
            <QuickFilterGroup
              selectionType="multiple"
              onChange={({ values }) => {
                const filteredData = getMultipleStatusFilterData(data, values);
                setListViewTableData(filteredData);
                setSelectedQuickFilters(values);
              }}
              value={selectedQuickFilters}
            >
              {['Pending', 'Failed', 'Completed'].map((status) => (
                <QuickFilter
                  key={status}
                  title={status}
                  value={status}
                  trailing={
                    <Counter
                      value={data.nodes.filter((node) => node.status === status).length}
                      color="neutral"
                    />
                  }
                />
              ))}
            </QuickFilterGroup>
          }
          selectedFiltersCount={selectedQuickFilters.length}
          actions={
            !isMobile && (
              <Box width="208px">
                <SearchInput
                  label=""
                  value={searchValue}
                  placeholder="Search payments"
                  onChange={({ value }) => handleSearchChange(value)}
                  onClearButtonClick={handleSearchClear}
                />
              </Box>
            )
          }
        >
          {/* Filter chips and table similar to first example */}
        </ListViewFilters>
        <Table data={listViewTableData}>
          {(tableData) => (
            <>
              <TableHeader>
                <TableHeaderRow>
                  <TableHeaderCell headerKey="ID">ID</TableHeaderCell>
                  <TableHeaderCell headerKey="PAYMENT_ID">Payment ID</TableHeaderCell>
                  <TableHeaderCell headerKey="AMOUNT">Amount</TableHeaderCell>
                  <TableHeaderCell headerKey="STATUS">Status</TableHeaderCell>
                  <TableHeaderCell headerKey="DATE">Date</TableHeaderCell>
                  <TableHeaderCell headerKey="METHOD">Method</TableHeaderCell>
                </TableHeaderRow>
              </TableHeader>
              <TableBody>
                {tableData.map((tableItem, index) => (
                  <TableRow
                    key={tableItem.id}
                    item={tableItem}
                    onClick={() => {
                      console.log('Row clicked:', tableItem);
                    }}
                  >
                    <TableCell>
                      <Code size="small">{tableItem.paymentId}</Code>
                    </TableCell>
                    <TableEditableCell
                      accessibilityLabel="Edit payment amount"
                      placeholder="Enter amount"
                      successText="Amount is valid"
                      defaultValue={tableItem.amount.toString()}
                    />
                    <TableCell>
                      <Link size="small" color="neutral" target="_blank" href={`/`}>
                        {tableItem.account}
                      </Link>
                    </TableCell>
                    <TableCell>
                      {tableItem.date?.toLocaleDateString('en-IN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                      })}
                    </TableCell>
                    <TableCell>{tableItem.method}</TableCell>
                    <TableCell>
                      <Badge
                        size="xsmall"
                        color={
                          tableItem.status === 'Completed'
                            ? 'positive'
                            : tableItem.status === 'Pending'
                            ? 'notice'
                            : 'negative'
                        }
                      >
                        {tableItem.status}
                      </Badge>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </>
          )}
        </Table>
      </ListView>
    </Box>
  );
}

export default MultiSelectListViewExample;
```

---

## Menu

## Component Name

Menu

## Description

Action Menu displays a list of actions on temporary surfaces. They allow users to perform actions from multiple options. Menus appear when users interact with a button, action, or other control, creating a contextual interface for related actions. Note that Menus are not responsive by default and are not intended for selection - use Dropdown with Select or AutoComplete for selectable options.

## TypeScript Types

The following types represent the props that the Menu component and its subcomponents accept. These types should be used when implementing the Menu component in your application.

```typescript
// The main Menu component props
type MenuProps = {
  /**
   * First children is trigger and second children is MenuOverlay
   */
  children: [React.ReactElement, React.ReactElement];

  /**
   * Open controlled state
   */
  isOpen?: boolean;

  /**
   * On Menu open change callback
   */
  onOpenChange?: ({ isOpen }: { isOpen: boolean }) => void;

  /**
   * Should menu open on click or hover
   *
   * @default 'click'
   */
  openInteraction?: 'hover' | 'click';
};

// MenuItem props
type MenuItemProps = {
  /**
   * title of item
   */
  title?: string;

  /**
   * Description text for the item
   */
  description?: string;

  /**
   * Slot to render custom menu items
   */
  children?: React.ReactNode;

  /**
   * HTML element to render as
   */
  as?: React.ElementType;

  /**
   * Click handler for MenuItem
   *
   * Absence of this prop and href will turn the item into non-interactive item
   */
  onClick?: (event: React.MouseEvent) => void;

  /**
   * Focus handler for MenuItem
   *
   * Absence of this prop and href will turn the item into non-interactive item
   */
  onFocus?: (event: React.FocusEvent) => void;

  /**
   * Link to open when item is clicked.
   *
   * Absence of this prop and onClick will turn the item into non-interactive item
   */
  href?: string;

  /**
   * HTML target of the link
   */
  target?: string;

  /**
   * Item that goes on left-side of item.
   *
   * Will be overridden in multiselect
   */
  leading?: React.ReactNode;

  /**
   * Item that goes on right-side of item.
   */
  trailing?: React.ReactNode;

  /**
   * Item that goes immediately next to the title.
   */
  titleSuffix?: React.ReactElement;

  /**
   * disabled state of item
   */
  isDisabled?: boolean;

  /**
   * Color of item. set to negative for dangerous actions like Delete, Remove, etc
   */
  color?: 'negative';
} & DataAnalyticsAttribute;

// MenuOverlay props
type MenuOverlayProps = {
  /**
   * JSX Slot for MenuItem or anything else
   */
  children: React.ReactElement[] | React.ReactElement | React.ReactNode;

  /**
   * zIndex override
   */
  zIndex?: number | string;

  /**
   * width override.
   *
   * By default width is not set
   */
  width?: string | number;

  /**
   * minWidth override
   */
  minWidth?: string | number;

  /**
   * maxWidth override
   */
  maxWidth?: string | number;
} & TestID &
  DataAnalyticsAttribute;

// MenuHeader props
type MenuHeaderProps = {
  /**
   * Title of the menu header
   */
  title: string;

  /**
   * Subtitle of the menu header
   */
  subtitle?: string;

  /**
   * Leading element of the menu header
   */
  leading?: React.ReactNode;

  /**
   * Trailing element of the menu header
   */
  trailing?: React.ReactNode;

  /**
   * Item that goes immediately next to the title
   */
  titleSuffix?: React.ReactNode;

  /**
   * Test ID for testing
   */
  testID?: string;

  /**
   * Data analytics attributes
   */
  'data-analytics'?: string;
};

// MenuFooter props
type MenuFooterProps = {
  /**
   * Children of the menu footer
   */
  children: React.ReactNode;

  /**
   * Test ID for testing
   */
  testID?: string;

  /**
   * Data analytics attributes
   */
  'data-analytics'?: string;
};

// MenuDivider props
type MenuDividerProps = TestID & DataAnalyticsAttribute;
```

## Example

### Comprehensive Profile Menu

This example demonstrates a comprehensive menu with an Avatar trigger and various menu components including MenuHeader, MenuItem, nested menus, MenuDivider, and MenuFooter. It shows how to structure a user profile menu with details, actions, and a footer message.

```tsx
import React from 'react';
import {
  Menu,
  MenuDivider,
  MenuItem,
  MenuOverlay,
  MenuHeader,
  MenuFooter,
  Button,
  Box,
  Link,
  Text,
  Avatar,
  CopyIcon,
  LogOutIcon,
  ShareIcon,
  TestIcon,
  TicketIcon,
  UserIcon,
} from '@razorpay/blade/components';

function BasicMenu() {
  return (
    <Box>
      <Menu>
        <Avatar name="Saurabh Daware" size="large" color="primary" />
        <MenuOverlay>
          <MenuHeader title="Saurabh Daware" subtitle="Admin" leading={<UserIcon />} />
          <Box paddingY="spacing.4" paddingX="spacing.3">
            <Text display="block" size="medium" weight="semibold">
              Razorpay Pvt Ltd
            </Text>
            <Box display="flex" alignItems="center" gap="spacing.3">
              <Text size="small">MID: Xyzyspoon13857</Text>
              <Link variant="button" size="small" icon={CopyIcon} />
            </Box>
          </Box>
          <Button variant="tertiary" isFullWidth size="xsmall">
            Switch Merchant
          </Button>
          <MenuDivider marginY="spacing.3" />
          <MenuItem
            title="Enable Test Mode"
            leading={<TestIcon size="small" />}
            description="Enable test mode"
          />
          <MenuItem
            title="View Support Tickets"
            leading={<TicketIcon size="small" />}
            description="View all your support tickets"
          />
          <Menu>
            <MenuItem leading={<ShareIcon size="small" />} title="Share Profile" />
            <MenuOverlay>
              <MenuItem title="Mail" />
              <Menu>
                <MenuItem title="Instagram" />
                <MenuOverlay>
                  <MenuItem title="Instagram Stories" />
                  <MenuItem title="Instagram Post" />
                  <MenuItem title="Instagram Chat" />
                </MenuOverlay>
              </Menu>
            </MenuOverlay>
          </Menu>
          <MenuItem
            leading={<LogOutIcon size="small" color="feedback.icon.negative.intense" />}
            title="Log Out"
            color="negative"
          />
          <MenuFooter>
            <Text variant="caption" size="small">
              Partner with us and start earning on every referral
            </Text>
          </MenuFooter>
        </MenuOverlay>
      </Menu>
    </Box>
  );
}

export default BasicMenu;
```

### Controlled Menu

This example shows how to create a controlled menu where the open state is managed by the component's state. It uses a button to explicitly open the menu and demonstrates the `isOpen` and `onOpenChange` props for programmatic control of the menu's visibility.

```tsx
import React, { useState } from 'react';
import {
  Menu,
  MenuDivider,
  MenuItem,
  MenuOverlay,
  MenuHeader,
  MenuFooter,
  Button,
  Box,
  Link,
  Text,
  Avatar,
  CopyIcon,
  LogOutIcon,
  ShareIcon,
  TestIcon,
  TicketIcon,
  UserIcon,
} from '@razorpay/blade/components';

function ControlledMenu() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <Box>
      <Button marginY="spacing.4" onClick={() => setIsOpen(true)}>
        Open Menu
      </Button>

      <Menu isOpen={isOpen} onOpenChange={({ isOpen }) => setIsOpen(isOpen)}>
        <Avatar name="Saurabh Daware" size="large" color="primary" />
        <MenuOverlay>
          <MenuHeader title="Saurabh Daware" subtitle="Admin" leading={<UserIcon />} />
          <Box paddingY="spacing.4" paddingX="spacing.3">
            <Text display="block" size="medium" weight="semibold">
              Razorpay Pvt Ltd
            </Text>
            <Box display="flex" alignItems="center" gap="spacing.3">
              <Text size="small">MID: Xyzyspoon13857</Text>
              <Link variant="button" size="small" icon={CopyIcon} />
            </Box>
          </Box>
          <Button variant="tertiary" isFullWidth size="xsmall">
            Switch Merchant
          </Button>
          <MenuDivider marginY="spacing.3" />
          <MenuItem
            title="Enable Test Mode"
            leading={<TestIcon size="small" />}
            description="Enable test mode"
          />
          <MenuItem
            title="View Support Tickets"
            leading={<TicketIcon size="small" />}
            description="View all your support tickets"
          />
          <MenuItem
            leading={<LogOutIcon size="small" color="feedback.icon.negative.intense" />}
            title="Log Out"
            color="negative"
            onClick={() => console.log('Logging out')}
          />
        </MenuOverlay>
      </Menu>
    </Box>
  );
}

export default ControlledMenu;
```

---

## Modal

## Component Name

Modal

## Description

Modal is a dialog component that appears in front of the app content to provide critical information or request user input. It's designed to focus user attention, disabling all other interactions until explicitly dismissed. Modals are accessible, can be dismissed via escape key, clicking outside, or a close button (when dismissible), and come in three sizes: small, medium, and large.

## Important Constraints

- `ModalHeader`'s `trailing` prop only accepts `Button`, `IconButton`, `Badge`, `Link`, `Text` & `Amount` components.

## TypeScript Types

These types represent the props that the Modal component and its subcomponents accept. When using the Modal component along with its subcomponents, you'll need these type definitions to understand the available props.

```typescript
// The main Modal component props
type ModalProps = {
  /**
   *  Children of Modal
   * Only ModalHeader, ModalBody and ModalFooter are allowed as children
   */
  children: React.ReactNode;
  /**
   Sets the modal to open or close
   * @default false
   */
  isOpen: boolean;
  /**
   *  Callback function when user clicks on close button or outside the modal or on pressing escape key.
   */
  onDismiss: () => void;
  /**
   * Whether the modal can be dismissed by clicking outside or pressing escape key
   * @default true
   * @note
   * If isDismissible is false, the modal will not be dismissed when the user clicks outside the modal or presses the escape key and the close button will not be shown. you need to handle the closing of the modal from your own code. also onDismiss will not be called.
   */
  isDismissible?: boolean;
  /**
   *  Ref to the element to be focused on opening the modal.
   */
  initialFocusRef?: React.MutableRefObject<any>;
  /**
   *  Size of the modal
   * @default 'small'
   */
  size?: 'small' | 'medium' | 'large' | 'full';
  /**
   *  Accessibility label for the modal
   */
  accessibilityLabel?: string;
  /**
   * Sets the z-index of the modal
   * @default 1000
   */
  zIndex?: number;
} & DataAnalyticsAttribute;

// The ModalHeader component props
type ModalHeaderProps = {
  /**
   * Title of the header
   */
  title?: React.ReactNode;
  /**
   * Subtitle of the header
   */
  subtitle?: React.ReactNode;
  /**
   * Content to be displayed before the title
   */
  leading?: React.ReactNode;
  /**
   * Content to be displayed after the title
   */
  trailing?: React.ReactNode;
  /**
   * Content to be displayed as a suffix to the title
   */
  titleSuffix?: React.ReactNode;
} & DataAnalyticsAttribute;

// The ModalBody component props
type ModalBodyProps = {
  children: React.ReactNode;
  /**
   * Sets the padding equally on all sides. Only few `spacing` tokens are allowed deliberately
   * @default `spacing.6`
   */
  padding?: Extract<SpacingValueType, 'spacing.0' | 'spacing.6'>;
} & DataAnalyticsAttribute;

// The ModalFooter component props
type ModalFooterProps = {
  children: React.ReactNode;
} & DataAnalyticsAttribute;
```

## Example

Below is a comprehensive example showcasing the Modal component with various configurations:

```tsx
import React, { useState, useRef } from 'react';
import {
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter,
  Box,
  Button,
  Radio,
  RadioGroup,
  Text,
  TextArea,
  Checkbox,
} from '@razorpay/blade/components';

const ModalExample = () => {
  // State to control modal visibility
  const [isModalOpen, setIsModalOpen] = useState(false);

  // State for form values
  const [selectedAddress, setSelectedAddress] = useState('home');
  const [selectedSize, setSelectedSize] = useState<'small' | 'medium' | 'large'>('medium');
  const [saveAsDefault, setSaveAsDefault] = useState(false);

  // Ref for initial focus when modal opens
  const addAddressButtonRef = useRef(null);

  // Handlers
  const openModal = () => setIsModalOpen(true);
  const closeModal = () => setIsModalOpen(false);
  const handleSave = () => {
    // Handle save logic here
    closeModal();
  };

  return (
    <>
      {/* Buttons to demonstrate different modal sizes */}
      <Box display="flex" gap="spacing.5" flexWrap="wrap" marginBottom="spacing.5">
        <Button
          onClick={() => {
            setSelectedSize('small');
            openModal();
          }}
        >
          Open Small Modal
        </Button>
      </Box>

      {/* Modal component */}
      <Modal
        isOpen={isModalOpen}
        onDismiss={closeModal}
        size={selectedSize}
        initialFocusRef={addAddressButtonRef}
        accessibilityLabel="Address selection modal"
      >
        <ModalHeader
          title="Select Delivery Address"
          subtitle="Choose where you'd like your order delivered"
        />

        <ModalBody>
          <Box display="flex" flexDirection="column" gap="spacing.5">
            <Box marginTop="spacing.5">
              <Text size="small" color="surface.text.gray.subtle">
                Need to add a new address?
              </Text>

              <Box marginTop="spacing.4">
                <TextArea
                  label="Address Line 1"
                  placeholder="Enter street address"
                  marginBottom="spacing.4"
                />
                <TextArea
                  label="Address Line 2"
                  placeholder="Apt, Suite, Building (optional)"
                  marginBottom="spacing.4"
                />
              </Box>
            </Box>
          </Box>
        </ModalBody>

        <ModalFooter>
          <Box display="flex" gap="spacing.3" justifyContent="flex-end" width="100%">
            <Button variant="tertiary" onClick={closeModal}>
              Cancel
            </Button>
            <Button ref={addAddressButtonRef} onClick={handleSave}>
              Save Address
            </Button>
          </Box>
        </ModalFooter>
      </Modal>
    </>
  );
};

export default ModalExample;
```

### OTP Modal Example

This example demonstrates a modal for OTP verification with input fields, timer, and resend functionality.

```tsx
import React from 'react';
import {
  Box,
  Button,
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter,
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Text,
  OTPInput,
  Link,
  LockIcon,
} from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';

// Responsive wrapper component for handling mobile/desktop modal display
function ResponsiveModalWrapper({
  children,
  footer,
  isOpen,
  onDismiss,
  modalBodyPadding,
  modalSize = 'small',
  wrapInBottomSheetFooter = false,
  customSnapPoints = [0.35, 0.5, 0.85],
}: {
  children: React.ReactElement | React.ReactElement[];
  footer?: React.ReactElement;
  isOpen: boolean;
  onDismiss: () => void;
  modalBodyPadding?: 'spacing.0' | 'spacing.6';
  modalSize?: 'small' | 'medium' | 'large' | 'full';
  wrapInBottomSheetFooter?: boolean;
  customSnapPoints?: [number, number, number];
}): React.ReactNode {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  if (isMobile) {
    return (
      <BottomSheet isOpen={isOpen} onDismiss={onDismiss} snapPoints={customSnapPoints}>
        <BottomSheetHeader />
        <BottomSheetBody padding="spacing.5">
          {children}
          {footer && !wrapInBottomSheetFooter && <Box marginTop="spacing.6">{footer}</Box>}
        </BottomSheetBody>
        {footer && wrapInBottomSheetFooter && <BottomSheetFooter>{footer}</BottomSheetFooter>}
      </BottomSheet>
    );
  }

  return (
    <Modal isOpen={isOpen} onDismiss={onDismiss} size={modalSize}>
      <ModalHeader />
      <ModalBody padding={modalBodyPadding}>{children}</ModalBody>
      {footer && <ModalFooter>{footer}</ModalFooter>}
    </Modal>
  );
}

function OTPModal(): React.ReactElement {
  const [isOpen, setIsOpen] = React.useState(false);
  const [otp, setOtp] = React.useState('');
  const [error, setError] = React.useState<string | null>(null);
  const [isResendOtpTimerRunning, setIsResendOtpTimerRunning] = React.useState(false);
  const [resendOtpTimer, setResendOtpTimer] = React.useState(30);
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  // Start timer when modal opens
  React.useEffect(() => {
    if (isOpen) {
      setIsResendOtpTimerRunning(true);
      setResendOtpTimer(30);
    } else {
      setIsResendOtpTimerRunning(false);
      setResendOtpTimer(30);
    }
  }, [isOpen]);

  // Handle timer countdown
  React.useEffect(() => {
    let timer: ReturnType<typeof setInterval>;
    if (isResendOtpTimerRunning && resendOtpTimer > 0) {
      timer = setInterval(() => {
        setResendOtpTimer((prev) => {
          if (prev <= 1) {
            setIsResendOtpTimerRunning(false);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }
    return () => clearInterval(timer);
  }, [isResendOtpTimerRunning, resendOtpTimer]);

  const handleVerify = (): void => {
    if (otp.length !== 6) {
      setError('Please enter a valid 6-digit OTP');
      return;
    }
    // Verify OTP logic here
    setError(null);
    setIsOpen(false);
  };

  return (
    <Box>
      <Button onClick={() => setIsOpen(true)}>Verify Phone Number</Button>
      <ResponsiveModalWrapper
        isOpen={isOpen}
        onDismiss={() => setIsOpen(false)}
        footer={
          <Box display="flex" gap="spacing.5" justifyContent="flex-end" width="100%">
            <Button variant="tertiary" isFullWidth={isMobile} onClick={() => setIsOpen(false)}>
              Cancel
            </Button>
            <Button isFullWidth={isMobile} onClick={handleVerify} isDisabled={otp.length !== 6}>
              Verify
            </Button>
          </Box>
        }
        customSnapPoints={[0.5, 0.6, 0.75]}
      >
        <Box
          display="flex"
          justifyContent="center"
          alignItems="center"
          borderRadius="medium"
          padding="spacing.4"
          width="48px"
          height="48px"
          // backgroundColor="feedback.background.neutral.subtle"
        >
          <LockIcon color="surface.icon.gray.subtle" size="xlarge" />
        </Box>
        <Box marginTop="spacing.4" display="flex" flexDirection="column" gap="spacing.2">
          <Text size="large" weight="semibold">
            2 Step Verification
          </Text>
          <Text size="medium" weight="regular" color="surface.text.gray.subtle">
            This action requires 2-step verification. A 6-digit OTP has been sent via SMS to
            8757450923. The OTP will expire in 5 minutes.
          </Text>
        </Box>
        <Box marginY="spacing.5">
          <OTPInput
            label="Enter the code"
            otpLength={6}
            size="large"
            aria-label="Enter verification code"
            value={otp}
            onChange={(value) => setOtp(value.rawValue ?? '')}
            errorText={error ?? undefined}
          />
        </Box>
        <Box
          marginTop="spacing.5"
          display="flex"
          flexDirection="row"
          gap="spacing.2"
          justifyContent="flex-start"
          alignItems="center"
        >
          <Text size="medium" weight="regular" color="surface.text.gray.subtle">
            {isResendOtpTimerRunning
              ? `Resend OTP in ${resendOtpTimer} seconds`
              : "Didn't receive OTP?"}
          </Text>
          {!isResendOtpTimerRunning && (
            <Link
              onClick={() => {
                setIsResendOtpTimerRunning(true);
                setResendOtpTimer(30);
              }}
              size="medium"
              variant="button"
              aria-label="Resend verification code"
            >
              Resend OTP
            </Link>
          )}
        </Box>
      </ResponsiveModalWrapper>
    </Box>
  );
}

export default OTPModal;

```
### Share Modal Example

This example shows a modal for sharing content with social media options and copy link functionality.

```tsx
import React from 'react';
import {
  Box,
  Button,
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter,
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Text,
  TextInput,
  ActionList,
  ActionListItem,
  Alert,
  TwitterIcon,
  FacebookIcon,
  WhatsAppIcon,
  CopyIcon,
} from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';

// [ResponsiveModalWrapper component code remains the same as above in otp modal example]

function ResponsiveModalWrapper({
  children,
  footer,
  isOpen,
  onDismiss,
  modalBodyPadding,
  modalSize = 'small',
  wrapInBottomSheetFooter = false,
  customSnapPoints = [0.35, 0.5, 0.85],
}: {
  children: React.ReactElement | React.ReactElement[];
  footer?: React.ReactElement;
  isOpen: boolean;
  onDismiss: () => void;
  modalBodyPadding?: 'spacing.0' | 'spacing.6';
  modalSize?: 'small' | 'medium' | 'large' | 'full';
  wrapInBottomSheetFooter?: boolean;
  customSnapPoints?: [number, number, number];
}): React.ReactNode {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  if (isMobile) {
    return (
      <BottomSheet isOpen={isOpen} onDismiss={onDismiss} snapPoints={customSnapPoints}>
        <BottomSheetHeader />
        <BottomSheetBody padding="spacing.5">
          {children}
          {footer && !wrapInBottomSheetFooter && <Box marginTop="spacing.6">{footer}</Box>}
        </BottomSheetBody>
        {footer && wrapInBottomSheetFooter && <BottomSheetFooter>{footer}</BottomSheetFooter>}
      </BottomSheet>
    );
  }

  return (
    <Modal isOpen={isOpen} onDismiss={onDismiss} size={modalSize}>
      <ModalHeader />
      <ModalBody padding={modalBodyPadding}>{children}</ModalBody>
      {footer && <ModalFooter>{footer}</ModalFooter>}
    </Modal>
  );
}

function ShareModal(): React.ReactElement {
  const [isOpen, setIsOpen] = React.useState(false);
  const [showCopiedAlert, setShowCopiedAlert] = React.useState(false);

  const shareUrl = 'https://example.com/share-link';

  const shareOptions = [
    {
      icon: TwitterIcon,
      label: 'Twitter',
      url: `https://twitter.com/intent/tweet?url=${shareUrl}`,
    },
    {
      icon: FacebookIcon,
      label: 'Facebook',
      url: `https://www.facebook.com/sharer/sharer.php?u=${shareUrl}`,
    },
    { icon: WhatsAppIcon, label: 'WhatsApp', url: `https://wa.me/?text=${shareUrl}` },
  ];

  const handleShare = (url: string): void => {
    window.open(url, '_blank');
  };

  const handleCopy = async (): Promise<void> => {
    await navigator.clipboard.writeText(shareUrl);
    setShowCopiedAlert(true);
    setTimeout(() => setShowCopiedAlert(false), 3000);
  };

  return (
    <Box>
      <Button onClick={() => setIsOpen(true)}>Share</Button>
      <ResponsiveModalWrapper
        isOpen={isOpen}
        onDismiss={() => setIsOpen(false)}
        modalSize="small"
        footer={
          <Box display="flex" justifyContent="flex-end">
            <Button variant="tertiary" onClick={() => setIsOpen(false)}>
              Close
            </Button>
          </Box>
        }
      >
        <Box display="flex" flexDirection="column" gap="spacing.4">
          <Text size="large" weight="semibold">
            Share this content
          </Text>
          {showCopiedAlert && (
            <Alert
              color="positive"
              title="Link copied!"
              description="The link has been copied to your clipboard."
              isDismissible
              onDismiss={() => setShowCopiedAlert(false)}
            />
          )}
          <Box>
            <ActionList>
              {shareOptions.map((option) => (
                <ActionListItem
                  key={option.label}
                  title={option.label}
                  onClick={() => handleShare(option.url)}
                  value={option.label}
                />
              ))}
            </ActionList>
          </Box>
          <Box display="flex" gap="spacing.3">
            <TextInput value={shareUrl} accessibilityLabel="Share URL" />
            <Button
              variant="secondary"
              icon={CopyIcon}
              onClick={handleCopy}
              accessibilityLabel="Copy link"
            />
          </Box>
        </Box>
      </ResponsiveModalWrapper>
    </Box>
  );
}

export default ShareModal;

```
### Informational Modal Example

This example demonstrates a modal for displaying important information or announcements with rich content.

```tsx
import React from 'react';
import {
  Box,
  Button,
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter,
  BottomSheet,
  BottomSheetHeader,
  BottomSheetBody,
  BottomSheetFooter,
  Text,
  Heading,
  Badge,
  List,
  ListItem,
  InfoIcon,
  CheckIcon,
} from '@razorpay/blade/components';
import { useBreakpoint, useTheme } from '@razorpay/blade/utils';

// [ResponsiveModalWrapper component code remains the same as in otp modal example]

function ResponsiveModalWrapper({
  children,
  footer,
  isOpen,
  onDismiss,
  modalBodyPadding,
  modalSize = 'small',
  wrapInBottomSheetFooter = false,
  customSnapPoints = [0.35, 0.5, 0.85],
}: {
  children: React.ReactElement | React.ReactElement[];
  footer?: React.ReactElement;
  isOpen: boolean;
  onDismiss: () => void;
  modalBodyPadding?: 'spacing.0' | 'spacing.6';
  modalSize?: 'small' | 'medium' | 'large' | 'full';
  wrapInBottomSheetFooter?: boolean;
  customSnapPoints?: [number, number, number];
}): React.ReactNode {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  if (isMobile) {
    return (
      <BottomSheet isOpen={isOpen} onDismiss={onDismiss} snapPoints={customSnapPoints}>
        <BottomSheetHeader />
        <BottomSheetBody padding="spacing.5">
          {children}
          {footer && !wrapInBottomSheetFooter && <Box marginTop="spacing.6">{footer}</Box>}
        </BottomSheetBody>
        {footer && wrapInBottomSheetFooter && <BottomSheetFooter>{footer}</BottomSheetFooter>}
      </BottomSheet>
    );
  }

  return (
    <Modal isOpen={isOpen} onDismiss={onDismiss} size={modalSize}>
      <ModalHeader />
      <ModalBody padding={modalBodyPadding}>{children}</ModalBody>
      {footer && <ModalFooter>{footer}</ModalFooter>}
    </Modal>
  );
}

function InformationalModal(): React.ReactElement {
  const [isOpen, setIsOpen] = React.useState(false);
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint(theme);
  const isMobile = matchedDeviceType === 'mobile';

  const features = [
    'Enhanced security with 2FA',
    'Improved dashboard performance',
    'New analytics features',
    'Better mobile responsiveness',
  ];

  return (
    <Box>
      <Button onClick={() => setIsOpen(true)} icon={InfoIcon}>
        What's New
      </Button>
      <ResponsiveModalWrapper
        isOpen={isOpen}
        onDismiss={() => setIsOpen(false)}
        modalSize="medium"
        footer={
          <Box display="flex" gap="spacing.5" justifyContent="flex-end" width="100%">
            <Button variant="primary" isFullWidth={isMobile} onClick={() => setIsOpen(false)}>
              Got it
            </Button>
          </Box>
        }
      >
        <Box display="flex" flexDirection="column" gap="spacing.6">
          <Box display="flex" alignItems="center" gap="spacing.3">
            <Heading size="large">Platform Updates</Heading>
            <Badge color="notice">New</Badge>
          </Box>
          <Text size="medium" color="surface.text.gray.muted">
            We've made several improvements to enhance your experience. Here are the key updates:
          </Text>
          <List>
            {features.map((feature) => (
              <ListItem key={feature} icon={CheckIcon}>
                {feature}
              </ListItem>
            ))}
          </List>
          <Box
            padding="spacing.4"
            backgroundColor="surface.background.gray.subtle"
            borderRadius="medium"
          >
            <Text size="small" color="surface.text.gray.muted">
              These updates are now live. For more details, please visit our documentation.
            </Text>
          </Box>
        </Box>
      </ResponsiveModalWrapper>
    </Box>
  );
}

export default InformationalModal;
```

---

## Morph

## Component Name

Morph

## Description

The Morph component provides smooth animations for transitioning between different UI states. It's an abstraction of Framer Motion's layout animations, allowing elements to morph seamlessly from one state to another. This is particularly useful for creating fluid user experiences when elements need to change position, size, or appearance. Morph works best when animating between similar components or position changes, though complex transformations may sometimes cause distortions. It should be used inside framer-motion's AnimatePresence

## TypeScript Types

These types represent the props that the component accepts. When using the Morph component, you'll need to understand these types to properly configure the animation behavior.

```typescript
type MorphProps = {
  /**
   * The React element to be morphed.
   * This should be a single React element that will animate to/from another element with the same layoutId.
   */
  children: React.ReactElement;

  /**
   * A unique identifier to connect elements that should morph between each other.
   * Elements with the same layoutId will smoothly animate from one to the other when one is removed and the other is added.
   */
  layoutId: string;
};
```

## Example

### Basic Transformation Example

```tsx
import { Morph } from '@razorpay/blade/components';
import { Button, TextInput, Box, Link } from '@razorpay/blade/components';
import { useState } from 'react';
import { AnimatePresence } from 'framer-motion';

function ButtonToInputMorphExample() {
  const [showNameInput, setShowNameInput] = useState(false);

  return (
    <Box minHeight="100px">
      <AnimatePresence>
        {!showNameInput ? (
          <Morph layoutId="button-to-input-morph">
            <Button onClick={() => setShowNameInput(true)}>Click to Enter Name</Button>
          </Morph>
        ) : (
          <Morph layoutId="button-to-input-morph">
            <Box display="block" width="240px">
              <TextInput
                autoFocus
                accessibilityLabel="Name"
                placeholder="Enter your Name"
                trailingButton={
                  <Link onClick={() => setShowNameInput(false)} variant="button">
                    Submit
                  </Link>
                }
              />
            </Box>
          </Morph>
        )}
      </AnimatePresence>
    </Box>
  );
}
```

### Shape and Style Morphing

```tsx
import { Morph } from '@razorpay/blade/components';
import { Box, Button } from '@razorpay/blade/components';
import { useState } from 'react';
import { AnimatePresence } from 'framer-motion';

function ShapeMorphExample() {
  const [isCircle, setIsCircle] = useState(true);

  return (
    <Box>
      <Button marginBottom="spacing.4" onClick={() => setIsCircle(!isCircle)}>
        Toggle Shape
      </Button>

      <AnimatePresence>
        {isCircle ? (
          <Morph layoutId="shape-morph">
            <Box
              height="200px"
              width="200px"
              borderRadius="round"
              backgroundColor="surface.background.primary.intense"
            />
          </Morph>
        ) : (
          <Morph layoutId="shape-morph">
            <Box
              height="200px"
              width="200px"
              borderRadius="none"
              borderWidth="thick"
              borderColor="surface.border.gray.muted"
            />
          </Morph>
        )}
      </AnimatePresence>
    </Box>
  );
}
```

### Interactive Button State Change

```tsx
import { Morph } from '@razorpay/blade/components';
import { Button, Box } from '@razorpay/blade/components';
import { useState } from 'react';
import { AnimatePresence } from 'framer-motion';

function DangerousButtonMorphExample() {
  const [shouldConfirm, setShouldConfirm] = useState(false);

  return (
    <Box>
      <AnimatePresence>
        {shouldConfirm ? (
          <Morph layoutId="button-morph">
            <Button color="negative" onClick={() => setShouldConfirm(false)}>
              Confirm Deletion
            </Button>
          </Morph>
        ) : (
          <Morph layoutId="button-morph">
            <Button variant="secondary" onClick={() => setShouldConfirm(true)}>
              Delete This
            </Button>
          </Morph>
        )}
      </AnimatePresence>
    </Box>
  );
}
```

---

## Move

## Component Name

Move

## Description

The Move component is a motion preset that animates the opacity and position of its children, allowing them to smoothly appear or disappear in the UI. It creates a subtle upward movement combined with a fade-in/fade-out effect to ensure seamless transitions while keeping the UI visually engaging. This component is ideal for adding motion to cards, forms, or any other elements that appear and disappear from the interface.

## TypeScript Types

These types represent the props that the component accepts. When using the Move component, you'll need to understand these types to properly configure the animation behavior.

```typescript
type MoveProps = {
  /**
   * The React element(s) to be animated
   */
  children: React.ReactElement;

  /**
   * Whether component should animate in, animate out, or animate both in and out
   *
   * With type="in", component will only animate in but immediately be removed on exit without animation
   * With type="out", component will only animate out but immediately mount on enter without animation
   * With type="inout", component animates in and out both
   *
   * @default 'inout'
   */
  type?: 'in' | 'out' | 'inout';

  /**
   * Handle visibility of motion component.
   *
   * By default components animate on mount but if you want to mount/unmount them, use this prop instead
   */
  isVisible?: boolean;

  /**
   * Values:
   * - mount: Component animates when it mounts
   * - in-view: Component animates when its in view of the scroll
   * - focus: Component animates in when its in focus
   * - on-animate-interactions: Component animates based on motionTriggers of <AnimateInteractions /> component
   *
   * @default ['mount']
   */
  motionTriggers?: ('mount' | 'in-view' | 'focus' | 'on-animate-interactions')[];

  /**
   * By default components are only made opacity: 0. When this prop is set to true, components will unmount and be removed from the page.
   *
   * **Warn:** Setting this true might cause layout shifts in your page since component will be removed so do check it once and add minHeight to its container
   *
   * @default false
   */
  shouldUnmountWhenHidden?: boolean;

  /**
   * Handles delay of animations
   *
   * @default undefined
   */
  delay?: MotionDelay;
};

// MotionDelay can be a simple delay token or an object with separate enter/exit delays
type MotionDelay = keyof Delay | { enter: keyof Delay; exit: keyof Delay };
```

## Example

### Basic Usage

This example demonstrates the basic implementation of the Move component to create a subtle animation effect for a card that appears with combined fade and movement animation when the component first mounts.

```tsx
import { Move } from '@razorpay/blade/components';
import { Card, CardBody, CardHeader, CardHeaderLeading } from '@razorpay/blade/components';
import { Text } from '@razorpay/blade/components';

function BasicMoveExample() {
  return (
    <Move motionTriggers={['mount']}>
      <Card>
        <CardHeader>
          <CardHeaderLeading title="Welcome to Razorpay" subtitle="Get started with payments" />
        </CardHeader>
        <CardBody>
          <Text>This card animates in with a smooth motion when the component mounts.</Text>
        </CardBody>
      </Card>
    </Move>
  );
}
```

---

## OTPInput

## Component Name

OTPInput

## Description

OTPInput is a specialized input component for collecting one-time passwords or verification codes. It presents a sequence of individual input fields (typically 4 or 6) where each field accepts a single character. The component supports both controlled and uncontrolled modes, auto-focusing between fields, masking for secure inputs, and validation states to provide feedback during verification processes.

## TypeScript Types

The following types define the props that the OTPInput component accepts. These types are essential for proper usage of the component in TypeScript projects.

```typescript
type FormInputOnEventWithIndex = ({
  name,
  value,
  inputIndex,
}: {
  name?: string;
  value?: string;
  inputIndex: number;
}) => void;

type OTPInputCommonProps = {
  /**
   * Determines the number of input fields to show for the OTP
   * @default 6
   */
  otpLength?: 4 | 6;

  /**
   * The callback function to be invoked when all the values of the OTPInput are filled
   */
  onOTPFilled?: ({ name, value }: { name?: string; value?: string }) => void;

  /**
   * Masks input characters in all the fields
   */
  isMasked?: boolean;

  /**
   * Determines what autoComplete suggestion type to show. Defaults to `oneTimeCode`.
   * It's not recommended to turn this off in favor of otp input practices.
   */
  autoCompleteSuggestionType?: 'none' | 'oneTimeCode';

  /**
   * The callback function to be invoked when one of the input fields gets focus
   */
  onFocus?: FormInputOnEventWithIndex;

  /**
   * The callback function to be invoked when one of the input fields is blurred
   */
  onBlur?: FormInputOnEventWithIndex;

  /* Common input props */
  label?: string;
  accessibilityLabel?: string;
  labelPosition?: 'top' | 'left';
  validationState?: 'none' | 'error' | 'success';
  helpText?: string;
  errorText?: string;
  successText?: string;
  name?: string;
  onChange?: ({ name, value }: { name?: string; value?: string }) => void;
  value?: string;
  isDisabled?: boolean;
  autoFocus?: boolean;
  keyboardReturnKeyType?: 'default' | 'go' | 'done' | 'next' | 'search' | 'send';
  keyboardType?: 'text' | 'search' | 'telephone' | 'email' | 'url' | 'decimal';
  placeholder?: string;
  testID?: string;
  size?: 'medium' | 'large';
} & DataAnalyticsAttribute &
  StyledPropsBlade;

type OTPInputPropsWithA11yLabel = {
  /**
   * Label to be shown for the input field
   */
  label?: undefined;
  /**
   * Accessibility label for the input
   */
  accessibilityLabel: string;
} & OTPInputCommonProps;

type OTPInputPropsWithLabel = {
  /**
   * Label to be shown for the input field
   */
  label: string;
  /**
   * Accessibility label for the input
   */
  accessibilityLabel?: string;
} & OTPInputCommonProps;

type OTPInputProps = OTPInputPropsWithA11yLabel | OTPInputPropsWithLabel;
```

## Example

### Basic OTP Input with Validation

This example shows a basic OTP verification flow with different states based on the input validation.

```tsx
import { useState, useEffect } from 'react';
import { OTPInput, Box, Button, Text } from '@razorpay/blade/components';

function OTPVerificationExample() {
  const [otp, setOtp] = useState('');
  const [validationState, setValidationState] = useState<'none' | 'error' | 'success'>('none');
  const [isVerifying, setIsVerifying] = useState(false);
  const [attempts, setAttempts] = useState(0);

  // Mock verification - in real apps, this would call your API
  const verifyOTP = () => {
    setIsVerifying(true);

    // Simulate API call delay
    setTimeout(() => {
      if (otp === '123456') {
        setValidationState('success');
      } else {
        setValidationState('error');
        setAttempts((prev) => prev + 1);
      }
      setIsVerifying(false);
    }, 1000);
  };

  // Reset validation state when OTP changes
  useEffect(() => {
    if (otp && validationState !== 'none') {
      setValidationState('none');
    }
  }, [otp]);

  return (
    <Box width="100%" maxWidth="568px">
      <OTPInput
        label="Verification Code"
        name="verificationCode"
        otpLength={6}
        value={otp}
        onChange={({ value }) => setOtp(value || '')}
        onOTPFilled={({ value }) => {
          console.log('OTP filled:', value);
          setOtp(value || '');
        }}
        validationState={validationState}
        errorText={
          attempts >= 3
            ? 'Too many incorrect attempts. Please request a new code.'
            : 'Incorrect verification code. Please try again.'
        }
        successText="Verification successful!"
        helpText="Enter the 6-digit code sent to your phone"
        autoFocus={true}
        size="medium"
        keyboardType="decimal"
        autoCompleteSuggestionType="oneTimeCode"
        data-analytics-section="verification"
        data-analytics-field="otp-input"
      />

      <Button
        onClick={verifyOTP}
        isLoading={isVerifying}
        isDisabled={otp.length !== 6 || isVerifying || attempts >= 3}
        marginBottom="spacing.3"
      >
        Verify
      </Button>

      {attempts > 0 && (
        <Text size="small" color="feedback.text.negative.intense">
          Attempts: {attempts}/3
        </Text>
      )}
    </Box>
  );
}
```

### Secure PIN Input with Masking

This example demonstrates using OTPInput for PIN entry with masked input for enhanced security.

```tsx
import { useState, useRef } from 'react';
import { OTPInput, Box, Button, Text } from '@razorpay/blade/components';

function SecurePINEntryExample() {
  const [pin, setPin] = useState('');
  const [confirmPin, setConfirmPin] = useState('');
  const [step, setStep] = useState('create');
  const confirmInputRef = useRef(null);

  const handlePinChange = ({ value }) => {
    setPin(value || '');
  };

  const handleConfirmPinChange = ({ value }) => {
    setConfirmPin(value || '');
  };

  const handleContinue = () => {
    if (step === 'create') {
      setStep('confirm');
      // Focus on first input of confirm PIN field
      setTimeout(() => {
        confirmInputRef.current?.[0]?.focus();
      }, 100);
    } else if (pin === confirmPin) {
      setStep('success');
    } else {
      setStep('mismatch');
    }
  };

  const resetForm = () => {
    setPin('');
    setConfirmPin('');
    setStep('create');
  };

  return (
    <Box
      width="100%"
      maxWidth="450px"
      padding="spacing.5"
      backgroundColor="surface.background.gray.subtle"
      borderRadius="medium"
    >
      <Text size="large" weight="semibold">
        {step === 'success' ? 'PIN Created Successfully' : 'Create Transaction PIN'}
      </Text>

      {step !== 'success' && (
        <>
          <Box marginBottom="spacing.5">
            <OTPInput
              label="Enter PIN"
              name="pin"
              otpLength={4}
              value={pin}
              onChange={handlePinChange}
              onOTPFilled={handlePinChange}
              isMasked={true}
              validationState={step === 'mismatch' ? 'error' : 'none'}
              helpText="Create a 4-digit PIN for secure transactions"
              autoFocus={step === 'create'}
              size="large"
              labelPosition="top"
              autoCompleteSuggestionType="none"
              keyboardType="decimal"
              data-analytics-field="create-pin"
            />
          </Box>

          {(step === 'confirm' || step === 'mismatch') && (
            <Box marginBottom="spacing.5">
              <OTPInput
                ref={confirmInputRef}
                label="Confirm PIN"
                name="confirmPin"
                otpLength={4}
                value={confirmPin}
                onChange={handleConfirmPinChange}
                onOTPFilled={handleConfirmPinChange}
                isMasked={true}
                validationState={step === 'mismatch' ? 'error' : 'none'}
                errorText={step === 'mismatch' ? "PINs don't match" : undefined}
                helpText="Re-enter the same PIN to confirm"
                size="large"
                labelPosition="top"
                autoCompleteSuggestionType="none"
                keyboardType="decimal"
                data-analytics-field="confirm-pin"
              />
            </Box>
          )}

          <Button
            onClick={handleContinue}
            isDisabled={
              (step === 'create' && pin.length !== 4) ||
              (step === 'confirm' && confirmPin.length !== 4)
            }
            isFullWidth
          >
            {step === 'confirm' || step === 'mismatch' ? 'Confirm PIN' : 'Continue'}
          </Button>
        </>
      )}

      {step === 'success' && (
        <Box>
          <Text>Your PIN has been created. You can use it for future transactions.</Text>
          <Button onClick={resetForm} variant="secondary">
            Create New PIN
          </Button>
        </Box>
      )}
    </Box>
  );
}
```

### OTP Input with Ref and Programmatic Focus

This example shows how to use refs with OTPInput to programmatically control focus, useful for complex forms or when specific behaviors are needed.

```tsx
import { useState, useRef } from 'react';
import { OTPInput, Box, Button, Text } from '@razorpay/blade/components';

function ProgrammaticOTPExample() {
  const [otp, setOtp] = useState('');
  const [focusIndex, setFocusIndex] = useState(0);
  const otpInputRef = useRef(null);

  const handleFocusInput = (index) => {
    if (otpInputRef.current && otpInputRef.current[index]) {
      otpInputRef.current[index].focus();
      setFocusIndex(index);
    }
  };

  const handleClear = () => {
    setOtp('');
    // Focus on first input after clearing
    handleFocusInput(0);
  };

  return (
    <Box width="100%" maxWidth="568px">
      <Text>Current focus position: {focusIndex + 1} of 6</Text>

      <OTPInput
        ref={otpInputRef}
        label="One-time Password"
        accessibilityLabel="Enter your one-time password"
        name="otpCode"
        value={otp}
        onChange={({ value }) => setOtp(value || '')}
        onFocus={({ inputIndex }) => setFocusIndex(inputIndex)}
        helpText="Use the buttons below to manipulate input focus"
        size="medium"
        otpLength={6}
        data-analytics-field="otp-with-ref"
      />

      <Box display="flex" gap="spacing.3" marginBottom="spacing.4">
        <Button onClick={() => handleFocusInput(0)} variant="secondary" size="small">
          Focus 1st
        </Button>
        <Button onClick={() => handleFocusInput(2)} variant="secondary" size="small">
          Focus 3rd
        </Button>
        <Button onClick={() => handleFocusInput(5)} variant="secondary" size="small">
          Focus Last
        </Button>
        <Button onClick={handleClear} variant="tertiary" size="small">
          Clear
        </Button>
      </Box>

      <Text size="small">
        Note: The OTPInput ref exposes an array of input references that can be used to
        programmatically focus specific inputs.
      </Text>
    </Box>
  );
}
```

---

## Pagination

## Component Name

Pagination

## Description

Pagination is a navigation component that allows users to navigate through multiple pages of content. It provides page number navigation buttons, page size selection dropdown, and direct page jumping capabilities with ellipsis for large page ranges. The component supports both controlled and uncontrolled modes for page and page size state management, and automatically adapts its UI for mobile devices by hiding certain features like page size picker, page number selector, and labels.

## Important Constraints

- Pages are 1-indexed externally (1 is the first page, 2 is the second page, etc.) - the `selectedPage` and `defaultSelectedPage` props use 1-based indexing
- `pageSize` can only be one of: `10`, `25`, or `50`
- `defaultPageSize` can only be one of: `10`, `25`, or `50`
- When both `selectedPage` and `defaultSelectedPage` are provided, `selectedPage` takes precedence (controlled mode)
- When both `pageSize` and `defaultPageSize` are provided, `pageSize` takes precedence (controlled mode)
- `showPageSizePicker`, `showPageNumberSelector`, and `showLabel` are always hidden on mobile devices
- `showPageNumberSelector` only displays when `totalPages > 1`
- If `totalPages` is not provided, the component defaults to 1 total page

## TypeScript Types

The following types represent the props that the Pagination component accepts. These types allow you to properly configure pagination according to your needs.

```typescript
type DataAnalyticsKey = `data-analytics-${string}`;

type DataAnalyticsAttribute = {
  [key: DataAnalyticsKey]: string;
};

type PaginationCommonProps = {
  /**
   * Total pages in the pagination.
   */
  totalPages?: number;

  /**
   * Current active page (1-indexed).
   * When provided, the component is controlled.
   * When not provided, the component is uncontrolled and manages its own state.
   * @default undefined (uncontrolled)
   */
  selectedPage?: number;

  /**
   * Default page when uncontrolled (1-indexed, where 1 is the first page).
   * Only used when selectedPage is not provided.
   * @default 1
   */
  defaultSelectedPage?: number;

  /**
   * Callback fired when the page is changed.
   * The page parameter is 1-indexed.
   */
  onSelectedPageChange?: ({ page }: { page: number }) => void;

  /**
   * The default page size.
   * Page size controls how items are shown per page.
   * @default 10
   */
  defaultPageSize?: 10 | 25 | 50;

  /**
   * Current page size when controlled.
   * When provided, the page size is controlled.
   * When not provided, the component manages page size internally.
   * @default 10
   */
  pageSize?: 10 | 25 | 50;

  /**
   * Callback function that is called when the page size is changed.
   */
  onPageSizeChange?: ({ pageSize }: { pageSize: number }) => void;

  /**
   * Whether to show the page size picker. It will be always hidden on mobile.
   * Page size picker controls how items are shown per page.
   * @default false
   */
  showPageSizePicker?: boolean;

  /**
   * Whether to show the page number selector. It will be always hidden on mobile.
   * Page number selectors is a group of buttons that allows the user to jump to a specific page.
   * @default false
   */
  showPageNumberSelector?: boolean;

  /**
   * Content of the label to be shown in the pagination component.
   * If not provided, a default label will be shown based on current page and page size.
   */
  label?: string;

  /**
   * Whether to show the label. It will be always hidden on mobile.
   * @default false
   */
  showLabel?: boolean;

  /**
   * Whether the pagination component is disabled.
   * @default false
   */
  isDisabled?: boolean;
} & DataAnalyticsAttribute;

type PaginationProps = PaginationCommonProps & {
  /**
   * The label to be shown in the page size picker.
   * @default 'items / page'
   */
  pageSizeLabel?: string;
};
```

## Example

### Controlled Pagination with All Features

This example demonstrates a fully controlled pagination component with all features enabled including page navigation, page size selection, page number selector with ellipsis for large page ranges, and custom label. It shows how to handle controlled state for both page and page size, with proper event handlers and accessibility considerations.

```typescript
import { Pagination } from '@razorpay/blade/components';
import { useState } from 'react';

function ControlledPaginationExample() {
  const [selectedPage, setSelectedPage] = useState(1);
  const [pageSize, setPageSize] = useState<10 | 25 | 50>(10);
  const totalItems = 1000;
  const totalPages = Math.ceil(totalItems / pageSize);

  return (
    <Pagination
      totalPages={totalPages}
      selectedPage={selectedPage}
      pageSize={pageSize}
      onSelectedPageChange={({ page }) => setSelectedPage(page)}
      onPageSizeChange={({ pageSize }) => setPageSize(pageSize as 10 | 25 | 50)}
      showPageSizePicker
      showPageNumberSelector
      showLabel
      label={`Showing ${(selectedPage - 1) * pageSize + 1}-${Math.min(
        selectedPage * pageSize,
        totalItems,
      )} of ${totalItems} items`}
      pageSizeLabel="items / page"
      isDisabled={false}
    />
  );
}
```

---

## PasswordInput

## Component Name

PasswordInput

## Description

PasswordInput is a secure input field designed for entering passwords. It masks the input by default and provides an optional reveal button to toggle visibility, enhancing user experience and security. The component supports accessibility features, validation states, character limits, and integrates seamlessly with browser autofill and password managers. It is highly configurable, supporting various sizes, disabled and required states, and can be used in both controlled and uncontrolled forms.

## TypeScript Types

Below are the TypeScript types for the `PasswordInput` component and its relevant subcomponents. These types represent the props that the component and its subcomponents accept. Refer to these when using `PasswordInput` in your application to ensure correct usage and type safety.

### PasswordInput Types

```ts
// PasswordInput.tsx

export type PasswordInputProps = (
  | {
      /**
       * Label to be shown for the input field
       */
      label?: undefined;
      /**
       * Accessibility label for the input
       */
      accessibilityLabel: string;
    }
  | {
      /**
       * Label to be shown for the input field
       */
      label: string;
      /**
       * Accessibility label for the input
       */
      accessibilityLabel?: string;
    }
) & {
  /**
   * Shows a reveal button to toggle password visibility
   * @default true
   */
  showRevealButton?: boolean;
  /**
   * Displays asterisk (`*`) when `isRequired` is enabled
   * @default none
   */
  necessityIndicator?: 'required' | 'none';
  /**
   * Determines what autoComplete suggestion type to show. Defaults to using platform heuristics.
   * It's not recommended to turn this off in favor of safe password practices.
   * Providing `password` or `newPassword` is more informative to the platform for browser autofill or password managers.
   * **Note**: Using `newPassword` on iOS has some [known issue](https://github.com/facebook/react-native/issues/21911) on React Native
   */
  autoCompleteSuggestionType?: 'none' | 'password' | 'newPassword';
  labelPosition?: 'left' | 'top';
  maxCharacters?: number;
  validationState?: 'success' | 'error' | 'none';
  errorText?: string;
  successText?: string;
  helpText?: string;
  isDisabled?: boolean;
  defaultValue?: string;
  placeholder?: string;
  isRequired?: boolean;
  value?: string;
  onChange?: (args: { name?: string; value?: string }) => void;
  onBlur?: (args: { name?: string; value?: string }) => void;
  onSubmit?: (args: { name?: string; value?: string }) => void;
  onFocus?: (args: { name?: string; value?: string }) => void;
  name?: string;
  autoFocus?: boolean;
  keyboardReturnKeyType?: 'default' | 'go' | 'done' | 'next' | 'previous' | 'search' | 'send';
  testID?: string;
  size?: 'medium' | 'large';
  alignSelf?: string;
  display?: string;
  justifySelf?: string;
  placeSelf?: string;
  order?: number;
  position?: string;
  zIndex?: number;
  gridColumn?: string;
  gridColumnStart?: string;
  gridColumnEnd?: string;
  gridRow?: string;
  gridRowStart?: string;
  gridRowEnd?: string;
  gridArea?: string;
  margin?: string;
  marginX?: string;
  marginY?: string;
  marginBottom?: string;
  marginTop?: string;
  marginRight?: string;
  marginLeft?: string;
  top?: string;
  right?: string;
  bottom?: string;
  left?: string;
  visibility?: string;
} & StyledPropsBlade &
  DataAnalyticsAttribute;
```

### CharacterCounter Subcomponent

```ts
// CharacterCounter.tsx

type CharacterCounterProps = {
  currentCount: number;
  maxCount: number;
  size?: 'medium' | 'large';
};
```

### IconButton Subcomponent

```ts
// IconButton.tsx

type IconButtonProps = {
  icon: React.ComponentType<any>;
  size?: 'small' | 'medium' | 'large';
  emphasis?: 'intense' | 'subtle';
  accessibilityLabel: string;
  isDisabled?: boolean;
  _tabIndex?: number;
  onClick: (
    event: React.MouseEvent<HTMLButtonElement> | import('react-native').GestureResponderEvent,
  ) => void;
  isHighlighted?: boolean;
  [key: `data-analytics-${string}`]: string;
  // StyledPropsBlade and BladeCommonEvents are also supported
};
```

## Example

### Comprehensive PasswordInput Usage

This example demonstrates a practical usage of `PasswordInput` with various props combined, including accessibility, validation, character limit, disabled state, required state, and autofill hints. It also shows how to use the component in a controlled form scenario.

```tsx
import React, { useState, useRef } from 'react';
import { PasswordInput, Button, Box } from '@razorpay/blade/components';

export default function PasswordInputExample() {
  const [password, setPassword] = useState('');

  return (
    <Box display="flex" flexDirection="column" gap="spacing.5" maxWidth="400px">
      <PasswordInput
        label="Create Password"
        accessibilityLabel="Password"
        helpText="Password must be at least 8 characters."
        placeholder="Enter a strong password"
        maxCharacters={16}
        value={password}
        onChange={({ value }) => setPassword(value || '')}
        validationState={
          password.length > 0 && password.length < 8
            ? 'error'
            : password.length >= 8
            ? 'success'
            : 'none'
        }
        errorText={password.length > 0 && password.length < 8 ? 'Password is too short' : ''}
        successText={password.length >= 8 ? 'Strong password' : ''}
        showRevealButton
        isRequired
        necessityIndicator="required"
        autoCompleteSuggestionType="newPassword"
        size="large"
        testID="password-input"
        marginBottom="spacing.4"
      />

      <PasswordInput
        accessibilityLabel="Password without visible label"
        placeholder="No label visible"
        helpText="This input uses only accessibility label."
      />
    </Box>
  );
}
```

---

## PhoneNumberInput

## Component Name

PhoneNumberInput

## Description

PhoneNumberInput is a specialized input component for collecting and validating international phone numbers. It features a country selector with flags, dial code display, and proper formatting based on the selected country. This component is ideal for forms requiring phone number validation across different regions, offering both controlled and uncontrolled usage patterns.

## TypeScript Types

The following types define the props that the PhoneNumberInput component accepts. These types are essential for proper usage of the component in TypeScript projects.

```typescript
import type { CountryCodeType } from '@razorpay/i18nify-js';

type PhoneNumberInputProps = {
  /**
   * Default value of the input, Used to set the default value of input field when it's uncontrolled
   */
  defaultValue?: string;
  /**
   * Value of the input, Used to turn the input field to controlled so user can control the value
   */
  value?: string;
  /**
   * The default country code to be used in the input.
   * Uncontrolled state of the country code.
   *
   * @default "IN" or autodetect based on the user's locale
   */
  defaultCountry?: CountryCodeType;
  /**
   * Controlled state of the country code to be used in the input.
   */
  country?: CountryCodeType;
  /**
   * Callback that is called when the country is selected from the country selector.
   */
  onCountryChange?: ({ country }: { country: CountryCodeType }) => void;
  /**
   * List of countries to be shown in the country selector.
   */
  allowedCountries?: CountryCodeType[];
  /**
   * Callback that is called when the value of the input changes.
   */
  onChange?: (event: {
    /**
     * formatted phone number with dial code
     *
     * @example: "+91 123456789"
     */
    phoneNumber: string;
    /**
     * dial code of the country
     *
     * @example: 91 for India
     */
    dialCode: string;
    /**
     * country code of the country
     *
     * @example: "IN" for India
     */
    country: CountryCodeType;
    /**
     * raw value of the input
     */
    value: string;
    /**
     * name of the input
     */
    name: string;
  }) => void;
  /**
   * If true, the dial code text will be shown in the leading text.
   *
   * @default true
   */
  showDialCode?: boolean;
  /**
   * If true, the country selector will be shown.
   *
   * @default true
   */
  showCountrySelector?: boolean;
  /**
   * Callback that is called when the clear button is clicked.
   */
  onClearButtonClick?: () => void;

  /* Common input props */
  size?: 'medium' | 'large';
  label?: string;
  accessibilityLabel?: string;
  labelPosition?: 'top' | 'left';
  helpText?: string;
  placeholder?: string;
  name?: string;
  validationState?: 'none' | 'error' | 'success';
  errorText?: string;
  successText?: string;
  necessityIndicator?: 'optional' | 'required';
  isRequired?: boolean;
  isDisabled?: boolean;
  autoFocus?: boolean;
  keyboardReturnKeyType?: 'default' | 'go' | 'done' | 'next' | 'search' | 'send';
  leadingIcon?: React.ComponentType<any>;
  trailingIcon?: React.ComponentType<any>;
  testID?: string;
  autoCompleteSuggestionType?: 'none' | 'telephone' | 'oneTimeCode';
} & DataAnalyticsAttribute &
  StyledPropsBlade;
```

## Example

### Basic Phone Number Input

This example demonstrates a simple phone number input with validation and country selection.

```tsx
import { useState } from 'react';
import { PhoneNumberInput, Box } from '@razorpay/blade/components';
import { isValidPhoneNumber } from '@razorpay/i18nify-js';
import type { CountryCodeType } from '@razorpay/i18nify-js';

function PhoneNumberInputExample() {
  const [phoneData, setPhoneData] = useState({
    value: '',
    country: 'IN' as CountryCodeType,
    isValid: true
  });

  const handleChange = ({ value, country, phoneNumber }) => {
    const isValid = value ? isValidPhoneNumber(value, country) : true;

    setPhoneData({
      value,
      country,
      isValid
    });

    console.log('Formatted phone number:', phoneNumber);
  };

  return (
    <Box width="100%" maxWidth="400px">
      <PhoneNumberInput
        label="Phone Number"
        name="phoneNumber"
        defaultCountry="IN"
        value={phoneData.value}
        onChange={handleChange}
        onCountryChange={({ country }) => {
          setPhoneData(prev => ({
            ...prev,
            country,
            isValid: prev.value ? isValidPhoneNumber(prev.value, country) : true
          }));
        }}
        validationState={phoneData.isValid ? 'none' : 'error'}
        errorText="Please enter a valid phone number"
        helpText="We'll use this to send you important updates"
        necessityIndicator="required"
        size="medium"
        data-analytics-field="phone-number"
        marginBottom="spacing.4"
      />
    </Box>
  );
}
```

### Advanced Configuration Options

This example shows a more complex usage with restricted countries, custom styling, and different display options.

```tsx
import { useState } from 'react';
import {
  PhoneNumberInput,
  Box,
  Text,
  PhoneIcon,
  Button
} from '@razorpay/blade/components';
import type { CountryCodeType } from '@razorpay/i18nify-js';

function AdvancedPhoneNumberExample() {
  const [phoneData, setPhoneData] = useState({
    phoneNumber: '',
    dialCode: '',
    country: 'US' as CountryCodeType
  });

  // List of allowed countries
  const allowedCountries: CountryCodeType[] = ['US', 'CA', 'GB', 'AU', 'IN'];

  const handlePhoneChange = ({ phoneNumber, dialCode, country, value }) => {
    setPhoneData({
      phoneNumber,
      dialCode,
      country
    });
    console.log('Raw input value:', value);
  };

  const handleSubmit = () => {
    alert(`Submitting phone: ${phoneData.phoneNumber}`);
  };

  return (
    <Box
      padding="spacing.5"
      backgroundColor="surface.background.gray.subtle"
      borderRadius="medium"
      width="100%"
      maxWidth="450px"
    >
      <Text size="large" weight="semibold" marginBottom="spacing.4">
        Contact Information
      </Text>

      <Box marginBottom="spacing.5">
        <PhoneNumberInput
          label="Mobile Number"
          name="mobileNumber"
          leadingIcon={PhoneIcon}
          country={phoneData.country}
          onChange={handlePhoneChange}
          onCountryChange={({ country }) => {
            setPhoneData(prev => ({
              ...prev,
              country
            }));
          }}
          allowedCountries={allowedCountries}
          size="large"
          showDialCode={true}
          accessibilityLabel="Enter your mobile number"
          data-analytics-section="contact-form"
          data-analytics-field="mobile-number"
        />
      </Box>

      <Box marginBottom="spacing.4">
        <Text size="small">
          Selected country: {phoneData.country}, Dial code: {phoneData.dialCode}
        </Text>
      </Box>

      <Button onClick={handleSubmit} isDisabled={!phoneData.phoneNumber}>
        Continue
      </Button>
    </Box>
  );
}
```

### Without Country Selector or Dial Code

This example demonstrates how to use PhoneNumberInput with simplified configuration, hiding the country selector and dial code for specific use cases.

```tsx
import { useState } from 'react';
import { PhoneNumberInput, Box, Text } from '@razorpay/blade/components';

function SimplifiedPhoneNumberExample() {
  const [value, setValue] = useState('');

  return (
    <Box width="100%" maxWidth="400px">
      <Text size="medium" marginBottom="spacing.3">
        National Phone Number Input
      </Text>

      <PhoneNumberInput
        label="Phone Number (India)"
        defaultCountry="IN"
        onChange={({ value }) => setValue(value)}
        showCountrySelector={false}
        showDialCode={false}
        placeholder="Enter 10-digit number"
        helpText="For Indian numbers only (e.g., 9876543210)"
        size="medium"
        data-analytics-field="local-phone"
      />
    </Box>
  );
}
```

### Form Integration with Validation

This example shows how to integrate PhoneNumberInput into a form with proper validation and error handling.

```tsx
import { useState } from 'react';
import {
  PhoneNumberInput,
  TextInput,
  Box,
  Button
} from '@razorpay/blade/components';
import { isValidPhoneNumber } from '@razorpay/i18nify-js';
import type { CountryCodeType } from '@razorpay/i18nify-js';

function ContactFormExample() {
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    phoneNumber: '',
    country: 'IN' as CountryCodeType
  });

  const [errors, setErrors] = useState({
    firstName: '',
    lastName: '',
    phoneNumber: ''
  });

  const validateForm = () => {
    const newErrors = {
      firstName: !formData.firstName ? 'First name is required' : '',
      lastName: !formData.lastName ? 'Last name is required' : '',
      phoneNumber: !formData.phoneNumber
        ? 'Phone number is required'
        : !isValidPhoneNumber(formData.phoneNumber, formData.country)
          ? 'Invalid phone number for selected country'
          : ''
    };

    setErrors(newErrors);
    return !Object.values(newErrors).some(error => error);
  };

  const handleSubmit = () => {
    if (validateForm()) {
      console.log('Form submitted:', formData);
      alert('Form submitted successfully!');
    }
  };

  return (
    <Box
      display="flex"
      flexDirection="column"
      gap="spacing.4"
      width="100%"
      maxWidth="500px"
      padding="spacing.5"
      backgroundColor="surface.background.gray.intense"
      borderRadius="medium"
    >
      <Box display="flex" gap="spacing.4">
        <TextInput
          label="First Name"
          name="firstName"
          value={formData.firstName}
          onChange={({ value }) => {
            setFormData(prev => ({ ...prev, firstName: value || '' }));
            if (value) setErrors(prev => ({ ...prev, firstName: '' }));
          }}
          validationState={errors.firstName ? 'error' : 'none'}
          errorText={errors.firstName}
          isRequired={true}
          data-analytics-field="first-name"
        />

        <TextInput
          label="Last Name"
          name="lastName"
          value={formData.lastName}
          onChange={({ value }) => {
            setFormData(prev => ({ ...prev, lastName: value || '' }));
            if (value) setErrors(prev => ({ ...prev, lastName: '' }));
          }}
          validationState={errors.lastName ? 'error' : 'none'}
          errorText={errors.lastName}
          isRequired={true}
          data-analytics-field="last-name"
        />
      </Box>

      <PhoneNumberInput
        label="Phone Number"
        name="phoneNumber"
        country={formData.country}
        value={formData.phoneNumber}
        onChange={({ value, country }) => {
          setFormData(prev => ({
            ...prev,
            phoneNumber: value || '',
            country
          }));

          if (value && isValidPhoneNumber(value, country)) {
            setErrors(prev => ({ ...prev, phoneNumber: '' }));
          }
        }}
        onCountryChange={({ country }) => {
          setFormData(prev => ({ ...prev, country }));

          if (formData.phoneNumber && isValidPhoneNumber(formData.phoneNumber, country)) {
            setErrors(prev => ({ ...prev, phoneNumber: '' }));
          } else if (formData.phoneNumber) {
            setErrors(prev => ({ ...prev, phoneNumber: 'Invalid phone number for selected country' }));
          }
        }}
        validationState={errors.phoneNumber ? 'error' : 'none'}
        errorText={errors.phoneNumber}
        isRequired={true}
        size="medium"
        necessityIndicator="required"
        data-analytics-field="phone-number"
      />

      <Box marginTop="spacing.2">
        <Button onClick={handleSubmit} variant="primary" size="medium">
          Submit
        </Button>
      </Box>
    </Box>
  );
}
```

---

## Popover

## Component Name

Popover

## Description

The Popover component displays additional context or interactive content that appears when a user interacts with a trigger element. It typically provides contextual information or actions without requiring navigation to a different page. Popovers are designed with a subtle appearance, can be positioned in various placements, and support both controlled and uncontrolled usage patterns.

## TypeScript Types

The following types are the props that the Popover component and its subcomponents accept. Use these types as a reference when implementing Popover in your application.

```typescript
import type { UseFloatingOptions } from '@floating-ui/react';
import type React from 'react';
import type { DataAnalyticsAttribute } from '~utils/types';

// Main Popover component props
type PopoverProps = {
  /**
   * Popover title
   */
  title?: string;
  /**
   * Leading content placed before the title
   *
   * Can be any blade icon or asset.
   */
  titleLeading?: React.ReactNode;
  /**
   * Footer content
   */
  footer?: React.ReactNode;
  /**
   * Popover content
   */
  content: React.ReactElement;
  /**
   * Placement of Popover
   *
   * @default "top"
   */
  placement?: UseFloatingOptions['placement'];
  /**
   * Popover trigger
   */
  children: React.ReactElement;
  /**
   * Open state of Popover
   * If set to true makes the popover controlled
   */
  isOpen?: boolean;
  /**
   * Uncontrolled state of the popover
   */
  defaultIsOpen?: boolean;
  /**
   * Called when popover open state is changed, this can be used to detect when popover opens or closed
   */
  onOpenChange?: ({ isOpen }: { isOpen: boolean }) => void;
  /**
   * Sets the z-index of the Popover
   * @default 1000
   */
  zIndex?: number;
  /**
   * The ref of the element that should receive focus when the popover opens.
   *
   * @default PopoverCloseButton
   */
  initialFocusRef?: React.RefObject<any>;
  /**
   * Should popover open on click or hover
   *
   * @default 'click'
   */
  openInteraction?: 'hover' | 'click';
} & DataAnalyticsAttribute;

// For when creating custom trigger components
type PopoverTriggerProps = {
  onMouseDown?: React.MouseEventHandler;
  onPointerDown?: React.PointerEventHandler;
  onKeyDown?: React.KeyboardEventHandler;
  onKeyUp?: React.KeyboardEventHandler;
  onClick?: React.MouseEventHandler;
  onTouchEnd?: React.TouchEventHandler;
};

// Props for the PopoverInteractiveWrapper component
type PopoverInteractiveWrapperProps = {
  /**
   * A label for screen readers to announce when the popover is opened.
   */
  accessibilityLabel?: string;
  /**
   * The content of the PopoverInteractiveWrapper.
   */
  children?: React.ReactNode;
  onClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
  onKeyDown?: (event: React.KeyboardEvent<HTMLButtonElement>) => void;
} & Omit<BaseBoxProps, 'as'> &
  DataAnalyticsAttribute;
```

## Example

### Basic Usage

Here's a comprehensive example showing how to use the Popover component with its various props:

```tsx
import React from 'react';
import { Popover, Button, Box, Text, InfoIcon } from '@razorpay/blade/components';

const App = () => {
  return (
    <Box padding="spacing.5">
      {/* Popover with title and icon */}
      <Box marginBottom="spacing.5">
        <Text weight="semibold" size="large" marginBottom="spacing.3">
          Popover with Title and Icon
        </Text>
        <Popover
          title="Settlement breakup"
          titleLeading={<InfoIcon color="interactive.icon.gray.normal" size="medium" />}
          content={
            <Box padding="spacing.2">
              <Text>Detailed information about the settlement goes here.</Text>
            </Box>
          }
          placement="right"
        >
          <Button variant="secondary">View Settlement</Button>
        </Popover>
      </Box>
    </Box>
  );
};

export default App;
```

### Popover on Non Interactive Elements

You can add Popover to non-interactive elements like Icon, Badge, etc using PopoverInteractiveWrapper

```tsx
import React from 'react';
import {
  Popover,
  PopoverInteractiveWrapper,
  Box,
  Text,
  InfoIcon,
} from '@razorpay/blade/components';

const App = () => {
  return (
    <Box marginBottom="spacing.5">
      <Text weight="semibold" size="large" marginBottom="spacing.3">
        Using PopoverInteractiveWrapper
      </Text>
      <Box display="flex" flexDirection="row" alignItems="center" gap="spacing.3">
        <Popover
          title="Information"
          content={<Text>This icon triggers a popover.</Text>}
          placement="top"
        >
          <PopoverInteractiveWrapper
            display="inline-block"
            accessibilityLabel="View more information"
          >
            <InfoIcon color="interactive.icon.gray.normal" size="large" />
          </PopoverInteractiveWrapper>
        </Popover>
      </Box>
    </Box>
  );
};

export default App;
```

### Creating a Custom Trigger Component

You can create custom trigger components for the Popover by forwarding the necessary props:

```tsx
import React from 'react';
import {
  Popover,
  Box,
  Text,
  type PopoverTriggerProps
} from '@razorpay/blade/components';

// Custom trigger component with forwardRef
const CustomTrigger = React.forwardRef<
  HTMLDivElement,
  { children: string } & PopoverTriggerProps
>(({ children, ...props }, ref) => {
  return (
    <Box
      backgroundColor="surface.background.gray.intense"
      padding="spacing.5"
      borderRadius="medium"
      tabIndex={0}
      ref={ref}
      {...props} // Forward all required props
    >
      {children}
    </Box>
  );
});

const CustomTriggerExample = () => {
  return (
    <Popover
      title="Custom Trigger Example"
      content={<Text>This popover is triggered by a custom component.</Text>}
      placement="top"
    >
      <CustomTrigger>Click me to open popover</CustomTrigger>
    </Popover>
  );
};

export default CustomTriggerExample;
```

---

## Preview

# Preview

## Description

The Preview component is a versatile file preview component that provides a container for displaying various types of content with zoom and drag capabilities. It consists of three main subcomponents: PreviewHeader, PreviewBody, and PreviewFooter. The component supports features like zooming, dragging, full-screen mode, and customizable headers and footers. It's particularly useful for displaying images, PDFs, and other content that requires interactive viewing capabilities.

## TypeScript Types

Below are the TypeScript types that define the props for the Preview component and its subcomponents. These types are essential for understanding what props each component accepts and how to use them effectively.

```typescript
type PreviewProps = {
  /**
   * The children of the Preview component.
   */
  children: React.ReactElement | React.ReactElement[];
  /**
   * The function to call when the full screen button is clicked.
   */
  onFullScreen?: () => void;
  /**
   * Whether the drag and zoom is disabled.
   */
  isDragAndZoomDisabled?: boolean;
  /**
   * The initial zoom of the Preview component.
   */
  defaultZoom?: number;
  /**
   * The function to call when the zoom changes.
   */
  onZoomChange?: (newZoom: number) => void;
  /**
   * The function to call when the drag changes.
   */
  onDragChange?: (position: { x: number; y: number }) => void;
  /**
   * The step of the zoom.
   */
  zoomScaleStep?: number;
};

type PreviewHeaderProps = {
  /**
   * The title of the PreviewHeader component.
   */
  title?: string;
  /**
   * The trailing of the PreviewHeader component.
   */
  trailing?: React.ReactElement | React.ReactElement[];
};

type PreviewBodyProps = {
  /**
   * The children of the PreviewBody component.
   */
  children: React.ReactElement;
};

type PreviewFooterProps = {
  /**
   * The trailing of the PreviewFooter component.
   */
  trailing?: React.ReactElement;
  /**
   * Whether to show the zoom percentage.
   */
  showZoomPercentage?: boolean;
};
```

## Example

Here are comprehensive examples showing different use cases of the Preview component:

### Basic Image Preview

```tsx
import { Preview, PreviewHeader, PreviewBody, PreviewFooter } from '@razorpay/blade/components';

function ImagePreview() {
  return (
    <Preview>
      <PreviewHeader title="Image Preview" />
      <PreviewBody>
        <img width="100%" height="100%" src="https://example.com/image.jpg" alt="Preview image" />
      </PreviewBody>
      <PreviewFooter showZoomPercentage={true} />
    </Preview>
  );
}
```

### PDF Preview with Navigation

```tsx
import { Preview, PreviewHeader, PreviewBody, PreviewFooter } from '@razorpay/blade/components';
import { Document, Page } from 'react-pdf';
import { Button } from '@razorpay/blade/components';
import { ArrowLeftIcon, ArrowRightIcon } from '@razorpay/blade/components';
import { useState } from 'react';

function PDFPreview() {
  const [currentPage, setCurrentPage] = useState(1);

  return (
    <Preview defaultZoom={1.5} onZoomChange={(zoom) => console.log('Zoom level:', zoom)}>
      <PreviewHeader title="PDF Document" trailing={<Button>Download</Button>} />
      <PreviewBody>
        <Document file="https://example.com/document.pdf">
          <Page pageNumber={currentPage} width={800} height={700} />
        </Document>
      </PreviewBody>
      <PreviewFooter
        showZoomPercentage={true}
        trailing={
          <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
            <Button
              icon={ArrowLeftIcon}
              onClick={() => setCurrentPage((prev) => Math.max(1, prev - 1))}
              variant="tertiary"
              aria-label="Previous page"
              isDisabled={currentPage <= 1}
            />
            <span>Page {currentPage}</span>
            <Button
              icon={ArrowRightIcon}
              onClick={() => setCurrentPage((prev) => prev + 1)}
              variant="tertiary"
              aria-label="Next page"
            />
          </div>
        }
      />
    </Preview>
  );
}
```

### Disabled Drag and Zoom Preview

```tsx
import { Preview, PreviewHeader, PreviewBody } from '@razorpay/blade/components';

function StaticPreview() {
  return (
    <Preview isDragAndZoomDisabled={true}>
      <PreviewHeader title="Static Preview" />
      <PreviewBody>
        <img
          width="100%"
          height="100%"
          src="https://example.com/image.jpg"
          alt="Static preview image"
        />
      </PreviewBody>
    </Preview>
  );
}
```

---

## ProgressBar

## Component Name

ProgressBar

## Description

A ProgressBar is a visual indicator that displays the progress of a process or task. It can be used to show determinate progress (with a known completion percentage) or indeterminate progress (when the completion time is unknown). The component offers different variants including linear and circular styles, and can be configured as either a progress indicator or a meter depending on the use case.

## Important Constraints

- `isIndeterminate` cannot be set when `type="meter"`
- `isIndeterminate` cannot be set when `variant="circular"`
- `size="large"` is not available when `variant="linear"`
- When `type` prop is set, `variant` can only be `"linear"` or `"circular"` (not `"progress"` or `"meter"`)

## TypeScript Types

These types represent the props that the component accepts. When using the ProgressBar component, you'll need to understand these types to properly configure it.

```typescript
type ProgressBarCommonProps = {
  /**
   * Sets aria-label to help users know what the progress bar is for. Default value is the same as the `label` passed.
   */
  accessibilityLabel?: string;
  /**
   * Sets the color of the progress bar which changes the feedback color.
   */
  color?: FeedbackColors;
  /**
   * Sets the type of the progress bar.
   * @default 'progress'
   */
  type?: 'meter' | 'progress';
  /**
   * Sets the label to be rendered for the progress bar. This value will also be used as default for `accessibilityLabel`.
   */
  label?: string;
  /**
   * Sets the size of the progress bar.
   * Note: 'large' size isn't available when the variant is 'linear'.
   * @default 'small'
   */
  size?: 'small' | 'medium' | 'large';
  /**
   * Sets the progress value of the progress bar.
   */
  value?: number;
  /**
   * Sets the minimum value for the progress bar.
   * @default 0
   */
  min?: number;
  /**
   * Sets the maximum value for the progress bar.
   * @default 100
   */
  max?: number;
} & TestID &
  DataAnalyticsAttribute &
  StyledPropsBlade;

type ProgressBarVariant = 'progress' | 'meter' | 'linear' | 'circular';

type ProgressBarProgressProps = ProgressBarCommonProps & {
  /**
   * Sets the variant to be rendered for the progress bar.
   * @default 'progress'
   */
  variant?: Extract<ProgressBarVariant, 'progress' | 'linear' | 'circular'>;
  /**
   * Sets whether the progress bar is in an indeterminate state.
   * @default false
   */
  isIndeterminate?: boolean;
  /**
   * Sets whether or not to show the progress percentage for the progress bar. Percentage is hidden by default for the `meter` variant.
   * @default true
   */
  showPercentage?: boolean;
};

type ProgressBarMeterProps = ProgressBarCommonProps & {
  /**
   * Sets the variant to be rendered for thr progress bar.
   * @default 'progress'
   */
  variant?: Extract<ProgressBarVariant, 'meter' | 'linear' | 'circular'>;
  /**
   * Sets whether the progress bar is in an indeterminate state.
   * @default false
   */
  isIndeterminate?: undefined;
  /**
   * Sets whether or not to show the progress percentage for the progress bar. Percentage is hidden by default for the `meter` variant.
   * @default false
   */
  showPercentage?: undefined;
};

type ProgressBarProps = ProgressBarProgressProps | ProgressBarMeterProps;
```

## Example

### Basic Usage

```tsx
import { ProgressBar } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';

function BasicProgressBarExample() {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.6">
      {/* Simple progress bar */}
      <ProgressBar label="Loading data" value={60} size="medium" />

      {/* Circular progress bar */}
      <ProgressBar label="Upload progress" value={75} variant="circular" size="medium" />
    </Box>
  );
}
```

### Dynamic Progress

```tsx
import { ProgressBar } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';
import { useState, useEffect } from 'react';

function DynamicProgressExample() {
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setProgress((prevProgress) => {
        if (prevProgress >= 100) {
          clearInterval(interval);
          return 100;
        }
        return prevProgress + 5;
      });
    }, 500);

    return () => clearInterval(interval);
  }, []);

  return (
    <Box display="flex" flexDirection="column" gap="spacing.6">
      <ProgressBar
        label={`File upload (${progress}%)`}
        value={progress}
        color="positive"
        size="medium"
      />

      <ProgressBar
        label="Circular progress"
        value={progress}
        variant="circular"
        color="information"
        size="large"
      />
    </Box>
  );
}
```

---

## QuickFilter

## Component Name

QuickFilter & QuickFilterGroup

## Description

QuickFilter and QuickFilterGroup components provide a user-friendly interface for displaying and selecting filterable options. They allow users to make single or multiple selections from a set of predefined filters, often displaying counts or other trailing elements. Ideal for dashboards, search interfaces, or any scenario where users need to filter data quickly.

## TypeScript Types

These types represent the props that the component accepts. When using the QuickFilter component along with QuickFilterGroup, you'll need to understand these types to properly configure them.

```typescript
type QuickFilterProps = {
  /*
      title is a string that is displayed as the title of the quick filter.
  */
  title: string;
  /*
        value is a string that is displayed as the value of the quick filter.
  */
  value: string;
  /*
        trailing is a React node that is displayed after the quick filter.
  */
  trailing?: React.ReactNode;
} & TestID &
  DataAnalyticsAttribute;

type QuickFilterGroupProps = {
  /**
   * Specifies the name attribute for the component.
   * When provided, this attribute ensures that the QuickFilter elements within the group are semantically associated, allowing them to be grouped logically for form submission.
   * This can be particularly useful in scenarios where the QuickFilter is part of a larger form and needs to be identified as a distinct entity when the form is submitted.
   * If not provided, a default unique identifier will be generated internally.
   */
  name?: string;
  /**
   * Sets the initial value of the QuickFilter component.
   */
  defaultValue?: string | string[];
  /**
   * Value of the QuickFilter group
   * Acts as a controlled component by specifying the QuickFilter value
   * Use `onChange` to update its value
   */
  value?: string | string[];
  /*
   onChange is a function that is called when the selected quick filter changes.
   it returns an object with the name of the quick filter group and the values of the selected quick filters.
  */
  onChange?: ({ name, values }: { name: string; values: string[] }) => void;
  /*
     selectionType is a string that can be either 'single' or 'multiple'.
  */
  selectionType: 'single' | 'multiple';
  /*
       children is an array of QuickFilter components.
  */
  children: React.ReactNode;
} & TestID &
  DataAnalyticsAttribute;

type QuickFilterContentProps = Pick<QuickFilterProps, 'trailing' | 'value' | 'title'> &
  Pick<QuickFilterGroupProps, 'selectionType'> &
  TestID &
  DataAnalyticsAttribute & {
    isSelected?: boolean;
  };

type QuickFilterGroupContextType = Pick<QuickFilterGroupProps, 'selectionType'> & {
  selectedQuickFilters: string[];
};
```

## Example

### Basic Usage

This example demonstrates a single-selection QuickFilter group with three filter options, each displaying a Counter component in the trailing position to show the number of items in each category.

```tsx
import { QuickFilterGroup, QuickFilter } from '@razorpay/blade/components';
import { Counter } from '@razorpay/blade/components';

function BasicQuickFilterExample() {
  const handleFilterChange = ({ name, values }) => {
    console.log(`Filter group ${name} has selected values: ${values.join(', ')}`);
  };

  return (
    <QuickFilterGroup selectionType="single" onChange={handleFilterChange}>
      <QuickFilter title="All" value="all" trailing={<Counter value={400} color="information" />} />
      <QuickFilter
        title="Captured"
        value="captured"
        trailing={<Counter value={234} color="positive" />}
      />
      <QuickFilter
        title="Failed"
        value="failed"
        trailing={<Counter value={166} color="negative" />}
      />
    </QuickFilterGroup>
  );
}
```

---

## Radio

## Component Name

Radio & RadioGroup

## Description

The Radio and RadioGroup components are used in forms when a user needs to select a single value from multiple options. RadioGroup serves as a container for Radio components, allowing users to make a single selection from a set of options. It handles state management and provides accessible markup with features like validation states, help text, and various size options.

## Important Constraints

- `Radio` component cannot be used outside of `RadioGroup` component
- `RadioGroup` component only accepts `Radio` components as children

Make sure to only follow structure as given in the examples below. Fragments are also not allowed as children in these components.

## TypeScript Types

These types represent the props that the component accepts. When using the Radio component along with RadioGroup, you'll need to understand these types to properly configure them.

```typescript
type RadioProps = {
  /**
   * Sets the label text of the Radio
   */
  children?: StringChildrenType;
  /**
   * Help text for the Radio
   */
  helpText?: string;
  /**
   * The value to be used in the Radio input.
   * This is the value that will be returned on form submission.
   */
  value: string;
  /**
   * If `true`, the Radio will be disabled
   *
   * @default false
   */
  isDisabled?: boolean;
  /**
   * Size of the radios
   *
   * @default "medium"
   */
  size?: 'small' | 'medium' | 'large';
} & TestID &
  DataAnalyticsAttribute &
  StyledPropsBlade &
  MotionMetaProp;

type RadioGroupProps = {
  /**
   * Accepts multiple radios as children
   */
  children: React.ReactNode;
  /**
   * Help text of the radio group
   */
  helpText?: string;
  /**
   * Error text of the radio group
   * Renders when `validationState` is set to 'error'
   *
   * Overrides helpText
   */
  errorText?: string;
  /**
   * Sets the error state of the radioGroup
   * If set to `error` it will render the `errorText` of the group,
   * and propagate `invalid` prop to every radio
   */
  validationState?: 'error' | 'none';
  /**
   * Renders a necessity indicator after radioGroup label
   *
   * If set to `undefined` it renders nothing.
   */
  necessityIndicator?: 'required' | 'optional' | 'none';
  /**
   * Sets the disabled state of the radioGroup
   * If set to `true` it propagate down to all the radios
   *
   * @default false
   */
  isDisabled?: boolean;
  /**
   * Sets the required state of the radioGroup
   * @default false
   */
  isRequired?: boolean;
  /**
   * Renders the label of the radio group
   */
  label?: string;
  /**
   * Sets the position of the label
   *
   * @default 'top'
   */
  labelPosition?: 'top' | 'left';
  /**
   * Initial value of the radio group
   */
  defaultValue?: string;
  /**
   * value of the radio group
   *
   * Use `onChange` to update its value
   */
  value?: string;
  /**
   * The callback invoked when any of the radio's state changes
   */
  onChange?: ({
    name,
    value,
    event,
  }: {
    name: string | undefined;
    value: string;
    event: React.ChangeEvent<HTMLInputElement>;
  }) => void;
  /**
   * The name of the input field in a radio
   * (Useful for form submission).
   */
  name?: string;
  /**
   * Size of the radios
   *
   * @default "medium"
   */
  size?: 'small' | 'medium' | 'large';
} & TestID &
  DataAnalyticsAttribute &
  StyledPropsBlade;

type OnChange = ({
  isChecked,
  event,
  value,
}: {
  isChecked: boolean;
  event: React.ChangeEvent;
  value?: string;
}) => void;

type RadioGroupContextType = Pick<
  RadioGroupProps,
  | 'validationState'
  | 'isDisabled'
  | 'isRequired'
  | 'labelPosition'
  | 'name'
  | 'defaultValue'
  | 'value'
  | 'onChange'
  | 'necessityIndicator'
  | 'size'
> & { state?: State };
```

## Example

### Basic Usage

This example demonstrates a standard RadioGroup with multiple Radio options of different sizes and states, including disabled options and help text.

```tsx
import { RadioGroup, Radio } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';

function BasicRadioExample() {
  const handleChange = ({ name, value }) => {
    console.log(`Selected ${value} for ${name}`);
  };

  return (
    <Box gap="spacing.5">
      {/* Standard RadioGroup with different sizes and states */}
      <RadioGroup
        label="Where do you want to collect payments?"
        helpText="Select only one option"
        name="payment-collection"
        onChange={handleChange}
        defaultValue="website"
        necessityIndicator="required"
      >
        <Radio value="website">Website</Radio>
        <Radio value="android">Android App</Radio>
        <Radio value="ios">iOS App</Radio>
        <Radio value="social-media" helpText="Like WhatsApp, Facebook, Instagram">
          Social Media
        </Radio>
        <Radio value="offline-store" isDisabled>
          Offline Store
        </Radio>
      </RadioGroup>
    </Box>
  );
}
```

### Controlled Radio Example

This example shows how to implement a controlled RadioGroup where the selected value is managed through React state, with the selection reflected in the help text.

```tsx
import { RadioGroup, Radio } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';
import { useState } from 'react';

function ControlledRadioExample() {
  const [selected, setSelected] = useState('apple');

  return (
    <Box>
      <RadioGroup
        label="Select your favorite fruit"
        helpText={`You selected: ${selected}`}
        name="fruits"
        value={selected}
        onChange={({ value }) => setSelected(value)}
        size="medium"
        labelPosition="left"
      >
        <Radio value="apple" helpText="Apples are 25% air">
          Apple
        </Radio>
        <Radio value="mango" helpText="The name 'mango' originated in India">
          Mango
        </Radio>
        <Radio value="orange" helpText="There are over 600 varieties of oranges">
          Orange
        </Radio>
      </RadioGroup>
    </Box>
  );
}
```

---

## Scale

## Component Name

Scale

## Description

The Scale component is a motion preset that animates elements by changing their size through CSS scale property. It allows you to enlarge or shrink elements based on user interactions like hover or focus, or through controlled state changes. Scale is perfect for providing subtle feedback when users interact with clickable elements or for highlighting important content.

## TypeScript Types

These types define the props that the Scale component accepts, allowing you to configure how elements scale up or down.

```typescript
type ScaleProps = {
  /**
   * React children to be animated.
   */
  children: React.ReactElement;

  /**
   * Controlled state of scaling. If you want to scale up on hover / focus, etc, checkout `motionTriggers` prop instead.
   *
   * This is when you want to scale up / scale down conditionally
   *
   * With `isHighlighted={true}`, your component will be in scaled state
   * With `isHighlighted={false}`, your component will be in normal state
   */
  isHighlighted?: boolean;

  /**
   * Whether to scale up or scale down the component
   *
   * @default 'scale-up'
   */
  variant?: 'scale-up' | 'scale-down';

  /**
   * Specifies what triggers the animation.
   * Common triggers include:
   * - mount: Animates when component mounts
   * - hover: Animates when component is hovered
   * - tap: Animates when component is tapped/clicked
   * - focus: Animates when component receives focus
   *
   * @default ['hover'] when isHighlighted is not provided
   * @default ['mount'] when isHighlighted is provided
   */
  motionTriggers?: MotionTriggersType[];

  /**
   * Sets whether component should animate in, out, or both.
   * - in: Only animates in, immediately removed on exit
   * - out: Only animates out, immediately appears on enter
   * - inout: Animates both in and out
   *
   * @default 'inout'
   */
  type?: 'in' | 'out' | 'inout';
};
```

## Example

### Basic Usage

This example demonstrates the Scale component's basic functionality with two cards - one that scales up on hover and another that scales down on click, showing different motion triggers and scaling variants.

```tsx
import {
  Scale,
  Card,
  CardBody,
  CardHeader,
  CardHeaderLeading,
  Text,
  Box,
} from '@razorpay/blade/components';

function BasicScaleExample() {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.8">
      {/* Default Scale (scales up on hover) */}
      <Scale motionTriggers={['hover']}>
        <Card width="300px">
          <CardHeader>
            <CardHeaderLeading title="Hover me" />
          </CardHeader>
          <CardBody>
            <Text>This card scales up when you hover over it.</Text>
          </CardBody>
        </Card>
      </Scale>

      {/* Scale down on tap/click */}
      <Scale variant="scale-down" motionTriggers={['tap']}>
        <Card width="300px">
          <CardHeader>
            <CardHeaderLeading title="Click me" />
          </CardHeader>
          <CardBody>
            <Text>This card scales down when you click on it.</Text>
          </CardBody>
        </Card>
      </Scale>
    </Box>
  );
}
```

### Controlled Scaling

This example shows how to implement controlled scaling with a toggle button, demonstrating both scale-up and scale-down variants side by side that respond to state changes rather than direct user interactions.

```tsx
import { useState } from 'react';
import {
  Scale,
  Box,
  Button,
  Card,
  CardBody,
  CardHeader,
  CardHeaderLeading,
  Text,
} from '@razorpay/blade/components';

function ControlledScaleExample() {
  const [isHighlighted, setIsHighlighted] = useState(false);

  return (
    <Box>
      <Button marginBottom="spacing.6" onClick={() => setIsHighlighted(!isHighlighted)}>
        Toggle Scale
      </Button>

      <Box display="flex" gap="spacing.6">
        {/* Scale up when isHighlighted is true */}
        <Box width="300px">
          <Text marginBottom="spacing.2">Scale Up</Text>
          <Scale isHighlighted={isHighlighted}>
            <Card>
              <CardHeader>
                <CardHeaderLeading title="Controlled Scale Up" />
              </CardHeader>
              <CardBody>
                <Text>This card scales up when the toggle button is clicked.</Text>
              </CardBody>
            </Card>
          </Scale>
        </Box>

        {/* Scale down when isHighlighted is true */}
        <Box width="300px">
          <Text marginBottom="spacing.2">Scale Down</Text>
          <Scale isHighlighted={isHighlighted} variant="scale-down">
            <Card>
              <CardHeader>
                <CardHeaderLeading title="Controlled Scale Down" />
              </CardHeader>
              <CardBody>
                <Text>This card scales down when the toggle button is clicked.</Text>
              </CardBody>
            </Card>
          </Scale>
        </Box>
      </Box>
    </Box>
  );
}
```

---

## SearchInput

## Component Name

SearchInput

## Description

SearchInput is a specialized input component designed for search functionality. It features a built-in search icon, clear button, and loading state, making it ideal for search interfaces, filters, and global application search. The component integrates with Dropdown for displaying search results and can be used within other components like tables for filtering data.

## TypeScript Types

The following types define the props that the SearchInput component accepts. These types are essential for proper usage of the component in TypeScript projects.

```typescript
type SearchInputSizes = 'medium' | 'large';

type SearchInputCommonProps = {
  label?: string;
  accessibilityLabel?: string;
  labelPosition?: 'top' | 'left';
  helpText?: string;
  placeholder?: string;
  defaultValue?: string;
  name?: string;
  onChange?: ({ name, value }: { name?: string; value?: string }) => void;
  onFocus?: ({ name, value }: { name?: string; value?: string }) => void;
  onBlur?: ({ name, value }: { name?: string; value?: string }) => void;
  value?: string;
  isDisabled?: boolean;
  autoFocus?: boolean;
  onSubmit?: ({ name, value }: { name?: string; value?: string }) => void;
  autoCapitalize?: 'none' | 'sentences' | 'words' | 'characters';
  testID?: string;
  onClick?: ({ name, value }: { name?: string; value?: string }) => void;
  size?: SearchInputSizes;
  onClearButtonClick?: () => void;
  isLoading?: boolean;
  showSearchIcon?: boolean;
} & DataAnalyticsAttribute &
  StyledPropsBlade;

type SearchInputPropsWithA11yLabel = {
  label?: undefined;
  accessibilityLabel: string;
} & SearchInputCommonProps;

type SearchInputPropsWithLabel = {
  label: string;
  accessibilityLabel?: string;
} & SearchInputCommonProps;

type SearchInputProps = SearchInputPropsWithA11yLabel | SearchInputPropsWithLabel;
```

## Example

### Basic Search Input

This example demonstrates a basic search input with label and help text, showing the most common usage pattern.

```tsx
import { useState } from 'react';
import { SearchInput, Box } from '@razorpay/blade/components';

function BasicSearchExample() {
  const [searchValue, setSearchValue] = useState('');

  const handleChange = ({ value }) => {
    setSearchValue(value || '');
    console.log('Searching for:', value);
  };

  const handleClear = () => {
    console.log('Search cleared');
  };

  return (
    <Box marginBottom="spacing.4">
      <SearchInput
        label="Search Products"
        placeholder="Search for products, categories, or SKUs"
        name="productSearch"
        value={searchValue}
        onChange={handleChange}
        onClearButtonClick={handleClear}
        helpText="Enter product name or SKU code"
        size="medium"
        data-analytics-section="product-catalog"
        data-analytics-action="search"
      />
    </Box>
  );
}
```

### Search Input with Dropdown Results

This example shows how to integrate SearchInput with Dropdown to display search results, demonstrating a common pattern for global search functionality.

```tsx
import { useState, useEffect } from 'react';
import {
  SearchInput,
  Box,
  Dropdown,
  DropdownOverlay,
  ActionList,
  ActionListItem,
  ActionListSection,
  ActionListItemIcon,
  Spinner,
  TransactionsIcon,
  SettingsIcon,
  UserIcon,
  HelpCircleIcon,
} from '@razorpay/blade/components';

function SearchWithDropdownExample() {
  const [searchTerm, setSearchTerm] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  // Mock data for search results
  const searchItems: Array<{
    id: string;
    title: string;
    icon: React.ComponentType<any>;
    category: string;
  }> = [
    { id: '1', title: 'Transactions', icon: TransactionsIcon, category: 'pages' },
    { id: '2', title: 'Settings', icon: SettingsIcon, category: 'pages' },
    { id: '3', title: 'Profile', icon: UserIcon, category: 'pages' },
    { id: '4', title: 'Help Center', icon: HelpCircleIcon, category: 'support' },
  ];

  // Simulate loading state when searching
  useEffect(() => {
    if (searchTerm) {
      setIsLoading(true);
      const timer = setTimeout(() => setIsLoading(false), 800);
      return () => clearTimeout(timer);
    }
  }, [searchTerm]);

  // Filter items based on search term
  const filteredItems = searchTerm
    ? searchItems.filter((item) => item.title.toLowerCase().includes(searchTerm.toLowerCase()))
    : searchItems;

  // Group items by category
  const groupedItems: Record<string, typeof searchItems> = filteredItems.reduce((acc, item) => {
    acc[item.category] = acc[item.category] || [];
    acc[item.category].push(item);
    return acc;
  }, {} as Record<string, typeof searchItems>);

  return (
    <Box width="400px">
      <Dropdown>
        <SearchInput
          accessibilityLabel="Global Search"
          placeholder="Search pages, settings and more"
          name="globalSearch"
          onChange={({ value }) => setSearchTerm(value || '')}
          isLoading={isLoading}
          autoCapitalize="none"
          size="large"
          showSearchIcon={true}
          data-analytics-section="global-search"
        />

        <DropdownOverlay>
          {isLoading ? (
            <Box display="flex" justifyContent="center" padding="spacing.4">
              <Spinner accessibilityLabel="Loading search results" />
            </Box>
          ) : filteredItems.length === 0 ? (
            <Box padding="spacing.4">
              No results found for "{searchTerm}"
            </Box>
          ) : (
            <ActionList>
              {Object.entries(groupedItems).map(([category, items]) => (
                <ActionListSection
                  key={category}
                  title={category === 'pages' ? 'Pages' : 'Support'}
                >
                  {items.map((item) => (
                    <ActionListItem
                      key={item.id}
                      title={item.title}
                      value={item.id}
                      leading={<ActionListItemIcon icon={item.icon} />}
                      onClick={() => console.log(`Selected: ${item.title}`)}
                    />
                  ))}
                </ActionListSection>
              ))}
            </ActionList>
          )}
        </DropdownOverlay>
      </Dropdown>
    </Box>
  );
}
```

---

## SelectInput

## Component Name

SelectInput

## Description

SelectInput is a dropdown trigger component that functions as the equivalent of the HTML `<select>` element in Blade Design System. It must be used within a Dropdown component and works with ActionList to create selectable options. SelectInput provides a clean interface for single or multiple item selection with full keyboard accessibility and rich styling options.

## TypeScript Types

The following types define the props that the SelectInput component accepts. These types are essential for proper usage of the component in TypeScript projects.

```typescript
type SelectInputProps = {
  /**
   * Label to be shown for the input field
   */
  label?: string;

  /**
   * Accessibility label for the input
   */
  accessibilityLabel?: string;

  /**
   * Position of the label.
   * Can be 'top', 'left', or 'inside-input'
   */
  labelPosition?: 'top' | 'left' | 'inside-input';

  /**
   * Indicates whether the field is optional or required
   */
  necessityIndicator?: 'optional' | 'required';

  /**
   * Validation state of the input
   */
  validationState?: 'none' | 'error' | 'success';

  /**
   * Help text to be displayed below the input
   */
  helpText?: string;

  /**
   * Error text to be displayed when validationState is 'error'
   */
  errorText?: string;

  /**
   * Success text to be displayed when validationState is 'success'
   */
  successText?: string;

  /**
   * Name of the input field
   */
  name?: string;

  /**
   * Whether the input is disabled
   */
  isDisabled?: boolean;

  /**
   * Whether the input is required
   */
  isRequired?: boolean;

  /**
   * Prefix text to be displayed before the value
   */
  prefix?: string;

  /**
   * Suffix text to be displayed after the value
   */
  suffix?: string;

  /**
   * Slot to be rendered adjacent to the value
   */
  valueSuffix?: ({ values }: { values: string[] }) => React.ReactNode;

  /**
   * Whether the input should be focused on mount
   */
  autoFocus?: boolean;

  /**
   * Callback that is called when the input is clicked
   */
  onClick?: ({ name, value }: { name?: string; value?: string }) => void;

  /**
   * Callback that is called when the input receives focus
   */
  onFocus?: ({ name, value }: { name?: string; value?: string }) => void;

  /**
   * Callback that is called when the input loses focus
   */
  onBlur?: ({ name, value }: { name?: string; value?: string }) => void;

  /**
   * Placeholder text to be displayed when no value is selected
   */
  placeholder?: string;

  /**
   * Test ID for testing
   */
  testID?: string;

  /**
   * Size of the input
   */
  size?: 'medium' | 'large';

  /**
   * Icon to be displayed at the beginning of the input
   */
  icon?: React.ComponentType<any>;

  /**
   * Controlled value of the Select. Use it in combination of `onChange`.
   */
  value?: string | string[];

  /**
   * Used to set the default value of SelectInput when it's uncontrolled.
   */
  defaultValue?: string | string[];

  /**
   * Callback that is called when the selection changes
   */
  onChange?: ({ name, values }: { name?: string; values: string[] }) => void;

  /**
   * Constraints the height of input to given number rows
   * @default 'single'
   */
  maxRows?: 'single' | 'multiple' | 'expandable';
} & DataAnalyticsAttribute;
```

## Example

### Basic SelectInput with Single Selection

This example demonstrates a basic SelectInput with single selection, showing how to use it within a Dropdown component.

```tsx
import { useState } from 'react';
import {
  Dropdown,
  DropdownOverlay,
  SelectInput,
  ActionList,
  ActionListItem,
  Box,
  Text,
  UserIcon,
} from '@razorpay/blade/components';

function BasicSelectExample() {
  const [selectedUser, setSelectedUser] = useState('');

  const handleUserChange = ({ values }) => {
    setSelectedUser(values[0] || '');
  };

  return (
    <Box width="100%" maxWidth="400px">
      <Text marginBottom="spacing.4">Selected user: {selectedUser || 'None'}</Text>

      <Dropdown selectionType="single">
        <SelectInput
          label="Select User"
          name="user"
          placeholder="Choose a user"
          icon={UserIcon}
          onChange={handleUserChange}
          helpText="Select a user to view their profile"
          necessityIndicator="required"
          size="medium"
          data-analytics-section="user-selection"
        />
        <DropdownOverlay>
          <ActionList>
            <ActionListItem title="John Doe" value="john" />
            <ActionListItem title="Jane Smith" value="jane" />
            <ActionListItem title="Robert Johnson" value="robert" />
            <ActionListItem title="Emily Davis" value="emily" />
          </ActionList>
        </DropdownOverlay>
      </Dropdown>
    </Box>
  );
}
```

### SelectInput with Multiple Selection and Validation

This example shows how to implement a SelectInput with multiple selection capability along with validation states.

```tsx
import { useState, useEffect } from 'react';
import {
  Dropdown,
  DropdownOverlay,
  SelectInput,
  ActionList,
  ActionListItem,
  ActionListSection,
  Box,
  Button,
  TagIcon,
} from '@razorpay/blade/components';

function MultiSelectWithValidationExample(): React.ReactElement {
  const [selectedCategories, setSelectedCategories] = useState<string[]>([]);
  const [validationState, setValidationState] = useState<'none' | 'error' | 'success'>('none');

  // Validate whenever selection changes
  useEffect(() => {
    if (selectedCategories.length === 0) {
      setValidationState('error');
    } else if (selectedCategories.length > 3) {
      setValidationState('error');
    } else {
      setValidationState('success');
    }
  }, [selectedCategories]);

  const handleCategoryChange = ({ values }: { values: string[] }): void => {
    setSelectedCategories(values);
  };

  const handleSubmit = (): void => {
    if (validationState === 'success') {
      // eslint-disable-next-line no-alert
      alert(`Selected categories: ${selectedCategories.join(', ')}`);
    }
  };

  return (
    <Box
      width="100%"
      maxWidth="450px"
      padding="spacing.5"
      backgroundColor="surface.background.gray.subtle"
      borderRadius="medium"
    >
      <Dropdown selectionType="multiple">
        <SelectInput
          label="Product Categories"
          name="categories"
          placeholder="Select categories"
          icon={TagIcon}
          value={selectedCategories}
          onChange={handleCategoryChange}
          validationState={validationState}
          errorText={
            selectedCategories.length === 0
              ? 'At least one category is required'
              : 'Maximum 3 categories allowed'
          }
          successText={`${selectedCategories.length} categories selected`}
          maxRows="multiple"
          isRequired={true}
          size="large"
          data-analytics-field="product-categories"
        />
        <DropdownOverlay>
          <ActionList>
            <ActionListSection title="Electronics">
              <ActionListItem title="Smartphones" value="smartphones" />
              <ActionListItem title="Laptops" value="laptops" />
              <ActionListItem title="Accessories" value="accessories" />
            </ActionListSection>
            <ActionListSection title="Clothing">
              <ActionListItem title="Men's Wear" value="mens-wear" />
              <ActionListItem title="Women's Wear" value="womens-wear" />
              <ActionListItem title="Children's Wear" value="childrens-wear" />
            </ActionListSection>
            <ActionListSection title="Home">
              <ActionListItem title="Furniture" value="furniture" />
              <ActionListItem title="Decor" value="decor" />
              <ActionListItem title="Kitchen" value="kitchen" />
            </ActionListSection>
          </ActionList>
        </DropdownOverlay>
      </Dropdown>

      <Button
        marginTop="spacing.4"
        onClick={handleSubmit}
        isDisabled={validationState !== 'success'}
      >
        Save Categories
      </Button>
    </Box>
  );
}

export default MultiSelectWithValidationExample;

```
### Controlled SelectInput with Custom Formatting

This example demonstrates a controlled SelectInput with custom formatting and state management for a more complex use case.

```tsx
import { useState } from 'react';
import {
  Dropdown,
  DropdownOverlay,
  SelectInput,
  ActionList,
  ActionListItem,
  ActionListItemAsset,
  Box,
  Button,
  Heading,
  Text,
  GlobeIcon,
} from '@razorpay/blade/components';

function CurrencySelectExample() {
  // Pre-defined currency data
  const currencies = [
    { code: 'USD', symbol: '$', name: 'US Dollar', flag: 'ðŸ‡ºðŸ‡¸' },
    { code: 'EUR', symbol: 'â‚¬', name: 'Euro', flag: 'ðŸ‡ªðŸ‡º' },
    { code: 'GBP', symbol: 'Â£', name: 'British Pound', flag: 'ðŸ‡¬ðŸ‡§' },
    { code: 'JPY', symbol: 'Â¥', name: 'Japanese Yen', flag: 'ðŸ‡¯ðŸ‡µ' },
    { code: 'INR', symbol: 'â‚¹', name: 'Indian Rupee', flag: 'ðŸ‡®ðŸ‡³' },
  ];

  const [selectedCurrency, setSelectedCurrency] = useState('INR');
  const [amount, setAmount] = useState('1000');

  const handleCurrencyChange = ({ values }) => {
    if (values && values.length > 0) {
      setSelectedCurrency(values[0]);
    }
  };

  // Get current currency data
  const currentCurrency = currencies.find((c) => c.code === selectedCurrency) || currencies[0];

  return (
    <Box
      width="100%"
      maxWidth="450px"
      padding="spacing.5"
      backgroundColor="surface.background.gray.intense"
      borderRadius="medium"
      borderWidth="thinner"
      borderStyle="solid"
      borderColor="surface.border.gray.subtle"
    >
      <Heading size="xlarge" weight="semibold" marginBottom="spacing.4">
        Currency Converter
      </Heading>

      <Box display="flex" alignItems="flex-end" gap="spacing.3" marginBottom="spacing.5">
        <Box width="150px">
          <Dropdown selectionType="single">
            <SelectInput
              label="Currency"
              name="currency"
              value={selectedCurrency}
              onChange={handleCurrencyChange}
              labelPosition="top"
              prefix={currentCurrency.symbol}
              defaultValue="INR"
              size="medium"
              data-analytics-field="currency-selector"
            />
            <DropdownOverlay>
              <ActionList>
                {currencies.map((currency) => (
                  <ActionListItem
                    key={currency.code}
                    title={`${currency.flag} ${currency.code} - ${currency.name}`}
                    value={currency.code}
                  />
                ))}
              </ActionList>
            </DropdownOverlay>
          </Dropdown>
        </Box>

        <Box flexGrow={1}>
          <Heading size="xlarge" weight="semibold">
            {currentCurrency.symbol} {amount}
          </Heading>
        </Box>
      </Box>

      <Box>
        <Text size="small">
          Selected currency: {currentCurrency.flag} {currentCurrency.name} ({currentCurrency.code})
        </Text>
      </Box>

      <Button marginTop="spacing.4" icon={GlobeIcon} iconPosition="left" isFullWidth>
        View Exchange Rates
      </Button>
    </Box>
  );
}
```

---

## SideNav

## Component Name

SideNav

## Description

The SideNav component provides a responsive side navigation layout positioned along the left side of the screen. It enables quick access to different sections or functionalities of an application with support for multi-level navigation, collapsible sections, and mobile responsiveness. SideNav supports both standalone usage and integration with routing libraries like React Router.

## Important Constraints

- `SideNavLink`: `as` prop requires React Router's Link. Always install React Router while using this component. Example:

  ```jsx
  import { Link } from 'react-router-dom';

  <SideNavLink as={Link} />;
  ```

- Explicitly add `position` prop to `SideNav` component to ensure it is positioned correctly.

## TypeScript Types

The following types represent the props that the SideNav component and its subcomponents accept. These types help configure the navigation structure properly.

````typescript
/**
 * Props for the SideNav component
 */
type SideNavProps = {
  /**
   * Children slot.
   *
   * Supports SideNavFooter, SideNavBody
   */
  children: React.ReactNode;
  /**
   * Only applicable in mobile
   *
   * State for opening / closing the SideNav in mobile
   */
  isOpen?: DrawerProps['isOpen'];
  /**
   * Only applicable in mobile
   *
   * Callback when SideNav is closed
   */
  onDismiss?: DrawerProps['onDismiss'];
  /**
   * Callback that gets triggered when L1 is collapsed or expanded.
   *
   * This callback gets triggered when you-
   * - Select the active link changes between L1 and L2 which can collapse or expand the L1
   * - When you hover / unhover L1 in collapsed state which can temporarily expand the L1
   */
  onVisibleLevelChange?: ({ visibleLevel }: { visibleLevel: number }) => void;
  /**
   * Banner slot for usecases like adding Activation Panel
   *
   * IMPORTANT: Avoid adding promotional items in this
   */
  banner?: React.ReactElement;
  /**
   * Position of the SideNav.
   *
   * It is position="fixed" by default with top="spacing.0" and left="spacing.0" and height="100%"
   *
   * @default 'fixed'
   */
  position?: StyledPropsBlade['position'];
} & StyledPropsBlade &
  TestID;

/**
 * Props for the SideNavLink component
 */
type SideNavLinkProps = {
  /**
   * title of the Link
   */
  title: string;
  /**
   * description of the Link
   *
   * Note: Only applicable for L2 items
   */
  description?: string;
  /**
   * Slot after the title.
   *
   * Used for <Badge />, <Counter /> in most cases
   */
  titleSuffix?: React.ReactElement;
  /**
   * Trailing slot for item. Only visible on hover of the item
   *
   * Used for <Button />
   */
  trailing?: React.ReactElement;
  /**
   * href of the link
   */
  href?: LinkProps['href'];
  /**
   * Anchor tag `target` attribute
   */
  target?: LinkProps['target'];
  /**
   * as prop to pass ReactRouter's Link component.
   *
   * ```jsx
   * import { Link } from 'react-router-dom';
   *
   * <SideNavLink as={Link} />
   * ```
   */
  as: React.ComponentType<any>;
  /**
   * Set Active state of SideNavLink.
   *
   * Checkout SideNav documentation for usage
   */
  isActive?: boolean;
  /**
   * Leading icon for SideNavLink
   */
  icon?: IconComponent;
  /**
   * Children slot to add Nested Menu
   *
   * ```jsx
   * <SideNavLink title="L2 Trigger" href="/l2-first-item">
   *  <SideNavLevel>
   *    <SideNavLink title="L2 Item" href="/l2-first-item" />
   *    <SideNavLink title="L2 Item 2" href="/l2-second-item" />
   *  </SideNavLevel>
   * </SideNavLink>
   * ```
   */
  children?: React.ReactElement;
  /**
   * Tooltip object to add tooltip to SideNavLink
   *
   * ```jsx
   * <SideNavLink
   *  tooltip={{
   *    title: 'Tooltip Title',
   *    content: 'Tooltip description'
   *  }}
   * />
   * ```
   */
  tooltip?: TooltipifyComponentProps['tooltip'];
  /**
   * Click handler for the link
   */
  onClick?: (event: React.MouseEvent) => void;
} & DataAnalyticsAttribute;

/**
 * Props for the SideNavSection component
 */
type SideNavSectionProps = {
  /**
   * Title of the section
   */
  title?: string;
  /**
   * Number of items after which the items are collapsed into `+x more`
   */
  maxVisibleItems?: number;
  /**
   * Default value if the nav section is expanded or collapsed after maxVisibleItems
   *
   * @default false
   */
  defaultIsExpanded?: boolean;
  /**
   * Callback when `+x more is clicked`
   */
  onExpandChange?: ({ isExpanded }: { isExpanded: boolean }) => void;
  /**
   * Children slot for SideNavLink
   */
  children: React.ReactElement[];
} & DataAnalyticsAttribute;

/**
 * Props for the SideNavItem component
 */
type SideNavItemProps = {
  /**
   * Leading slot for SideNavItem.
   *
   * Meant for Indicator, Icon, etc
   */
  leading: React.ReactElement;
  /**
   * Trailing slot for SideNavItem.
   *
   * Meant for Button, Switch, etc
   */
  trailing: React.ReactElement;
  /**
   * Title of SideNavItem
   */
  title: string;
  /**
   * Render item of container. Use as="label" when using Switch or form input in trailing
   *
   * @default div
   */
  as?: 'label' | 'div';
  /**
   * backgroundColor of the item
   *
   * @default undefined
   */
  backgroundColor?: BaseBoxProps['backgroundColor'];
  /**
   * Tooltip object to add tooltip to SideNavItem
   *
   * ```jsx
   * <SideNavItem
   *  tooltip={{
   *    title: 'Tooltip Title',
   *    content: 'Tooltip description'
   *  }}
   * />
   * ```
   */
  tooltip?: SideNavLinkProps['tooltip'];
} & DataAnalyticsAttribute;

/**
 * Props for the SideNavFooter component
 */
type SideNavFooterProps = {
  /**
   * Children slot for SideNavLink, SideNavItem
   */
  children: React.ReactElement[] | React.ReactElement;
};

/**
 * Props for the SideNavBody component
 */
type SideNavBodyProps = {
  /**
   * Children slot for SideNavSection components
   */
  children: React.ReactElement | React.ReactElement[];
};

/**
 * Props for the SideNavLevel component
 */
type SideNavLevelProps = {
  /**
   * Children slot for nested SideNavLink components
   */
  children: React.ReactElement | React.ReactElement[];
};
````

## Example

### Comprehensive SideNav with React Router Integration

This example demonstrates a fully-featured SideNav implementation with multi-level navigation, React Router integration, dynamic active state handling, nested sections, responsive design for mobile, and interactive elements like a test mode toggle and activation banner.

```tsx
import React, { useState } from 'react';
import { BrowserRouter as Router, Link, useLocation, matchPath } from 'react-router-dom';
import {
  SideNav,
  SideNavBody,
  SideNavFooter,
  SideNavLink,
  SideNavLevel,
  SideNavSection,
  SideNavItem,
  Box,
  Card,
  CardBody,
  Text,
  ProgressBar,
  Indicator,
  Switch,
  Button,
  Tooltip,
  HomeIcon,
  SettingsIcon,
  UserIcon,
  CreditCardIcon,
  BillIcon,
  WalletIcon,
  MenuIcon,
  PlusIcon,
  BankIcon,
  ChevronRightIcon,
  ArrowUpRightIcon,
} from '@razorpay/blade/components';

// Custom activation card for the banner slot
const ActivationCard = () => {
  return (
    <Card href="/activate" padding="spacing.4" elevation="none">
      <CardBody>
        <Box display="flex" justifyContent="space-between" marginBottom="spacing.2">
          <Text size="medium" weight="semibold">
            Activation Pending
          </Text>
          <Box>
            <ChevronRightIcon />
          </Box>
        </Box>
        <ProgressBar
          label="Progress"
          showPercentage={true}
          value={50}
          accessibilityLabel="Activation progress: 50% complete"
        />
      </CardBody>
    </Card>
  );
};

// Navigation link with proper active state handling
const NavLink = (props) => {
  const location = useLocation();

  // Helper function to check if a link is active
  const isItemActive = (pathname, { href, activeOnLinks }) => {
    const isCurrentPathActive = matchPath(pathname, {
      path: href,
      exact: false,
    });

    const isSubItemActive = activeOnLinks?.some((link) =>
      matchPath(pathname, { path: link, exact: false }),
    );

    return Boolean(isCurrentPathActive || isSubItemActive);
  };

  return (
    <SideNavLink
      {...props}
      as={Link}
      isActive={isItemActive(location.pathname, {
        href: props.href,
        activeOnLinks: props.activeOnLinks,
      })}
    />
  );
};

// Main SideNav component with all features
const SideNavExample = () => {
  const [isMobileOpen, setIsMobileOpen] = useState(false);
  const [isTestModeActive, setIsTestModeActive] = useState(false);
  const location = useLocation();

  // Helper to get all child hrefs for managing active states
  const getAllChildHrefs = (items) => {
    if (!items) return [];

    const hrefs = [];
    items.forEach((item) => {
      if (item.href) hrefs.push(item.href);
      if (item.items) hrefs.push(...getAllChildHrefs(item.items));
    });

    return hrefs;
  };

  // Define navigation items (typically would come from an API or config)
  const navigationItems = [
    {
      type: 'section',
      items: [
        {
          icon: HomeIcon,
          title: 'Dashboard',
          href: '/dashboard',
          'data-analytics-section': 'main-nav',
          'data-analytics-element': 'dashboard',
        },
        {
          icon: WalletIcon,
          title: 'Payments',
          href: '/payments',
          tooltip: {
            content: 'View all payment transactions',
            placement: 'right',
          },
          trailing: (
            <Tooltip content="Create new payment (Ctrl+N)" placement="right">
              <Button
                icon={PlusIcon}
                size="xsmall"
                variant="tertiary"
                accessibilityLabel="Create new payment"
              />
            </Tooltip>
          ),
          'data-analytics-section': 'main-nav',
          'data-analytics-element': 'payments',
        },
      ],
    },
    {
      type: 'section',
      title: 'Banking',
      maxVisibleItems: 3,
      items: [
        {
          icon: CreditCardIcon,
          title: 'Credit Cards',
          href: '/banking/credit-cards',
          'data-analytics-section': 'banking',
          'data-analytics-element': 'credit-cards',
          items: [
            {
              title: 'Physical Cards',
              href: '/banking/credit-cards/physical',
              description: 'RBL20I43',
              'data-analytics-section': 'banking',
              'data-analytics-element': 'physical-cards',
            },
            {
              title: 'Virtual Cards',
              href: '/banking/credit-cards/virtual',
              description: 'VIR32L98',
              'data-analytics-section': 'banking',
              'data-analytics-element': 'virtual-cards',
            },
          ],
        },
        {
          icon: BankIcon,
          title: 'Bank Accounts',
          href: '/banking/accounts',
          'data-analytics-section': 'banking',
          'data-analytics-element': 'bank-accounts',
        },
        {
          icon: BillIcon,
          title: 'Statements',
          href: '/banking/statements',
          'data-analytics-section': 'banking',
          'data-analytics-element': 'statements',
        },
        {
          icon: ArrowUpRightIcon,
          title: 'Transfers',
          href: '/banking/transfers',
          'data-analytics-section': 'banking',
          'data-analytics-element': 'transfers',
        },
      ],
    },
  ];

  return (
    <Box height="100vh" position="relative">
      <SideNav
        isOpen={isMobileOpen}
        onDismiss={() => setIsMobileOpen(false)}
        onVisibleLevelChange={({ visibleLevel }) => console.log('Visible level:', visibleLevel)}
        banner={<ActivationCard />}
        testID="main-navigation"
        position="absolute"
      >
        <SideNavBody>
          {navigationItems.map((section, sectionIndex) => {
            // Calculate whether section should be expanded by default
            const sectionItems = section.items || [];
            const hasActiveItem = sectionItems.some(
              (item) =>
                matchPath(location.pathname, { path: item.href, exact: false }) ||
                getAllChildHrefs(item.items).some((childHref) =>
                  matchPath(location.pathname, { path: childHref, exact: false }),
                ),
            );

            return (
              <SideNavSection
                key={`section-${sectionIndex}`}
                title={section.title}
                maxVisibleItems={section.maxVisibleItems}
                defaultIsExpanded={hasActiveItem}
                onExpandChange={({ isExpanded }) =>
                  console.log(`Section "${section.title}" expanded:`, isExpanded)
                }
                data-analytics-section={`nav-section-${sectionIndex}`}
              >
                {sectionItems.map((item, itemIndex) => {
                  if (!item.items) {
                    return <NavLink key={`item-${itemIndex}`} {...item} />;
                  }

                  // For items with children, create nested navigation
                  const childHrefs = getAllChildHrefs(item.items);

                  return (
                    <NavLink
                      key={`item-${itemIndex}`}
                      {...item}
                      activeOnLinks={childHrefs}
                      href={item.items[0]?.href || item.href}
                    >
                      <SideNavLevel>
                        {item.items?.map((subItem, subIndex) => (
                          <NavLink
                            key={`subitem-${subIndex}`}
                            {...subItem}
                            description={subItem.description}
                          />
                        ))}
                      </SideNavLevel>
                    </NavLink>
                  );
                })}
              </SideNavSection>
            );
          })}
        </SideNavBody>

        <SideNavFooter>
          {/* Test mode toggle with accessibility improvements */}
          <SideNavItem
            as="label"
            title="Test Mode"
            leading={
              <Indicator
                color={isTestModeActive ? 'notice' : 'positive'}
                emphasis="intense"
                accessibilityLabel={isTestModeActive ? 'Test mode enabled' : 'Test mode disabled'}
              />
            }
            backgroundColor={isTestModeActive ? 'feedback.background.notice.subtle' : undefined}
            trailing={
              <Switch
                accessibilityLabel="Toggle test mode"
                size="small"
                isChecked={isTestModeActive}
                onChange={({ isChecked }) => setIsTestModeActive(isChecked)}
              />
            }
            data-analytics-section="footer"
            data-analytics-element="test-mode-toggle"
          />

          {/* Settings navigation with nested items */}
          <NavLink
            title="Settings"
            icon={SettingsIcon}
            href="/settings"
            activeOnLinks={['/settings/user', '/settings/account']}
            data-analytics-section="footer"
            data-analytics-element="settings"
          >
            <SideNavLevel>
              <NavLink
                icon={UserIcon}
                title="User Settings"
                href="/settings/user"
                data-analytics-section="settings"
                data-analytics-element="user-settings"
              />
              <NavLink
                icon={SettingsIcon}
                title="Account Settings"
                href="/settings/account"
                data-analytics-section="settings"
                data-analytics-element="account-settings"
              />
            </SideNavLevel>
          </NavLink>
        </SideNavFooter>
      </SideNav>

      {/* Mobile menu toggle button */}
      <Box
        display={{ base: 'block', m: 'none' }}
        position="fixed"
        top="spacing.4"
        right="spacing.4"
        zIndex="2"
      >
        <Button
          variant="tertiary"
          icon={MenuIcon}
          onClick={() => setIsMobileOpen(true)}
          accessibilityLabel="Open navigation menu"
        />
      </Box>

      {/* Main content area with proper spacing based on SideNav */}
      <Box marginLeft={{ base: 'spacing.0', m: '300px' }} padding="spacing.4" height="100%">
        {/* Your application content goes here */}
      </Box>
    </Box>
  );
};

// Wrap with Router for actual usage
const App = () => (
  <Router>
    <SideNavExample />
  </Router>
);

export default App;
```

---

## Skeleton

## Component Name

Skeleton

## Description

The Skeleton component is a placeholder UI element that displays a pulsing animation while content is loading. It mimics the structure and appearance of the final content to create a smoother perceived loading experience. Skeletons reduce the perception of loading time and provide users with a visual indication of the layout before the actual content appears.

## TypeScript Types

These types define the props that the Skeleton component accepts, allowing you to configure how the loading placeholders appear.

```typescript
type SkeletonProps = {
  /**
   * Sets the width of the skeleton.
   * Can be any valid CSS width value or responsive object.
   */
  width?: string | number | ResponsiveValue<string | number>;

  /**
   * Sets the maximum width of the skeleton.
   * Can be any valid CSS max-width value or responsive object.
   */
  maxWidth?: string | number | ResponsiveValue<string | number>;

  /**
   * Sets the minimum width of the skeleton.
   * Can be any valid CSS min-width value or responsive object.
   */
  minWidth?: string | number | ResponsiveValue<string | number>;

  /**
   * Sets the height of the skeleton.
   * Can be any valid CSS height value or responsive object.
   */
  height?: string | number | ResponsiveValue<string | number>;

  /**
   * Sets the maximum height of the skeleton.
   * Can be any valid CSS max-height value or responsive object.
   */
  maxHeight?: string | number | ResponsiveValue<string | number>;

  /**
   * Sets the minimum height of the skeleton.
   * Can be any valid CSS min-height value or responsive object.
   */
  minHeight?: string | number | ResponsiveValue<string | number>;

  /**
   * Sets the border radius of the skeleton.
   * @default 'medium'
   */
  borderRadius?: BorderRadiusToken;

  /**
   * Unique identifier for testing purposes.
   */
  testID?: string;
} & StyledPropsBlade &
  Partial<FlexboxProps>;
```

## Example

### Basic Usage

This example shows a simple implementation of multiple Skeleton elements with varying widths and heights to create a text-like loading placeholder.

```tsx
import { Skeleton, Box } from '@razorpay/blade/components';

function BasicSkeletonExample() {
  return (
    <Box padding="spacing.4">
      {/* Simple skeleton line */}
      <Skeleton width="100%" height="24px" borderRadius="medium" marginBottom="spacing.4" />

      {/* Shorter skeleton line */}
      <Skeleton width="60%" height="20px" borderRadius="medium" marginBottom="spacing.4" />

      {/* Even shorter skeleton line */}
      <Skeleton width="40%" height="20px" borderRadius="medium" />
    </Box>
  );
}
```

### Card With Loading State

This example demonstrates how to use Skeleton components within a card to create a realistic loading state that mimics the actual content's structure, with a toggle button to switch between loading and loaded states.

```tsx
import { useState, useEffect } from 'react';
import {
  Skeleton,
  Box,
  Card,
  CardHeader,
  CardBody,
  CardHeaderLeading,
  Button,
  Text,
  Divider,
} from '@razorpay/blade/components';

function CardLoadingExample() {
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Simulate loading data
    const timer = setTimeout(() => {
      setIsLoading(false);
    }, 3000);

    return () => clearTimeout(timer);
  }, []);

  return (
    <Box maxWidth="400px">
      <Button marginBottom="spacing.4" onClick={() => setIsLoading((prev) => !prev)}>
        Toggle Loading State
      </Button>

      <Card>
        {isLoading ? (
          <Box padding="spacing.6">
            {/* Header skeleton */}
            <Box marginBottom="spacing.4">
              <Skeleton width="70%" height="24px" borderRadius="medium" marginBottom="spacing.3" />
              <Skeleton width="40%" height="16px" borderRadius="medium" />
            </Box>

            <Divider marginY="spacing.4" />

            {/* Content skeleton */}
            <Box>
              <Skeleton width="100%" height="16px" borderRadius="medium" marginBottom="spacing.3" />
              <Skeleton width="100%" height="16px" borderRadius="medium" marginBottom="spacing.3" />
              <Skeleton width="60%" height="16px" borderRadius="medium" />
            </Box>
          </Box>
        ) : (
          <>
            <CardHeader>
              <CardHeaderLeading title="Payment Pages" subtitle="Automated Receipts Enabled" />
            </CardHeader>
            <CardBody>
              <Text>
                Razorpay Payment Pages is the easiest way to accept payments with a custom-branded
                online store. Accept international and domestic payments with automated payment
                receipts.
              </Text>
            </CardBody>
          </>
        )}
      </Card>
    </Box>
  );
}
```

---

## SkipNav

## Component Name

SkipNav

## Description

The SkipNav component lets users skip the navigation and jump to the main content of the page. It improves accessibility by allowing keyboard users to bypass repetitive navigation links and quickly access the primary content. This is especially useful for users with screen readers or those who navigate websites using only a keyboard.

## TypeScript Types

These types define the props that the SkipNav component and its subcomponents accept, allowing you to configure the component when using it in your application.

```typescript
// SkipNavLink Component Props
type SkipNavLinkProps = {
  /**
   * The ID of the element to skip to.
   * Must match the id prop on SkipNavContent.
   * @default 'blade-skip-nav'
   */
  id?: string;

  /**
   * The text content of the skip link.
   * @default 'Skip to content'
   */
  children?: StringChildrenType;

  /**
   * Internal prop - adds background to link.
   * @private
   */
  _hasBackground?: boolean;
};

// SkipNavContent Component Props
type SkipNavContentProps = {
  /**
   * The ID of the element that will be skipped to.
   * Must match the id prop on SkipNavLink.
   * @default 'blade-skip-nav'
   */
  id?: string;
} & TestID;
```

## Example

### Basic Usage

This example demonstrates how to implement the SkipNav component for accessibility, showing proper placement of SkipNavLink at the beginning of the document and SkipNavContent at the start of the main content area.

```tsx
import { SkipNavLink, SkipNavContent, Box, Link, Text, Heading } from '@razorpay/blade/components';

function AccessibleLayout() {
  return (
    <Box>
      {/* Place SkipNavLink at the beginning of your document */}
      <SkipNavLink>Skip to content</SkipNavLink>

      {/* Navigation Section */}
      <nav>
        <Box
          display="flex"
          gap="spacing.4"
          padding="spacing.4"
          backgroundColor="surface.background.gray.subtle"
        >
          <ul>
            <li>
              <Link href="#home">Home</Link>
            </li>
            <li>
              <Link href="#features">Features</Link>
            </li>
            <li>
              <Link href="#pricing">Pricing</Link>
            </li>
            <li>
              <Link href="#contact">Contact</Link>
            </li>
          </ul>
        </Box>
      </nav>

      {/* Main Content - Place SkipNavContent at the beginning of main content */}
      <main>
        <SkipNavContent />
        <Box padding="spacing.4">
          <Heading size="xlarge">Welcome to Our Website</Heading>
          <Text marginTop="spacing.3">
            This is the main content area that users will skip to when using the SkipNavLink.
          </Text>
        </Box>
      </main>
    </Box>
  );
}
```

---

## Slide

## Component Name

Slide

## Description

The Slide component is a motion preset that animates elements by sliding them in from outside the viewport. It creates smooth entrance and exit animations, making elements appear or disappear with a sliding motion. This component is ideal for page transitions, introducing new UI elements, or implementing progressive disclosure patterns.

## TypeScript Types

These types define the props that the Slide component accepts, allowing you to configure how elements slide into and out of view.

```typescript
// Main Slide component props
type SlideProps = {
  /**
   * React children to be animated.
   */
  children: React.ReactElement;

  /**
   * Controls whether the component is visible or not.
   * When used, the component will animate in when true and animate out when false.
   */
  isVisible?: boolean;

  /**
   * Specifies what triggers the animation.
   * - mount: Animates when component mounts
   * - in-view: Animates when component enters the viewport
   * - focus: Animates when component receives focus
   * - on-animate-interactions: Animates based on AnimateInteractions component
   *
   * @default ['mount']
   */
  motionTriggers?: ('mount' | 'in-view' | 'focus' | 'on-animate-interactions')[];

  /**
   * Determines if the component should be unmounted from the DOM when hidden.
   * When false (default), component remains in DOM with opacity 0.
   *
   * @default false
   */
  shouldUnmountWhenHidden?: boolean;

  /**
   * Sets whether component should animate in, out, or both.
   * - in: Only animates in, immediately removed on exit
   * - out: Only animates out, immediately appears on enter
   * - inout: Animates both in and out
   *
   * @default 'inout'
   */
  type?: 'in' | 'out' | 'inout';

  /**
   * Direction from where the component should slide.
   * Can be a single direction for both enter/exit or different directions for each.
   *
   * @default 'bottom'
   */
  direction?:
    | 'top'
    | 'right'
    | 'bottom'
    | 'left'
    | {
        enter: 'top' | 'right' | 'bottom' | 'left';
        exit: 'top' | 'right' | 'bottom' | 'left';
      };

  /**
   * Offset from which the component should slide.
   * The Slide component is meant to animate from outside the viewport.
   *
   * @default
   * direction="right|left" -> 100vw
   * direction="top|bottom" -> 100vh
   */
  fromOffset?: '100vh' | '100vw' | `${number}%`;

  /**
   * Handles delay of animations.
   * Can be a single delay value or different values for enter/exit.
   */
  delay?:
    | keyof Delay
    | {
        enter: keyof Delay;
        exit: keyof Delay;
      };
};
```

## Example

### Basic Usage

This example demonstrates a simple slide animation toggled by a button, showing how to use the Slide component with the isVisible prop to control the animation state.

```tsx
import { useState } from 'react';
import { Slide, Box, Button, Card, CardBody, Text } from '@razorpay/blade/components';

function BasicSlideExample() {
  const [isVisible, setIsVisible] = useState(true);

  return (
    <Box padding="spacing.6">
      <Button marginBottom="spacing.4" onClick={() => setIsVisible(!isVisible)}>
        Toggle Slide
      </Button>

      <Slide isVisible={isVisible} direction="bottom">
        <Card width="100%" height="100%">
          <CardBody>
            <Text>
              This card slides in from the bottom and out to the bottom when the toggle button is
              clicked.
            </Text>
          </CardBody>
        </Card>
      </Slide>
    </Box>
  );
}
```

### Slide In View Example

This example shows how to trigger slide animations when elements enter the viewport during scrolling, with multiple elements sliding from different directions and with varying delays.

```tsx
import {
  Slide,
  Box,
  Card,
  CardBody,
  CardHeader,
  CardHeaderLeading,
  Text,
} from '@razorpay/blade/components';

function SlideInViewExample() {
  return (
    <Box
      height="400px"
      overflow="auto"
      padding="spacing.4"
      backgroundColor="surface.background.gray.subtle"
    >
      <Text marginBottom="spacing.4">Scroll down to see elements slide in</Text>

      {/* Create space to scroll */}
      <Box height="300px" />

      {/* First element that slides in when scrolled into view */}
      <Slide motionTriggers={['in-view']} direction="left">
        <Card marginBottom="spacing.6">
          <CardHeader>
            <CardHeaderLeading title="First Item" />
          </CardHeader>
          <CardBody>
            <Text>This card slides in from the left when scrolled into view</Text>
          </CardBody>
        </Card>
      </Slide>

      {/* Create more space */}
      <Box height="200px" />

      {/* Second element with different animation */}
      <Slide motionTriggers={['in-view']} direction="right" delay="gentle">
        <Card marginBottom="spacing.6">
          <CardHeader>
            <CardHeaderLeading title="Second Item" />
          </CardHeader>
          <CardBody>
            <Text>
              This card slides in from the right with a gentle delay when scrolled into view
            </Text>
          </CardBody>
        </Card>
      </Slide>

      {/* Create more space */}
      <Box height="200px" />

      {/* Third element with another animation style */}
      <Slide motionTriggers={['in-view']} direction="bottom">
        <Card>
          <CardHeader>
            <CardHeaderLeading title="Third Item" />
          </CardHeader>
          <CardBody>
            <Text>This card slides in from the bottom when scrolled into view</Text>
          </CardBody>
        </Card>
      </Slide>
    </Box>
  );
}
```

---

## Spinner

## Component Name

Spinner

## Description

A Spinner is an element with a looping animation that indicates loading is in progress. It provides visual feedback to users when content is being loaded or when an action is being processed, helping to improve user experience during wait times.

## TypeScript Types

These types define the props that the Spinner component and its subcomponents accept, allowing you to configure the component when using it in your application.

```typescript
// Main component props
type SpinnerProps = {
  /**
   * Sets the color of the spinner.
   *
   * @default 'neutral'
   */
  color?: 'primary' | 'neutral' | 'white';
  /**
   * Sets the label of the spinner.
   */
  label?: string;
  /**
   * Sets the position of the label.
   *
   * @default 'right'
   */
  labelPosition?: 'right' | 'bottom';
  /**
   * Sets the size of the spinner.
   *
   * @default 'medium'
   */
  size?: 'medium' | 'large' | 'xlarge';
  /**
   * Sets the aria-label for web & accessibilityLabel react-native.
   *
   * @default 'Loading'
   */
  accessibilityLabel?: string;
} & TestID &
  StyledPropsBlade;

// Token types
type SpinnerDimensions = {
  medium: 16;
  large: 20;
  xlarge: 24;
};

// Motion configuration
type SpinnerMotion = {
  duration: DurationString;
  easing: EasingString;
};
```

## Example

### Basic Usage

This example demonstrates how to use the Spinner component to indicate a loading state, with a timer that simulates content loading for 3 seconds before displaying a success message.

```tsx
import { useState, useEffect } from 'react';
import { Spinner, Text, Box } from '@razorpay/blade/components';

function LoadingExample() {
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Simulate a loading state for 3 seconds
    const timer = setTimeout(() => {
      setIsLoading(false);
    }, 3000);

    return () => clearTimeout(timer);
  }, []);

  return (
    <Box>
      {isLoading ? (
        <Spinner accessibilityLabel="Loading content" color="primary" />
      ) : (
        <Text>Content loaded successfully!</Text>
      )}
    </Box>
  );
}
```

---

## SpotlightPopoverTour

## Component Name

SpotlightPopoverTour

## Description

The SpotlightPopoverTour component is used to provide context as well as enable users to take certain actions on it. These are used to highlight a new feature or provide a guided tour to a new user. The component can spotlight specific UI elements on the page and present a series of steps with descriptions.

## TypeScript Types

Below are the TypeScript types that define the props that the SpotlightPopoverTour and its subcomponents accept:

```typescript
// Main component props
type SpotlightPopoverTourProps = {
  /**
   * Array of steps to be rendered
   *
   * The order of the steps will be the order in which they are rendered depending on the `activeStep` prop
   */
  steps: SpotlightPopoverTourSteps;
  /**
   * Whether the tour is visible or not
   */
  isOpen: boolean;
  /**
   * Callback when the tour is opened or closed
   */
  onOpenChange?: ({ isOpen }: { isOpen: boolean }) => void;
  /**
   * Callback which fires when the `stopTour` method is called from the `steps` array
   */
  onFinish?: () => void;
  /**
   * Callback when the active step changes
   */
  onStepChange?: (step: number) => void;
  /**
   * Active step to be rendered
   */
  activeStep: number;
  children: React.ReactNode;
};

// Tour step props
type SpotlightPopoverTourStepProps = {
  name: string;
  children: React.ReactNode;
};

// Tour step definition
type Step = {
  /**
   * Unique identifier for the tour step
   */
  name: string;
  /**
   * Content of the Popover
   */
  content: (props: SpotlightPopoverStepRenderProps) => React.ReactElement;
  /**
   * Footer content
   */
  footer?: (props: SpotlightPopoverStepRenderProps) => React.ReactNode;
  /**
   * Popover title
   */
  title?: string;
  /**
   * Leading content placed before the title
   *
   * Can be any blade icon or asset.
   */
  titleLeading?: React.ReactNode;
  /**
   * Placement of Popover
   * @default "top"
   */
  placement?: UseFloatingOptions['placement'];
};

// Array of Step objects
type SpotlightPopoverTourSteps = Step[];

// Props passed to render functions
type SpotlightPopoverStepRenderProps = {
  /**
   * Go to a specific step
   */
  goToStep: (step: number) => void;
  /**
   * Go to the next step
   */
  goToNext: () => void;
  /**
   * Go to the previous step
   */
  goToPrevious: () => void;
  /**
   * Stop the tour
   *
   * This will call the `onFinish` callback
   */
  stopTour: () => void;
  /**
   * Current active step (zero based index)
   */
  activeStep: number;
  /**
   * Total number of steps
   */
  totalSteps: number;
};
```

## Example

### Basic Tour Example

This example demonstrates a simple guided tour with three steps highlighting different UI elements, using a custom footer component to control navigation between steps.

```tsx
import { useState } from 'react';
import {
  SpotlightPopoverTour,
  SpotlightPopoverTourStep,
  SpotlightPopoverTourFooter,
  Box,
  Button,
  Text,
  Card,
  CardBody,
  InfoIcon,
  Amount,
} from '@razorpay/blade/components';
import type {
  SpotlightPopoverTourSteps,
  SpotlightPopoverStepRenderProps,
} from '@razorpay/blade/components';
// Custom footer component that can control the tour
const CustomTourFooter = ({
  activeStep,
  totalSteps,
  goToNext,
  goToPrevious,
  stopTour,
}: SpotlightPopoverStepRenderProps): React.ReactElement => {
  const isLast = activeStep === totalSteps - 1;
  const isFirst = activeStep === 0;

  return (
    <SpotlightPopoverTourFooter
      activeStep={activeStep}
      totalSteps={totalSteps}
      actions={{
        primary: isLast
          ? {
              text: 'Done',
              onClick: stopTour,
            }
          : {
              text: 'Next',
              onClick: goToNext,
            },
        secondary: isFirst
          ? undefined
          : {
              text: 'Prev',
              onClick: goToPrevious,
            },
      }}
    />
  );
};

function BasicTourExample(): React.ReactElement {
  const [activeStep, setActiveStep] = useState(0);
  const [isOpen, setIsOpen] = useState(false);

  // Define the tour steps
  const steps: SpotlightPopoverTourSteps = [
    {
      name: 'refunds-step',
      title: 'Overview of Refunds',
      content: () => (
        <Box>
          <Text color="surface.text.gray.subtle">
            You can issue refunds for various reasons, like when a customer returns a product or
            cancels a service.
          </Text>
          <Text color="surface.text.gray.subtle" marginTop="spacing.2">
            You can also issue partial refunds - for example, if a customer purchased multiple
            items.
          </Text>
        </Box>
      ),
      placement: 'bottom' as const,
      footer: CustomTourFooter,
    },
    {
      name: 'disputes-step',
      title: 'Overview of Disputes',
      content: () => (
        <Box>
          <Text color="surface.text.gray.subtle">
            Disputes are raised by customers when they have a problem with a transaction.
          </Text>
        </Box>
      ),
      placement: 'bottom' as const,
      footer: CustomTourFooter,
    },
    {
      name: 'status-step',
      title: 'Dispute Statuses',
      content: () => (
        <Text color="surface.text.gray.subtle">
          Disputes which are open or under review will be shown here. You can also review them by
          clicking on the button.
        </Text>
      ),
      placement: 'bottom' as const,
      footer: CustomTourFooter,
    },
  ];

  return (
    <Box>
      <Button
        marginBottom="spacing.9"
        onClick={() => {
          setIsOpen(!isOpen);
        }}
      >
        {isOpen ? 'Tour In Progress' : 'Start Tour'}
      </Button>

      <SpotlightPopoverTour
        steps={steps}
        isOpen={isOpen}
        activeStep={activeStep}
        onFinish={() => {
          setActiveStep(0);
          setIsOpen(false);
        }}
        onOpenChange={({ isOpen }) => {
          setIsOpen(isOpen);
        }}
        onStepChange={(step) => {
          setActiveStep(step);
        }}
      >
        <Box
          display="flex"
          flexDirection={{ base: 'column', m: 'row' }}
          gap="spacing.4"
          alignItems="stretch"
        >
          <SpotlightPopoverTourStep name="refunds-step">
            <Box width="100%">
              <Card width="100%" height="100%">
                <CardBody>
                  <Box display="flex" flexDirection="column" gap="spacing.3">
                    <Box display="flex" alignItems="center" gap="spacing.3">
                      <Text>Refunds</Text>
                      <InfoIcon color="surface.icon.gray.muted" />
                    </Box>
                    <Amount value={40000} type="heading" size="large" />
                    <Text color="surface.text.gray.muted">3 Processed</Text>
                  </Box>
                </CardBody>
              </Card>
            </Box>
          </SpotlightPopoverTourStep>

          <SpotlightPopoverTourStep name="disputes-step">
            <Box width="100%">
              <Card width="100%" height="100%">
                <CardBody>
                  <Box display="flex" flexDirection="column" gap="spacing.3">
                    <Box display="flex" alignItems="center" gap="spacing.3">
                      <Text>Disputes</Text>
                      <InfoIcon color="interactive.icon.gray.muted" />
                    </Box>
                    <Amount value={0} type="heading" size="large" />

                    <SpotlightPopoverTourStep name="status-step">
                      <Box
                        display="flex"
                        justifyContent="space-between"
                        alignItems="center"
                        gap="spacing.3"
                      >
                        <Text color="surface.text.gray.muted">0 Open | 0 Under review</Text>
                        <Button size="small" variant="tertiary">
                          Review
                        </Button>
                      </Box>
                    </SpotlightPopoverTourStep>
                  </Box>
                </CardBody>
              </Card>
            </Box>
          </SpotlightPopoverTourStep>
        </Box>
      </SpotlightPopoverTour>
    </Box>
  );
}

export default BasicTourExample;

```
### Interruptible Tour Example

This example shows an advanced implementation of a tour that can be interrupted or skipped, with dynamic step content that changes based on whether the user completed or skipped the tour.

```tsx
import { useState } from 'react';
import {
  SpotlightPopoverTour,
  SpotlightPopoverTourStep,
  Box,
  Button,
  Text,
  Code,
} from '@razorpay/blade/components';
import type {
  SpotlightPopoverTourSteps,
  SpotlightPopoverStepRenderProps,
} from '@razorpay/blade/components';

const InterruptibleTourFooter = ({
  activeStep,
  goToNext,
  goToStep,
  stopTour,
  goToPrevious,
  totalSteps,
  setIsTourSkipped,
}: SpotlightPopoverStepRenderProps & {
  setIsTourSkipped: (isTourSkipped: boolean) => void;
}): React.ReactElement => {
  const isLast = activeStep === totalSteps - 1;
  const isFirst = activeStep === 0;

  return (
    <Box display="flex" justifyContent="space-between" alignItems="center" gap="spacing.7">
      <Text size="small" weight="semibold">
        {activeStep + 1} / {totalSteps}
      </Text>
      <Box display="flex" gap="spacing.4">
        <Button
          size="small"
          variant="tertiary"
          onClick={() => {
            setIsTourSkipped(true);
            goToStep(totalSteps - 1);
          }}
        >
          Skip Tour
        </Button>
        {!isFirst && (
          <Button
            size="small"
            variant="secondary"
            onClick={() => {
              goToPrevious();
            }}
          >
            Prev
          </Button>
        )}
        {isLast ? (
          <Button
            size="small"
            onClick={() => {
              stopTour();
            }}
          >
            Done
          </Button>
        ) : (
          <Button
            size="small"
            onClick={() => {
              goToNext();
            }}
          >
            Next
          </Button>
        )}
      </Box>
    </Box>
  );
};

function InterruptibleTourExample(): React.ReactElement {
  const [activeStep, setActiveStep] = useState(0);
  const [isTourSkipped, setIsTourSkipped] = useState(false);
  const [isOpen, setIsOpen] = useState(false);

  // Define steps dynamically based on state
  const steps: SpotlightPopoverTourSteps = [
    {
      name: 'step-1',
      title: 'Step 1',
      content: () => (
        <Box>
          <Text color="surface.text.gray.subtle">This is step 1, press skip</Text>
        </Box>
      ),
      placement: 'top' as const,
      footer: (props) => (
        <InterruptibleTourFooter
          activeStep={props.activeStep}
          goToNext={props.goToNext}
          goToStep={props.goToStep}
          stopTour={props.stopTour}
          goToPrevious={props.goToPrevious}
          totalSteps={props.totalSteps}
          setIsTourSkipped={setIsTourSkipped}
        />
      ),
    },
    {
      name: 'step-2',
      title: 'Step 2',
      content: () => (
        <Box>
          <Text color="surface.text.gray.subtle">This is step 2</Text>
        </Box>
      ),
      placement: 'bottom' as const,
      footer: (props) => (
        <InterruptibleTourFooter
          activeStep={props.activeStep}
          goToNext={props.goToNext}
          goToStep={props.goToStep}
          stopTour={props.stopTour}
          goToPrevious={props.goToPrevious}
          totalSteps={props.totalSteps}
          setIsTourSkipped={setIsTourSkipped}
        />
      ),
    },
    // The final step changes based on whether user skipped or completed
    isTourSkipped
      ? {
          name: 'final-step',
          title: 'Tour Incomplete!',
          content: () => (
            <Text color="surface.text.gray.subtle">
              We recommend that you complete the tour to make the most of the new features. You can
              find it here when you want to take it.
            </Text>
          ),
          footer: ({ stopTour }) => (
            <Button
              size="small"
              onClick={() => {
                stopTour();
              }}
            >
              Got it
            </Button>
          ),
        }
      : {
          name: 'final-step',
          title: 'Tour Complete!',
          content: () => (
            <Text color="surface.text.gray.subtle">
              You have completed the tour. You can find it here when you want to take it.
            </Text>
          ),
          footer: ({ stopTour }) => (
            <Button
              size="small"
              onClick={() => {
                stopTour();
              }}
            >
              Thanks.
            </Button>
          ),
        },
  ];

  return (
    <Box>
      <SpotlightPopoverTour
        steps={steps}
        isOpen={isOpen}
        activeStep={activeStep}
        onFinish={() => {
          setIsOpen(false);
          setIsTourSkipped(false);
          setActiveStep(0);
        }}
        onOpenChange={({ isOpen }) => {
          setIsOpen(isOpen);
        }}
        onStepChange={(step) => {
          setActiveStep(step);
        }}
      >
        <SpotlightPopoverTourStep name="final-step">
          <Button
            marginBottom="spacing.5"
            onClick={() => {
              setIsOpen(!isOpen);
            }}
          >
            {isOpen ? 'Tour In Progress' : 'Start Tour'}
          </Button>
        </SpotlightPopoverTourStep>

        <Text>
          You can create complex flows like interruptible tours by dynamically modifying the steps
          array, and changing its contents.
        </Text>

        <Text>
          Compose and make use of methods provided by the tour component like{' '}
          <Code size="medium">stopTour</Code>, <Code size="medium">goToStep</Code>,{' '}
          <Code size="medium">goToNext</Code> etc to control the behavior of the current tour step
        </Text>

        <Box display="flex" gap="spacing.4" alignItems="stretch" marginTop="spacing.6">
          <SpotlightPopoverTourStep name="step-1">
            <Box padding="spacing.4" backgroundColor="surface.background.gray.intense">
              Step 1
            </Box>
          </SpotlightPopoverTourStep>

          <SpotlightPopoverTourStep name="step-2">
            <Box padding="spacing.4" backgroundColor="surface.background.gray.intense">
              Step 2
            </Box>
          </SpotlightPopoverTourStep>
        </Box>
      </SpotlightPopoverTour>
    </Box>
  );
}

export default InterruptibleTourExample;

```

---

## Stagger

## Component Name

Stagger

## Description

Stagger is a utility motion preset component that allows you to stagger children (make them appear one after the other) with animations. It's designed to create visually appealing entry and exit animations where child elements animate sequentially rather than simultaneously, creating a cascading effect.

## TypeScript Types

Below are the TypeScript types that define the props that the Stagger component accepts:

```typescript
// Main component props
type StaggerProps = Pick<
  BaseMotionEntryExitProps,
  'isVisible' | 'motionTriggers' | 'shouldUnmountWhenHidden' | 'type' | 'delay'
> & {
  children: React.ReactElement[] | React.ReactElement;
} & Omit<BoxProps, 'as'>;

// The picked BaseMotionEntryExitProps include:
type BaseMotionEntryExitProps = {
  /**
   * Whether the component is visible or not
   * @default true
   */
  isVisible?: boolean;

  /**
   * What triggers the motion
   * @default ['mount']
   */
  motionTriggers?: Array<'mount' | 'hover' | 'focus'>;

  /**
   * Whether to unmount the component when it's hidden
   * @default false
   */
  shouldUnmountWhenHidden?: boolean;

  /**
   * Type of animation to use
   * @default 'inout'
   */
  type?: 'in' | 'out' | 'inout';

  /**
   * Delay duration for the animation
   */
  delay?:
    | keyof typeof theme.motion.delay
    | { enter?: keyof typeof theme.motion.delay; exit?: keyof typeof theme.motion.delay };
};
```

## Example

### Basic Stagger Animation with Fade

This example demonstrates how to create a sequential appearance animation for multiple cards, where each card fades in one after another rather than simultaneously, controlled by a toggle button.

```tsx
import { useState } from 'react';
import {
  Stagger,
  Fade,
  Box,
  Button,
  Card,
  CardBody,
  CardHeader,
  CardHeaderLeading,
  Text,
} from '@razorpay/blade/components';

function StaggerExample() {
  const [isVisible, setIsVisible] = useState(true);

  return (
    <Box
      backgroundColor="surface.background.gray.intense"
      padding="spacing.8"
      borderRadius="medium"
    >
      <Button marginBottom="spacing.4" onClick={() => setIsVisible(!isVisible)}>
        {isVisible ? 'Hide Cards' : 'Show Cards'}
      </Button>

      <Stagger
        isVisible={isVisible}
        display="flex"
        flexDirection="row"
        gap="spacing.4"
        motionTriggers={['mount']}
        type="inout"
        shouldUnmountWhenHidden={false}
      >
        <Fade>
          <Card width="200px">
            <CardHeader>
              <CardHeaderLeading title="Card 1" subtitle="First card" />
            </CardHeader>
            <CardBody>
              <Text>This card appears first</Text>
            </CardBody>
          </Card>
        </Fade>

        <Fade>
          <Card width="200px">
            <CardHeader>
              <CardHeaderLeading title="Card 2" subtitle="Second card" />
            </CardHeader>
            <CardBody>
              <Text>This card appears second</Text>
            </CardBody>
          </Card>
        </Fade>

        <Fade>
          <Card width="200px">
            <CardHeader>
              <CardHeaderLeading title="Card 3" subtitle="Third card" />
            </CardHeader>
            <CardBody>
              <Text>This card appears third</Text>
            </CardBody>
          </Card>
        </Fade>
      </Stagger>
    </Box>
  );
}
```

---

## StepGroup

## Component Name

StepGroup

## Description

StepGroup visualizes sequential processes with a consistent structure. It can be interactive, guiding users through steps, or function as a timeline for reference. The component supports both vertical and horizontal orientations, customizable progress states, and nested structures for complex workflows.

## Important Constraints

- `Collapsible` component is not supported when `StepGroup` has `orientation="horizontal"`
- `StepItem` `trailing` prop is not allowed when `StepGroup` has `orientation="horizontal"`
- Nested `StepGroup` components are not allowed when parent `StepGroup` has `orientation="horizontal"`

## TypeScript Types

Below are the TypeScript types that define the props that StepGroup and its subcomponents accept:

````typescript
// Main component props
type StepGroupProps = {
  /**
   * size of step group
   *
   * @default medium
   */
  size?: 'medium' | 'large';

  /**
   * orientation of step group
   *
   * @default vertical
   */
  orientation?: 'horizontal' | 'vertical';

  /**
   * children slot for StepItem components
   */
  children: React.ReactElement | React.ReactElement[];

  /**
   * Width of StepGroup. By default it takes the width of its items.
   */
  width?: BoxProps['width'];

  /**
   * minWidth prop of StepGroup
   */
  minWidth?: BoxProps['minWidth'];

  /**
   * maxWidth prop of StepGroup
   *
   * @default 100%
   */
  maxWidth?: BoxProps['maxWidth'];
} & StyledPropsBlade &
  DataAnalyticsAttribute &
  TestID;

// StepItem component props
type StepItemProps = {
  /**
   * title of StepItem
   */
  title: string;

  /**
   * color of StepItem title
   */
  titleColor?: `feedback.text.${FeedbackColors}.intense` | `surface.text.primary.normal`;

  /**
   * A string that renders in italic font. Made for adding timestamp values.
   *
   * ```jsx
   * timestamp="Thu, 11th Oct23 | 12:00pm"
   * ```
   */
  timestamp?: string;

  /**
   * Description of StepItem
   */
  description?: string;

  /**
   * Progress line of step. When its start only starting part is highlighted and rest is kept dotted
   *
   * @default full
   */
  stepProgress?: 'start' | 'end' | 'full' | 'none';

  /**
   * marker JSX slot. It can be StepItemIndicator or StepItemIcon
   *
   * ```jsx
   * marker={<StepItemIndicator color="positive" />}
   * marker={<StepItemIcon icon={CheckIcon} color="positive" />}
   * ```
   */
  marker?: React.ReactElement;

  /**
   * trailing slot for StepItem. Mostly meant for Badge
   */
  trailing?: React.ReactElement;

  /**
   * Controlled state of selected item
   */
  isSelected?: boolean;

  /**
   * State for disabling the step item
   */
  isDisabled?: boolean;

  /**
   * Anchor tag's href value. Turns StepItem into interactive item and render it as `<a>` tag
   */
  href?: LinkProps['href'];

  /**
   * Anchjor tag's taget value. Meant to be used alongside `href` prop
   */
  target?: LinkProps['target'];

  /**
   * StepItem's click handler. Turns StepItem into interactive item and render it as button tag
   */
  onClick?: (event: React.MouseEvent) => void;

  /**
   * Children slot for adding additional custom elements to item
   */
  children?: React.ReactNode;
} & DataAnalyticsAttribute;
````

## Example

### Basic Vertical StepGroup

This example demonstrates a standard vertical StepGroup showing a progression of steps with different states, timestamps, icons, and badges to represent a complete onboarding process.

```tsx
import {
  StepGroup,
  StepItem,
  StepItemIcon,
  StepItemIndicator,
  Badge,
  FileIcon,
  UserIcon,
  BriefcaseIcon,
  ClockIcon,
  HeartIcon,
  Box,
} from '@razorpay/blade/components';

function MyStepGroup() {
  return (
    <StepGroup orientation="vertical" size="medium">
      <StepItem
        title="Introduction"
        timestamp="Thu, 11th Octâ€™23 | 12:00pm"
        stepProgress="full"
        marker={<StepItemIcon icon={FileIcon} color="positive" />}
      />
      <StepItem
        title="Personal Details"
        timestamp="Mon, 15th Octâ€™23 | 12:00pm"
        description="Your Personal Details for onboarding"
        stepProgress="full"
        marker={<StepItemIcon icon={UserIcon} color="positive" />}
      />
      <StepItem
        title="Business Details"
        trailing={
          <Badge color="positive" size="medium">
            Received by our team
          </Badge>
        }
        stepProgress="full"
        marker={<StepItemIcon icon={BriefcaseIcon} color="positive" />}
      />
      <StepItem
        title="Needs Response"
        titleColor="feedback.text.notice.intense"
        timestamp="Respond latest by Tue, 23rd Oct'24 | 12:00pm"
        stepProgress="start"
        marker={<StepItemIcon icon={ClockIcon} color="notice" />}
      />
      <StepItem
        title="Complete Onboarding"
        marker={<StepItemIcon icon={HeartIcon} color="neutral" />}
        trailing={
          <Badge color="neutral" size="medium">
            Pending
          </Badge>
        }
      />
    </StepGroup>
  );
}
```

### Interactive StepGroup with Click Handlers

This example shows how to create an interactive StepGroup where steps can be selected via click events, with visual feedback and state management to track the current selected step.

```tsx
import { StepGroup, StepItem, StepItemIndicator, Button, Box } from '@razorpay/blade/components';
import { useState } from 'react';

function InteractiveStepGroup() {
  const [selectedIndex, setSelectedIndex] = useState(-1);

  const stepItems = [
    {
      title: 'Introduction',
      timestamp: 'Mon, 15th Octâ€™23 | 12:00pm',
      description: 'Introduction to Razorpay Payment Gateway',
    },
    {
      title: 'Personal Details',
      timestamp: 'Mon, 16th Octâ€™23 | 12:00pm',
      description: 'Fill your Personal Details for onboarding',
    },
    {
      title: 'Business Details',
      timestamp: 'Mon, 17th Octâ€™23 | 12:00pm',
      description: 'Fill your Business Details for onboarding',
      isDisabled: true,
    },
    {
      title: 'Complete Onboarding',
      timestamp: 'Mon, 20th Octâ€™23 | 12:00pm',
      description: 'Complete your onboarding to start',
    },
  ];

  return (
    <Box>
      <StepGroup orientation="vertical" size="medium">
        {stepItems.map((stepInfo, index) => (
          <StepItem
            key={`${stepInfo.title}-${index}`}
            isSelected={selectedIndex === index}
            marker={<StepItemIndicator color={selectedIndex === index ? 'primary' : 'neutral'} />}
            onClick={() => setSelectedIndex(index)}
            stepProgress={
              index === selectedIndex ? 'start' : index < selectedIndex ? 'full' : 'none'
            }
            {...stepInfo}
          />
        ))}
      </StepGroup>

      {selectedIndex >= 0 && (
        <Box marginTop="spacing.8">
          <Button size="medium" variant="primary">
            Continue to Next Step
          </Button>
        </Box>
      )}
    </Box>
  );
}
```

### Nested StepGroup with Collapsible Sections

This example demonstrates a complex implementation with nested StepGroups and collapsible sections that can be expanded to reveal additional step details, useful for displaying hierarchical processes.

```tsx
import {
  StepGroup,
  StepItem,
  StepItemIcon,
  StepItemIndicator,
  Badge,
  Box,
  Button,
  Collapsible,
  CollapsibleBody,
  CollapsibleLink,
  RazorpayIcon,
  BriefcaseIcon,
  ClockIcon,
} from '@razorpay/blade/components';
import { useState } from 'react';

function NestedStepGroup() {
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <StepGroup orientation="vertical" size="medium" width="100%" maxWidth="600px">
      <StepItem
        title="Disputes Raised"
        timestamp="Thu, 11th Octâ€™23 | 12:00pm"
        stepProgress="full"
        marker={<StepItemIndicator color="positive" />}
      />
      <StepItem
        title="Disputes Under Review"
        trailing={
          <Badge color="positive" size="medium">
            Received by our team
          </Badge>
        }
        stepProgress="full"
        marker={<StepItemIndicator color="positive" />}
      />
      <StepGroup>
        <StepItem
          title="Review from Razorpay Team"
          timestamp="Fri, 12th Octâ€™23 | 12:00pm"
          description="The dispute is reviewed by Razorpay team"
          stepProgress="full"
          marker={<StepItemIcon icon={RazorpayIcon} color="positive" />}
        />
      </StepGroup>

      <StepItem
        title="Needs Response"
        timestamp="Respond latest by Tue, 23rd Oct'24 | 12:00pm"
        stepProgress="start"
        marker={<StepItemIndicator color="positive" />}
      />

      <Collapsible
        onExpandChange={({ isExpanded: newIsExpanded }) => setIsExpanded(newIsExpanded)}
        direction="top"
      >
        <CollapsibleLink>{isExpanded ? 'Hide Details' : 'Show Details'}</CollapsibleLink>
        <CollapsibleBody>
          <StepGroup>
            <StepItem
              title="Personal Documents Submission"
              marker={<StepItemIndicator color="positive" />}
              stepProgress="full"
            />
            <StepItem
              title="Company Documents Submission"
              titleColor="feedback.text.notice.intense"
              marker={<StepItemIndicator color="notice" />}
              stepProgress="start"
            >
              <Button size="medium" variant="secondary">
                Submit Documents
              </Button>
            </StepItem>
            <StepItem
              title="Documents Approval"
              trailing={
                <Badge color="neutral" size="medium">
                  Pending
                </Badge>
              }
            />
          </StepGroup>
        </CollapsibleBody>
      </Collapsible>

      <StepItem
        title="Decision from the Bank"
        trailing={
          <Badge color="neutral" size="medium">
            Pending
          </Badge>
        }
      />
    </StepGroup>
  );
}
```

### Horizontal StepGroup

This example shows a horizontal orientation of the StepGroup component, ideal for representing a linear progression of steps across the page rather than vertically down the page.

```tsx
import { StepGroup, StepItem, StepItemIndicator, Box } from '@razorpay/blade/components';

function HorizontalStepGroup() {
  return (
    <Box width="100%">
      <StepGroup orientation="horizontal" size="medium">
        <StepItem
          title="Introduction"
          stepProgress="full"
          marker={<StepItemIndicator color="positive" />}
        />
        <StepItem
          title="Personal Details"
          stepProgress="full"
          marker={<StepItemIndicator color="positive" />}
        />
        <StepItem
          title="Business Details"
          stepProgress="start"
          marker={<StepItemIndicator color="primary" />}
          isSelected={true}
        />
        <StepItem title="Document Verification" marker={<StepItemIndicator color="neutral" />} />
        <StepItem title="Complete Onboarding" marker={<StepItemIndicator color="neutral" />} />
      </StepGroup>
    </Box>
  );
}
```

---

## Switch

## Component Name

Switch

## Description

A switch component is used to quickly switch between two possible states. These are only used for binary actions that occur immediately after the user turns the switch on/off. The component supports controlled and uncontrolled modes, different sizes, and accessibility features to ensure proper screen reader support.

## TypeScript Types

The following types represent the props that the Switch component accepts. These types are essential for properly implementing and using the Switch component in your applications.

```typescript
type OnChange = ({
  isChecked,
  value,
  event,
}: {
  isChecked: boolean;
  event?: React.ChangeEvent;
  value?: string;
}) => void;

type SwitchProps = {
  /**
   * If `true`, The switch will be checked. This also makes the switch controlled
   * Use `onChange` to update its value
   *
   * @default false
   */
  isChecked?: boolean;
  /**
   * If `true`, the switch will be initially checked. This also makes the switch uncontrolled
   *
   * @default false
   */
  defaultChecked?: boolean;
  /**
   * The callback invoked when the checked state of the `Switch` changes.
   */
  onChange?: OnChange;
  /**
   * The name of the input field in a switch
   * (Useful for form submission).
   */
  name?: string;
  /**
   * The value to be used in the switch input.
   * This is the value that will be returned on form submission.
   */
  value?: string;
  /**
   * If `true`, the switch will be disabled
   *
   * @default false
   */
  isDisabled?: boolean;
  /**
   * Size of the switch
   *
   * @default "medium"
   */
  size?: 'small' | 'medium';
  /**
   * Provides accessible label for internal checkbox component that sets the aria-label prop for screen readers.
   */
  accessibilityLabel: string;
  /**
   * The id of the input field in a switch, useful for associating a label element with the input via htmlFor prop
   */
  id?: string;
} & TestID &
  DataAnalyticsAttribute &
  StyledPropsBlade &
  MotionMetaProp;
```

## Example

### Basic Usage

This example demonstrates the basic usage of the Switch component with essential props:

```tsx
import React from 'react';
import { Switch } from '@razorpay/blade/components';

function BasicExample() {
  return (
    <Switch
      accessibilityLabel="Toggle dark mode"
      onChange={(e) => console.log('Switch toggled:', e.isChecked)}
    />
  );
}

export default BasicExample;
```

---

## Table

## Component Name

Table

## Description

A table component that displays data in a grid format through rows and columns of cells. Table facilitates data organization and allows users to scan, sort, compare, and take action on large amounts of data. It supports features like row selection, pagination, sorting, sticky headers/footers, and customizable cell content.

## Important Constraints

- `Table` `toolbar` prop only accepts `TableToolbar` component

## TypeScript Types

These types define the props that the Table component and its subcomponents accept, helping you understand how to use them properly in your application.

```typescript
// The base identifier type used in tables
type Identifier = string | number;

// Defines the shape of a table node (row)
type TableNode<Item> = Item & {
  id: Identifier;
};

// The main data structure passed to Table
type TableData<Item> = {
  nodes: TableNode<Item>[];
};

// Main Table component props
type TableProps<Item> = {
  /**
   * The children of the Table component should be a function that returns TableHeader, TableBody and TableFooter components.
   * The function will be called with the tableData prop.
   */
  children: (tableData: TableNode<Item>[]) => React.ReactElement;

  /**
   * The data prop is an object with a nodes property that is an array of objects.
   * Each object in the array is a row in the table.
   * The object should have an id property that is a unique identifier for the row.
   */
  data: TableData<Item>;

  /**
   * Selection mode determines how the table rows can be selected.
   * @default 'row'
   **/
  multiSelectTrigger?: 'checkbox' | 'row';

  /**
   * The selectionType prop determines the type of selection that is allowed on the table.
   * @default 'none'
   **/
  selectionType?: 'none' | 'single' | 'multiple';

  /**
   * The onSelectionChange prop is a function that is called when the selection changes.
   **/
  onSelectionChange?: ({
    values,
    selectedIds,
  }: {
    values: TableNode<Item>[];
    selectedIds: Identifier[];
  }) => void;

  /**
   * The isHeaderSticky prop determines whether the table header is sticky or not.
   * @default false
   **/
  isHeaderSticky?: boolean;

  /**
   * The isFooterSticky prop determines whether the table footer is sticky or not.
   * @default false
   **/
  isFooterSticky?: boolean;

  /**
   * The isFirstColumnSticky prop determines whether the first column is sticky or not.
   * @default false
   **/
  isFirstColumnSticky?: boolean;

  /**
   * The rowDensity prop determines the density of the table.
   * @default 'normal'
   **/
  rowDensity?: 'compact' | 'normal' | 'comfortable';

  /**
   * The onSortChange prop is a function that is called when the sort changes.
   **/
  onSortChange?: ({
    sortKey,
    isSortReversed,
  }: {
    sortKey: string | undefined;
    isSortReversed: boolean;
  }) => void;

  /**
   * The sortFunctions prop is an object that has a key for each column that is sortable.
   **/
  sortFunctions?: Record<string, (array: TableNode<Item>[]) => TableNode<Item>[]>;

  /**
   * The toolbar prop is a React element that is rendered above the table.
   **/
  toolbar?: React.ReactElement;

  /**
   * The pagination prop is a React element that is rendered below the table.
   **/
  pagination?: React.ReactElement;

  /**
   * The height prop is a responsive styled prop that determines the height of the table.
   **/
  height?: BoxProps['height'];

  /**
   * The showStripedRows prop determines whether the table should have striped rows or not.
   * @default false
   **/
  showStripedRows?: boolean;

  /**
   * The gridTemplateColumns prop determines the grid-template-columns CSS property of the table.
   * @default `repeat(${columnCount},minmax(100px, 1fr))`
   **/
  gridTemplateColumns?: string;

  /**
   * The isLoading prop determines whether the table is loading or not.
   * @default false
   **/
  isLoading?: boolean;

  /**
   * The isRefreshing prop determines whether the table is refreshing or not.
   * @default false
   **/
  isRefreshing?: boolean;

  /**
   * The showBorderedCells prop determines whether the table should have bordered cells or not.
   **/
  showBorderedCells?: boolean;

  /**
   * An array of default selected row ids. This will be used to set the initial selected rows.
   */
  defaultSelectedIds?: Identifier[];

  /**
   * The backgroundColor prop determines the background color of the table.
   **/
  backgroundColor?: string | 'transparent';
};

// TableHeader component props
type TableHeaderProps = {
  /**
   * The children of TableHeader should be TableHeaderRow
   **/
  children: React.ReactNode;
};

// TableHeaderRow component props
type TableHeaderRowProps = {
  /**
   * The children of TableHeaderRow should be TableHeaderCell
   **/
  children: React.ReactNode;
  /**
   * The rowDensity prop determines the density of the table.
   **/
  rowDensity?: TableProps<unknown>['rowDensity'];
};

// TableHeaderCell component props
type TableHeaderCellProps = {
  /**
   * The children of TableHeaderCell can be a string or a ReactNode.
   **/
  children: string | React.ReactNode;
  /**
   * The unique key of the column.
   * This is used to identify the column for sorting in sortFunctions prop of Table.
   **/
  headerKey?: string;
  /**
   * The textAlign prop determines the content alignment of the table.
   * @default 'left'
   **/
  textAlign?: 'left' | 'center' | 'right';
};

// TableBody component props
type TableBodyProps<Item> = {
  /**
   * The children of the TableBody component should be TableRow components.
   **/
  children: React.ReactNode | ((tableItem: Item, index: number) => React.ReactElement);
};

// TableRow component props
type TableRowProps<Item> = {
  /**
   * The children of the TableRow component should be TableCell components.
   **/
  children: React.ReactNode;
  /**
   * The item prop is used to pass the individual table item to the TableRow component.
   **/
  item: TableNode<Item>;
  /**
   * The isDisabled prop is used to disable the TableRow component.
   **/
  isDisabled?: boolean;
  /**
   * Callback triggered when the row is hovered.
   */
  onHover?: ({ item }: { item: TableNode<Item> }) => void;
  /**
   * Callback triggered when the row is clicked.
   */
  onClick?: ({ item }: { item: TableNode<Item> }) => void;
  /**
   * Actions to display when hovering over the row
   */
  hoverActions?: React.ReactElement;
};

// TableCell component props
type TableCellProps = {
  /**
   * The children of the TableCell component should be a string or a ReactNode.
   **/
  children: React.ReactNode;
  /**
   * The textAlign prop determines the content alignment of the table.
   * @default 'left'
   **/
  textAlign?: 'left' | 'center' | 'right';
};

// TableEditableCell component props
type TableEditableCellProps = {
  // Input related props
  validationState?: 'none' | 'error' | 'success';
  placeholder?: string;
  defaultValue?: string;
  name?: string;
  onChange?: (value: string) => void;
  onFocus?: () => void;
  onBlur?: () => void;
  value?: string;
  isDisabled?: boolean;
  isRequired?: boolean;
  prefix?: React.ReactNode;
  suffix?: React.ReactNode;
  maxCharacters?: number;
  autoFocus?: boolean;
  errorText?: string;
  successText?: string;
  // Required prop
  accessibilityLabel: string;
};

// TableFooter component props
type TableFooterProps = {
  /**
   * The children of TableFooter should be TableFooterRow
   **/
  children: React.ReactNode;
};

// TableFooterRow component props
type TableFooterRowProps = {
  /**
   * The children of TableFooterRow should be TableFooterCell
   **/
  children: React.ReactNode;
};

// TableFooterCell component props
type TableFooterCellProps = {
  /**
   * The children of TableHeaderCell can be a string or a ReactNode.
   **/
  children: string | React.ReactNode;
  /**
   * The textAlign prop determines the content alignment of the table.
   * @default 'left'
   **/
  textAlign?: 'left' | 'center' | 'right';
};

// TableToolbar component props
type TableToolbarProps = {
  /**
   * The children of TableToolbar should be TableToolbarActions
   */
  children?: React.ReactNode;
  /**
   * The title of the TableToolbar.
   * @default `Showing 1 to ${totalItems} Items`
   */
  title?: string;
  /**
   * The title to show when items are selected.
   * @default `${selectedRows.length} 'Items'} Selected`
   */
  selectedTitle?: string;
  /**
   * Controls how the TableToolbar is positioned relative to the TableHeader.
   * - `inline`: Renders the toolbar above the TableHeader as part of the normal layout (default).
   * - `overlay`: Renders the toolbar over the TableHeader.
   *
   * Defaults to `inline`.
   */
  placement?: 'inline' | 'overlay';
};

// TablePagination component props
type TablePaginationProps = {
  /**
   * The default page size.
   * @default 10
   **/
  defaultPageSize?: 10 | 25 | 50;

  /**
   * The current page. Passing this prop will make the component controlled.
   **/
  currentPage?: number;

  /**
   * Callback function that is called when the page size is changed
   */
  onPageSizeChange?: ({ pageSize }: { pageSize: number }) => void;

  /**
   * Whether to show the page size picker.
   * @default true
   */
  showPageSizePicker?: boolean;

  /**
   * Whether to show the page number selector.
   * @default false
   */
  showPageNumberSelector?: boolean;

  /**
   * Content of the label to be shown in the pagination component
   */
  label?: string;

  /**
   * Whether to show the label.
   * @default false
   */
  showLabel?: boolean;

  /**
   * Whether the pagination is happening on client or server.
   * @default 'client'
   */
  paginationType?: 'client' | 'server';

  /**
   * The total number of possible items in the table.
   * Required when paginationType is 'server'.
   */
  totalItemCount?: number;

  /**
   * Callback function that is called when the page is changed.
   * Required when paginationType is 'server'.
   */
  onPageChange?: ({ page }: { page: number }) => void;
};
```

## Example

### Comprehensive Table with Advanced Features

This example demonstrates a fully-featured payment transactions table with multiple interactive elements including selection, sorting, sticky headers, row actions, editable cells, custom toolbar, pagination, and footer summaries.

```tsx
import React, { useState } from 'react';
import {
  Table,
  TableHeader,
  TableHeaderRow,
  TableHeaderCell,
  TableBody,
  TableRow,
  TableCell,
  TableEditableCell,
  TableFooter,
  TableFooterRow,
  TableFooterCell,
  TableToolbar,
  TableToolbarActions,
  TablePagination,
  TableData,
  TableNode,
  Box,
  Text,
  Code,
  Button,
  IconButton,
  Badge,
  Amount,
  CheckIcon,
  CloseIcon,
  PlusIcon,
} from '@razorpay/blade/components';

// Define your data types
type PaymentItem = {
  id: string;
  paymentId: string;
  amount: number;
  status: 'Completed' | 'Pending' | 'Failed';
  date: Date;
  type: 'Payout' | 'Refund';
  method: string;
  bank: string;
  account: string;
  name: string;
};

const PaymentTable = () => {
  // Sample data
  const payments: PaymentItem[] = Array.from({ length: 50 }, (_, i) => ({
    id: (i + 1).toString(),
    paymentId: `rzp${Math.floor(Math.random() * 1000000)}`,
    amount: Number((Math.random() * 10000).toFixed(2)),
    status: ['Completed', 'Pending', 'Failed'][Math.floor(Math.random() * 3)] as
      | 'Completed'
      | 'Pending'
      | 'Failed',
    date: new Date(2023, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1),
    type: ['Payout', 'Refund'][Math.floor(Math.random() * 2)] as 'Payout' | 'Refund',
    method: ['Bank Transfer', 'Credit Card', 'PayPal'][Math.floor(Math.random() * 3)],
    bank: ['HDFC', 'ICICI', 'SBI'][Math.floor(Math.random() * 3)],
    account: Math.floor(Math.random() * 1000000000).toString(),
    name: ['John Doe', 'Jane Smith', 'Bob Johnson'][Math.floor(Math.random() * 3)],
  }));

  const tableData: TableData<PaymentItem> = {
    nodes: payments,
  };

  // State for selection
  const [selectedIds, setSelectedIds] = useState<string[]>([]);

  // Handle selection change
  const handleSelectionChange = ({ selectedIds }: { selectedIds: (string | number)[] }) => {
    setSelectedIds(selectedIds as string[]);
    console.log('Selected IDs:', selectedIds);
  };

  // Define sort functions
  const sortFunctions = {
    PAYMENT_ID: (array: TableNode<PaymentItem>[]) =>
      [...array].sort((a, b) => a.paymentId.localeCompare(b.paymentId)),
    AMOUNT: (array: TableNode<PaymentItem>[]) => [...array].sort((a, b) => a.amount - b.amount),
    DATE: (array: TableNode<PaymentItem>[]) =>
      [...array].sort((a, b) => a.date.getTime() - b.date.getTime()),
    STATUS: (array: TableNode<PaymentItem>[]) =>
      [...array].sort((a, b) => a.status.localeCompare(b.status)),
  };

  return (
    <Box padding="spacing.5" overflow="auto" minHeight="400px">
      <Table
        data={tableData}
        defaultSelectedIds={['1', '3']}
        onSelectionChange={handleSelectionChange}
        isFirstColumnSticky
        isHeaderSticky
        selectionType="multiple"
        rowDensity="normal"
        showStripedRows
        showBorderedCells
        sortFunctions={sortFunctions}
        toolbar={
          <TableToolbar
            title="Payment Transactions"
            selectedTitle={`${selectedIds.length} Payments Selected`}
          >
            <TableToolbarActions>
              <Button variant="secondary" marginRight="spacing.2" icon={PlusIcon}>
                Export
              </Button>
              <Button>Process Selected</Button>
            </TableToolbarActions>
          </TableToolbar>
        }
        pagination={
          <TablePagination
            defaultPageSize={10}
            showPageSizePicker
            showPageNumberSelector
            onPageChange={({ page }) => console.log('Page changed:', page)}
            onPageSizeChange={({ pageSize }) => console.log('Page size changed:', pageSize)}
          />
        }
      >
        {(tableData) => (
          <>
            <TableHeader>
              <TableHeaderRow>
                <TableHeaderCell headerKey="PAYMENT_ID">Payment ID</TableHeaderCell>
                <TableHeaderCell headerKey="AMOUNT" textAlign="right">
                  Amount
                </TableHeaderCell>
                <TableHeaderCell>Account</TableHeaderCell>
                <TableHeaderCell headerKey="DATE">Date</TableHeaderCell>
                <TableHeaderCell>Method</TableHeaderCell>
                <TableHeaderCell headerKey="STATUS">Status</TableHeaderCell>
                <TableHeaderCell textAlign="center">Actions</TableHeaderCell>
              </TableHeaderRow>
            </TableHeader>

            <TableBody>
              {tableData.map((tableItem, index) => (
                <TableRow
                  key={index}
                  item={tableItem}
                  onClick={({ item }) => console.log('Row clicked:', item.id)}
                  onHover={({ item }) => console.log('Row hovered:', item.id)}
                  hoverActions={
                    <>
                      <Button variant="tertiary" size="xsmall">
                        View Details
                      </Button>
                      <IconButton
                        icon={CheckIcon}
                        isHighlighted
                        accessibilityLabel="Approve"
                        onClick={() => console.log('Approved', tableItem.paymentId)}
                      />
                      <IconButton
                        icon={CloseIcon}
                        isHighlighted
                        accessibilityLabel="Reject"
                        onClick={() => console.log('Rejected', tableItem.paymentId)}
                      />
                    </>
                  }
                >
                  <TableCell>
                    <Code size="medium">{tableItem.paymentId}</Code>
                  </TableCell>
                  <TableCell textAlign="right">
                    <Amount value={tableItem.amount} />
                  </TableCell>
                  <TableEditableCell
                    accessibilityLabel="Account"
                    placeholder="Enter account number"
                    defaultValue={tableItem.account}
                    successText="Account is valid"
                    onChange={(value) => console.log('Account changed:', value)}
                  />
                  <TableCell>
                    {tableItem.date.toLocaleDateString('en-IN', {
                      year: 'numeric',
                      month: '2-digit',
                      day: '2-digit',
                    })}
                  </TableCell>
                  <TableCell>{tableItem.method}</TableCell>
                  <TableCell>
                    <Badge
                      size="medium"
                      color={
                        tableItem.status === 'Completed'
                          ? 'positive'
                          : tableItem.status === 'Pending'
                          ? 'notice'
                          : 'negative'
                      }
                    >
                      {tableItem.status}
                    </Badge>
                  </TableCell>
                  <TableCell textAlign="center">
                    <Box display="flex" justifyContent="center" gap="spacing.2">
                      <IconButton
                        icon={CheckIcon}
                        accessibilityLabel="Approve"
                        onClick={() => console.log('Approved', tableItem.id)}
                      />
                      <IconButton
                        icon={CloseIcon}
                        accessibilityLabel="Reject"
                        onClick={() => console.log('Rejected', tableItem.id)}
                      />
                    </Box>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>

            <TableFooter>
              <TableFooterRow>
                <TableFooterCell>Total</TableFooterCell>
                <TableFooterCell textAlign="right">
                  <Amount
                    value={tableData.reduce((sum, item) => sum + item.amount, 0)}
                    weight="semibold"
                  />
                </TableFooterCell>
                <TableFooterCell>-</TableFooterCell>
                <TableFooterCell>-</TableFooterCell>
                <TableFooterCell>-</TableFooterCell>
                <TableFooterCell>-</TableFooterCell>
                <TableFooterCell>-</TableFooterCell>
              </TableFooterRow>
            </TableFooter>
          </>
        )}
      </Table>
    </Box>
  );
};

export default PaymentTable;
```

### Server-Side Pagination Example

This example shows how to implement a table with server-side pagination, where data is fetched from an API based on the current page, with loading states and proper handling of page changes.

```tsx
import React, { useState, useEffect } from 'react';
import {
  Table,
  TableHeader,
  TableHeaderRow,
  TableHeaderCell,
  TableBody,
  TableRow,
  TableCell,
  TablePagination,
  TableData,
  Box,
  Spinner,
} from '@razorpay/blade/components';

type User = {
  id: string;
  name: string;
  email: string;
  role: string;
};

const ServerPaginatedTable = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [currentPage, setCurrentPage] = useState(0);
  const [totalCount, setTotalCount] = useState(0);
  const pageSize = 10;

  // Simulated API fetch
  const fetchUsers = async (page: number) => {
    setLoading(true);

    // Replace with actual API call
    setTimeout(() => {
      // Mock data generation for demonstration
      const newUsers = Array.from({ length: pageSize }, (_, i) => ({
        id: `user-${page * pageSize + i + 1}`,
        name: `User ${page * pageSize + i + 1}`,
        email: `user${page * pageSize + i + 1}@example.com`,
        role: ['Admin', 'User', 'Editor'][Math.floor(Math.random() * 3)],
      }));

      setUsers(newUsers);
      setTotalCount(100); // Total count from API
      setLoading(false);
    }, 500);
  };

  useEffect(() => {
    fetchUsers(currentPage);
  }, [currentPage]);

  const handlePageChange = ({ page }: { page: number }) => {
    setCurrentPage(page);
  };

  const tableData: TableData<User> = {
    nodes: users,
  };

  return (
    <Box padding="spacing.5">
      <Table
        data={tableData}
        isLoading={loading}
        pagination={
          <TablePagination
            paginationType="server"
            totalItemCount={totalCount}
            onPageChange={handlePageChange}
            currentPage={currentPage}
            defaultPageSize={pageSize}
            showPageSizePicker={false}
            showPageNumberSelector
          />
        }
      >
        {(tableData) => (
          <>
            <TableHeader>
              <TableHeaderRow>
                <TableHeaderCell>ID</TableHeaderCell>
                <TableHeaderCell>Name</TableHeaderCell>
                <TableHeaderCell>Email</TableHeaderCell>
                <TableHeaderCell>Role</TableHeaderCell>
              </TableHeaderRow>
            </TableHeader>

            <TableBody>
              {tableData.map((user, index) => (
                <TableRow key={index} item={user}>
                  <TableCell>{user.id}</TableCell>
                  <TableCell>{user.name}</TableCell>
                  <TableCell>{user.email}</TableCell>
                  <TableCell>{user.role}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </>
        )}
      </Table>
    </Box>
  );
};

export default ServerPaginatedTable;
```

### Table Nesting Pattern

Hierarchical data display with expandable rows and animations. Use for parent-child relationships or detailed information.

```tsx
import React, { useState } from 'react';
import {
  Table,
  TableHeader,
  TableHeaderRow,
  TableHeaderCell,
  TableBody,
  TableRow,
  TableCell,
  Button,
  Badge,
  Box,
  Text,
  ChevronDownIcon,
  ChevronRightIcon,
} from '@razorpay/blade/components';

type Data = {
  id: string;
  name: string;
  totalAmount: number;
  status: string;
  nestedData: Data[];
};

type TableData = Data[];

const tableData: TableData = [
  {
    id: '1',
    name: 'John Doe',
    totalAmount: 100,
    status: 'Completed',
    nestedData: [],
  },
  {
    id: '2',
    name: 'Jane Smith',
    totalAmount: 200,
    status: 'Pending',
    nestedData: [],
  },
];
const TableNestingExample = () => {
  const [expandedRows, setExpandedRows] = useState<Set<string>>(new Set());

  const toggleRow = (id: string) => {
    const newExpanded = new Set(expandedRows);
    if (newExpanded.has(id)) {
      newExpanded.delete(id);
    } else {
      newExpanded.add(id);
    }
    setExpandedRows(newExpanded);
  };

  return (
    <Table data={{ nodes: tableData }}>
      {(tableData) => (
        <>
          <TableHeader>
            <TableHeaderRow>
              <TableHeaderCell>Name</TableHeaderCell>
              <TableHeaderCell>Amount</TableHeaderCell>
              <TableHeaderCell>Status</TableHeaderCell>
            </TableHeaderRow>
          </TableHeader>

          <TableBody>
            {tableData.map((item) => (
              <>
                <TableRow key={item.id} item={item}>
                  <TableCell>
                    <Button
                      variant="tertiary"
                      size="xsmall"
                      icon={expandedRows.has(item.id) ? ChevronDownIcon : ChevronRightIcon}
                      onClick={() => toggleRow(item.id)}
                    />
                    {item.name}
                  </TableCell>
                  <TableCell>{item.totalAmount}</TableCell>
                  <TableCell>
                    <Badge color="positive">{item.status}</Badge>
                  </TableCell>
                </TableRow>

                {expandedRows.has(String(item.id)) && (
                  <TableRow key={`${item.id}-expanded`} item={item}>
                    <TableCell gridColumnStart={1} gridColumnEnd={4}>
                      <Box
                        backgroundColor="surface.background.gray.subtle"
                        padding="spacing.4"
                        borderRadius="medium"
                        margin="spacing.2"
                      >
                        {/* Nested content here */}
                        {item.nestedData?.map((child) => (
                          <Box key={child.id} display="flex" justifyContent="space-between">
                            <Text>{child.name}</Text>
                            <Text>{child.totalAmount}</Text>
                          </Box>
                        ))}
                      </Box>
                    </TableCell>
                  </TableRow>
                )}
              </>
            ))}
          </TableBody>
        </>
      )}
    </Table>
  );
};

export default TableNestingExample;
```

### Table Spanning Pattern

Row and column spanning for complex layouts with merged cells. Use for grouping related data or creating summary sections. Use grid props on TableCell to span across multiple rows or columns for merged cells.

```jsx
{/* Header spanning */}
<TableHeaderCell gridColumnStart={2} gridColumnEnd={4}>
  Combined Header
</TableHeaderCell>

<TableRow item={item}>
  {/* Span across multiple columns */}
  <TableCell gridColumnStart={1} gridColumnEnd={4}>
    Summary spanning 3 columns
  </TableCell>
</TableRow>

<TableRow item={item}>
  {/* Span across multiple rows */}
  <TableCell gridRowStart={2} gridRowEnd={4}>
    Group spanning 2 rows
  </TableCell>
</TableRow>

{/* Footer spanning */}
<TableFooterCell gridColumnStart={1} gridColumnEnd={3}>
  Total
</TableFooterCell>
```

### Table Grouping Pattern

Hierarchical grouped data with automatic tree structure. Use for categorized data with parent-child relationships.

```jsx
const TableGroupingExample = () => {
  return (
    <Table data={groupedData} isGrouped showBorderedCells>
      {(tableData) => (
        <>
          <TableHeader>
            <TableHeaderRow>
              <TableHeaderCell>Category</TableHeaderCell>
              <TableHeaderCell>Amount</TableHeaderCell>
              <TableHeaderCell>Status</TableHeaderCell>
            </TableHeaderRow>
          </TableHeader>

          <TableBody>
            {tableData.map((item, index) => (
              <TableRow key={index} item={item}>
                <TableCell
                  gridColumnStart={item.treeXLevel === 0 ? 1 : undefined}
                  gridColumnEnd={item.treeXLevel === 0 ? 4 : undefined}
                >
                  {item.name}
                </TableCell>
                {item.treeXLevel !== 0 && (
                  <>
                    <TableCell>{item.amount}</TableCell>
                    <TableCell>{item.status}</TableCell>
                  </>
                )}
              </TableRow>
            ))}
          </TableBody>
        </>
      )}
    </Table>
  );
};
```

---

## Tabs

## Component Name

Tabs

## Description

The Tabs component is a navigation element used to switch between different views in the same context. Tabs are contextual to a section or page and are triggered by user interaction. They provide an organized way to display related content while maintaining a clean user interface.

## Important Constraints

- `Tabs` component requires a `TabList` as a child

## TypeScript Types

These types represent the props that the Tabs component and its subcomponents accept.

```typescript
// Main Tabs component props
type TabsProps = {
  /**
   * The content of the component, accepts `TabList` and `TabPanel` components.
   */
  children: React.ReactNode;

  /**
   * The value of the tab panel same as the corresponding TabItem's value to match the selected TabItem.
   */
  value?: string;

  /**
   * The default value of the selected tab, in case the Tabs component is uncontrolled.
   */
  defaultValue?: string;

  /**
   * Callback fired when the value changes.
   */
  onChange?: (value: string) => void;

  /**
   * The orientation of the tabs.
   *
   * @default 'horizontal' (always horizontal on react-native)
   */
  orientation?: 'horizontal' | 'vertical';

  /**
   * The size of the tabs.
   *
   * @default 'medium'
   */
  size?: 'medium' | 'large';

  /**
   * The variant of the tabs.
   *
   * @default 'bordered'
   */
  variant?: 'bordered' | 'borderless' | 'filled';

  /**
   * If `true`, the TabItems will grow to use all the available space.
   *
   * @default false
   */
  isFullWidthTabItem?: boolean;

  /**
   * If `true`, the TabPanel will be rendered only when it becomes active.
   *
   * @default false
   */
  isLazy?: boolean;
} & DataAnalyticsAttribute;

// TabItem component props
type TabItemProps = {
  /**
   * The content of the tab item.
   */
  children: React.ReactNode;

  /**
   * The value of the tab item.
   */
  value: string;

  /**
   * Leading element of the tab item.
   * Can be used to render an Icon.
   */
  leading?: IconComponent;

  /**
   * Trailing element of the tab item.
   * Can be used to render a Badge/Counter component.
   */
  trailing?: React.ReactNode;

  /**
   * If `true`, the tab item will be disabled.
   */
  isDisabled?: boolean;

  /**
   * If set the tab item will be rendered as a link.
   * This can be used to create a tab item that redirects to another page or integrate with react-router.
   *
   * @default undefined
   */
  href?: string;

  /**
   * Callback fired when the tab item is clicked.
   */
  onClick?: (event: React.MouseEvent) => void;
};

// TabPanel component props
type TabPanelProps = {
  /**
   * The value of the tab panel. This will be used to match the selected tab.
   */
  value: string;

  /**
   * The content of the tab panel.
   */
  children: React.ReactNode;
} & DataAnalyticsAttribute;

// TabList has no specific props other than children and common styling props
```

## Example

### Basic Usage

This example demonstrates the fundamental implementation of Tabs with a bordered horizontal layout, showing how to structure TabList, TabItems, and TabPanels.

```tsx
import { Box, Text, Tabs, TabList, TabItem, TabPanel } from '@razorpay/blade/components';

function BasicTabsExample() {
  return (
    <Tabs variant="bordered" orientation="horizontal">
      <TabList>
        <TabItem value="subscriptions">Subscription</TabItem>
        <TabItem value="plans">Plans</TabItem>
        <TabItem value="settings">Settings</TabItem>
      </TabList>

      <TabPanel value="subscriptions">
        <Box paddingTop="spacing.4">
          <Text>Subscriptions Panel Content</Text>
        </Box>
      </TabPanel>
      <TabPanel value="plans">
        <Box paddingTop="spacing.4">
          <Text>Plans Panel Content</Text>
        </Box>
      </TabPanel>
      <TabPanel value="settings">
        <Box paddingTop="spacing.4">
          <Text>Settings Panel Content</Text>
        </Box>
      </TabPanel>
    </Tabs>
  );
}
```

### Controlled Tabs

This example shows how to create controlled tabs where the active tab is managed by state, allowing programmatic tab switching through external controls.

```tsx
import { Box, Text, Tabs, TabList, TabItem, TabPanel, Button } from '@razorpay/blade/components';
import React from 'react';

function ControlledTabsExample() {
  const [activeTab, setActiveTab] = React.useState('plans');

  return (
    <Box>
      <Text weight="semibold" marginBottom="spacing.4">
        Current Tab: {activeTab}
      </Text>

      <Box display="flex" gap="spacing.4" marginBottom="spacing.4">
        <Button variant="tertiary" onClick={() => setActiveTab('subscriptions')}>
          Go to Subscriptions
        </Button>
        <Button variant="tertiary" onClick={() => setActiveTab('plans')}>
          Go to Plans
        </Button>
        <Button variant="tertiary" onClick={() => setActiveTab('settings')}>
          Go to Settings
        </Button>
      </Box>

      <Tabs value={activeTab} onChange={(newValue) => setActiveTab(newValue)}>
        <TabList>
          <TabItem value="subscriptions">Subscription</TabItem>
          <TabItem value="plans">Plans</TabItem>
          <TabItem value="settings">Settings</TabItem>
        </TabList>

        <TabPanel value="subscriptions">
          <Box paddingTop="spacing.4">
            <Text>Subscriptions Panel Content</Text>
          </Box>
        </TabPanel>
        <TabPanel value="plans">
          <Box paddingTop="spacing.4">
            <Text>Plans Panel Content</Text>
          </Box>
        </TabPanel>
        <TabPanel value="settings">
          <Box paddingTop="spacing.4">
            <Text>Settings Panel Content</Text>
          </Box>
        </TabPanel>
      </Tabs>
    </Box>
  );
}
```

### Tabs with Icons and Badges

This example demonstrates how to enhance tabs with visual elements like icons, counters, and badges to provide additional context and improve usability.

```tsx
import {
  Box,
  Text,
  Tabs,
  TabList,
  TabItem,
  TabPanel,
  Counter,
  Badge,
  SubscriptionsIcon,
  ClipboardIcon,
  SettingsIcon,
} from '@razorpay/blade/components';

function TabsWithIconsAndBadgesExample() {
  return (
    <Tabs variant="bordered" size="medium">
      <TabList>
        <TabItem
          value="subscriptions"
          leading={SubscriptionsIcon}
          trailing={<Counter value={3} color="positive" />}
        >
          Subscription
        </TabItem>
        <TabItem
          value="plans"
          leading={ClipboardIcon}
          trailing={<Badge color="positive">NEW</Badge>}
        >
          Plans
        </TabItem>
        <TabItem value="settings" leading={SettingsIcon}>
          Settings
        </TabItem>
      </TabList>

      <TabPanel value="subscriptions">
        <Box paddingTop="spacing.4">
          <Text>You have 3 active subscriptions</Text>
        </Box>
      </TabPanel>
      <TabPanel value="plans">
        <Box paddingTop="spacing.4">
          <Text>Check out our new plans!</Text>
        </Box>
      </TabPanel>
      <TabPanel value="settings">
        <Box paddingTop="spacing.4">
          <Text>Configure your settings here</Text>
        </Box>
      </TabPanel>
    </Tabs>
  );
}
```

---

## Tag

## Component Name

Tag

## Description

The Tag component displays interactive keywords that help organize and categorize objects. Tags can be added or removed from an object by users. They appear as small, dismissible pill-shaped elements with optional icons and are commonly used to represent selected items in interfaces.

## TypeScript Types

These types represent the props that the Tag component accepts.

```typescript
// Main Tag component props
type TagProps = {
  /**
   * Decides the size of Tag
   *
   * @default medium
   */
  size?: 'medium' | 'large';

  /**
   * Leading icon for your Tag
   */
  icon?: IconComponent;

  /**
   * Callback when close icon on Tag is clicked
   */
  onDismiss: () => void;

  /**
   * Text that renders inside Tag
   */
  children: StringChildrenType;

  /**
   * Disable tag
   */
  isDisabled?: boolean;

  /**
   * Private property for Blade.
   *
   * Should not be used by consumers.
   *
   * Used for adding virtual focus on tag.
   *
   * @private
   */
  _isVirtuallyFocused?: boolean;

  /**
   * Private property for Blade.
   *
   * Should not be used by consumers.
   *
   * Is tag placed inside an input
   *
   * @private
   */
  _isTagInsideInput?: boolean;
} & StyledPropsBlade &
  DataAnalyticsAttribute &
  TestID;
```

## Example

### Basic Usage

This example shows the simplest implementation of a Tag component with an icon and dismiss functionality.

```tsx
import React from 'react';
import { Tag, FileTextIcon } from '@razorpay/blade/components';

function BasicTagExample() {
  const [isTagVisible, setIsTagVisible] = React.useState(true);

  return (
    <>
      {isTagVisible ? (
        <Tag
          icon={FileTextIcon}
          onDismiss={() => {
            console.log('Unpaid Tag dismissed');
            setIsTagVisible(false);
          }}
        >
          Unpaid
        </Tag>
      ) : null}
    </>
  );
}
```

### Disabled Tag

This example demonstrates a Tag in its disabled state, where the dismiss functionality is visually indicated as unavailable but still defined in the code.

```tsx
import React from 'react';
import { Tag, FileTextIcon } from '@razorpay/blade/components';

function DisabledTagExample() {
  const [isTagVisible, setIsTagVisible] = React.useState(true);

  return (
    <>
      {isTagVisible ? (
        <Tag
          icon={FileTextIcon}
          isDisabled={true}
          onDismiss={() => {
            console.log('Disabled Tag dismissed');
            setIsTagVisible(false);
          }}
        >
          Disabled Tag
        </Tag>
      ) : null}
    </>
  );
}
```

### Different Size Tags

This example shows both medium and large Tag sizes side by side for comparison, each with their own dismiss handlers.

```tsx
import React from 'react';
import { Tag, Box, FileTextIcon } from '@razorpay/blade/components';

function TagSizesExample() {
  const [mediumTagVisible, setMediumTagVisible] = React.useState(true);
  const [largeTagVisible, setLargeTagVisible] = React.useState(true);

  return (
    <Box display="flex" gap="spacing.4" alignItems="center">
      {mediumTagVisible ? (
        <Tag size="medium" icon={FileTextIcon} onDismiss={() => setMediumTagVisible(false)}>
          Medium Tag
        </Tag>
      ) : null}

      {largeTagVisible ? (
        <Tag size="large" icon={FileTextIcon} onDismiss={() => setLargeTagVisible(false)}>
          Large Tag
        </Tag>
      ) : null}
    </Box>
  );
}
```

### Tag Group with Input

This example demonstrates how to implement a tag input system where users can add new tags through a text input and remove existing tags by clicking their dismiss buttons.

```tsx
import React from 'react';
import { Tag, Box, TextInput, Button, PlusIcon } from '@razorpay/blade/components';

function TagInputExample() {
  const [inputValue, setInputValue] = React.useState('');
  const [tags, setTags] = React.useState<string[]>([]);

  const addTag = (): void => {
    // Add input value to tags and clear the input value
    if (inputValue) {
      setTags([...tags, inputValue]);
      setInputValue('');
    }
  };

  const removeTag = (tagName: string): void => {
    setTags(tags.filter((tagNameValue) => tagNameValue !== tagName));
  };

  return (
    <Box>
      <Box paddingY="spacing.4">
        {tags.map((tagName) => (
          <Tag key={tagName} marginRight="spacing.2" onDismiss={() => removeTag(tagName)}>
            {tagName}
          </Tag>
        ))}
      </Box>

      <Box>
        <form
          onSubmit={(e) => {
            e.preventDefault();
            addTag();
          }}
        >
          <TextInput
            label="Tag Label"
            value={inputValue}
            onChange={({ value }) => setInputValue(value ?? '')}
          />
          <Button
            icon={PlusIcon}
            iconPosition="right"
            variant="secondary"
            marginTop="spacing.2"
            type="submit"
          >
            Create Tag
          </Button>
        </form>
      </Box>
    </Box>
  );
}
```

### Comprehensive Example

This advanced example shows a complete tag management system with different tag states, icons, and interactive features including adding new tags, toggling disabled states, and random tag removal.

```tsx
import React from 'react';
import {
  Tag,
  Box,
  Text,
  TextInput,
  Button,
  PlusIcon,
  FileTextIcon,
  TagIcon,
  CalendarIcon,
  BellIcon,
} from '@razorpay/blade/components';

function ComprehensiveTagExample() {
  // State for managing tags
  const [tags, setTags] = React.useState<
    Array<{
      id: string;
      text: string;
      icon?: React.ComponentType<any>;
      isDisabled?: boolean;
    }>
  >([
    { id: '1', text: 'Unpaid', icon: FileTextIcon },
    { id: '2', text: 'Pending', icon: TagIcon },
    { id: '3', text: 'Completed', icon: CalendarIcon },
    { id: '4', text: 'Disabled', icon: BellIcon, isDisabled: true },
  ]);

  // State for adding new tags
  const [inputValue, setInputValue] = React.useState('');

  // Add a new tag
  const addTag = (): void => {
    if (inputValue) {
      setTags([
        ...tags,
        {
          id: String(Date.now()),
          text: inputValue,
        },
      ]);
      setInputValue('');
    }
  };

  // Remove a tag
  const removeTag = (tagId: string): void => {
    setTags(tags.filter((tag) => tag.id !== tagId));
  };

  // Toggle tag disabled state
  const toggleTagDisabled = (tagId: string): void => {
    setTags(tags.map((tag) => (tag.id === tagId ? { ...tag, isDisabled: !tag.isDisabled } : tag)));
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.6">
      <Text size="medium" weight="semibold">
        Tag Management Example
      </Text>

      {/* Display all tags */}
      <Box display="flex" flexWrap="wrap" gap="spacing.3" alignItems="center">
        {tags.map((tag) => (
          <Tag
            key={tag.id}
            icon={tag.icon}
            size="medium"
            isDisabled={tag.isDisabled}
            onDismiss={() => removeTag(tag.id)}
          >
            {tag.text}
          </Tag>
        ))}
      </Box>

      {/* Form to add new tags */}
      <Box marginTop="spacing.2">
        <form
          onSubmit={(e) => {
            e.preventDefault();
            addTag();
          }}
        >
          <TextInput
            label="Add New Tag"
            value={inputValue}
            onChange={({ value }) => setInputValue(value ?? '')}
            placeholder="Enter tag name"
          />
          <Button
            icon={PlusIcon}
            iconPosition="right"
            variant="secondary"
            marginTop="spacing.3"
            type="submit"
          >
            Add Tag
          </Button>
        </form>
      </Box>

      {/* Actions for existing tags */}
      {tags.length > 0 && (
        <Box marginTop="spacing.2">
          <Text size="small" marginBottom="spacing.3">
            Actions for selected tag:
          </Text>
          <Box display="flex" gap="spacing.3">
            <Button
              variant="tertiary"
              onClick={() => {
                if (tags.length > 0) {
                  const randomIndex = Math.floor(Math.random() * tags.length);
                  toggleTagDisabled(tags[randomIndex].id);
                }
              }}
            >
              Toggle Random Tag State
            </Button>

            <Button
              variant="tertiary"
              color="negative"
              onClick={() => {
                if (tags.length > 0) {
                  const randomIndex = Math.floor(Math.random() * tags.length);
                  removeTag(tags[randomIndex].id);
                }
              }}
            >
              Remove Random Tag
            </Button>
          </Box>
        </Box>
      )}
    </Box>
  );
}
```

---

## Text

## Component Name

Text

## Description

The Text component is a versatile typography component used to display main content on a page. It is designed to work seamlessly with Title or Heading components to create hierarchical content structures. The component automatically applies responsive styles based on the device it's being rendered on. It supports different variants (body and caption), weights, sizes, and can be customized with various text properties like color, alignment, and truncation.

## Important Constraints

- `variant="caption"` only accepts `size="small"` or `size="medium"`

## TypeScript Types

The following types define the props that the Text component and its variants accept. These types help you understand what properties you can pass to customize the Text component's appearance and behavior.

```typescript
type TextVariant = 'body' | 'caption';

type TextCommonProps = {
  as?: 'p' | 'span' | 'div' | 'abbr' | 'figcaption' | 'cite' | 'q' | 'label';
  truncateAfterLines?: number;
  children: React.ReactNode;
  weight?: 'regular' | 'medium' | 'semibold';
  /**
   * Overrides the color of the Text component.
   *
   * **Note** This takes priority over `type` and `contrast` prop to decide color of text
   */
  color?: string;
  textAlign?: string;
  textDecorationLine?: string;
  wordBreak?: string;
} & TestID &
  StyledPropsBlade;

type TextBodyVariant = TextCommonProps & {
  variant?: 'body';
  size?: 'xsmall' | 'small' | 'medium' | 'large';
};

type TextCaptionVariant = TextCommonProps & {
  variant?: 'caption';
  size?: 'small' | 'medium';
};

type TextProps<T> = T extends { variant: infer Variant }
  ? Variant extends 'caption'
    ? TextCaptionVariant
    : Variant extends 'body'
    ? TextBodyVariant
    : T
  : T;
```

## Example

Here's a comprehensive example showcasing the Text component's various features and props, demonstrating different text variants, sizes, weights, and styling options for creating properly formatted content:

```tsx
import { Text } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';

function TextExample() {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.4">
      {/* Body variant with different sizes and weights */}
      <Text
        variant="body"
        size="large"
        weight="semibold"
        color="surface.text.primary.normal"
        textAlign="center"
      >
        This is a large body text with semibold weight
      </Text>

      {/* Caption variant with truncation */}
      <Text variant="caption" size="medium" truncateAfterLines={2} color="surface.text.gray.normal">
        This is a medium caption text that will be truncated after 2 lines. Lorem ipsum dolor sit
        amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore
        magna aliqua.
      </Text>

      {/* Nested text with different semantic elements */}
      <Text as="p">
        Regular paragraph with
        <Text as="span" weight="semibold" color="surface.text.primary.normal">
          emphasized text
        </Text> and <Text as="cite" variant="body" size="small" textDecorationLine="underline">
          citation
        </Text>
      </Text>

      {/* Accessibility example with label */}
      <Text as="label" variant="body" size="medium" weight="medium" testID="form-label">
        Form Input Label
      </Text>

      {/* Text with word break and custom styling */}
      <Text
        variant="body"
        size="medium"
        wordBreak="break-word"
        textAlign="left"
        color="surface.text.gray.normal"
        margin="spacing.2"
      >
        This text demonstrates word-break and custom styling with margin
      </Text>
    </Box>
  );
}

export default TextExample;
```

---

## TextArea

## Component Name

TextArea

## Description

TextArea is a component for collecting multi-line text input from users. It supports features like validation states, character counting, and tagging functionality. TextArea is ideal for comments, descriptions, bio information, and other long-form text content where users need more space than a single-line input field.

## TypeScript Types

The following types define the props that the TextArea component accepts. These types are essential for proper usage of the component in TypeScript projects.

```typescript
type TextAreaSizes = 'medium' | 'large';

type TextAreaCommonProps = {
  label?: string;
  accessibilityLabel?: string;
  labelPosition?: 'top' | 'left';
  necessityIndicator?: 'optional' | 'required';
  validationState?: 'none' | 'error' | 'success';
  helpText?: string;
  errorText?: string;
  successText?: string;
  placeholder?: string;
  defaultValue?: string;
  name?: string;
  onChange?: ({ name, value }: { name?: string; value?: string }) => void;
  onFocus?: ({ name, value }: { name?: string; value?: string }) => void;
  onBlur?: ({ name, value }: { name?: string; value?: string }) => void;
  onSubmit?: ({ name, value }: { name?: string; value?: string }) => void;
  value?: string;
  isDisabled?: boolean;
  isRequired?: boolean;
  maxCharacters?: number;
  autoFocus?: boolean;
  numberOfLines?: 1 | 2 | 3 | 4 | 5;
  testID?: string;
  size?: TextAreaSizes;
  showClearButton?: boolean;
  onClearButtonClick?: () => void;
  onKeyDown?: ({
    name,
    value,
    event,
  }: {
    name?: string;
    value: string;
    event: React.KeyboardEvent;
  }) => void;
  isTaggedInput?: boolean;
  tags?: string[];
  onTagChange?: ({ tags }: { tags: string[] }) => void;
} & DataAnalyticsAttribute &
  StyledPropsBlade;

type TextAreaPropsWithA11yLabel = {
  label?: undefined;
  accessibilityLabel: string;
} & TextAreaCommonProps;

type TextAreaPropsWithLabel = {
  label: string;
  accessibilityLabel?: string;
} & TextAreaCommonProps;

type TextAreaProps = TextAreaPropsWithA11yLabel | TextAreaPropsWithLabel;
```

## Example

### Basic TextArea with Validation

This example shows a TextArea component with validation, character limit, and help text. It demonstrates how to handle validation states and provide user feedback.

```tsx 
import { useState } from 'react';
import { TextArea, Box } from '@razorpay/blade/components';

function FeedbackForm(): React.ReactElement {
  const [feedback, setFeedback] = useState('');
  const [validationState, setValidationState] = useState<'none' | 'error' | 'success'>('none');

  const handleChange = ({ value }: { value: string }): void => {
    setFeedback(value || '');

    if ((value || '').length < 10) {
      setValidationState('error');
    } else if ((value || '').length > 500) {
      setValidationState('error');
    } else {
      setValidationState('success');
    }
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.4">
      <TextArea
        label="Your Feedback"
        placeholder="Please share your thoughts about our service"
        name="feedback"
        value={feedback}
        onChange={(e) => handleChange({ value: e.value ?? '' })}
        numberOfLines={3}
        maxCharacters={500}
        validationState={validationState}
        helpText="Your feedback helps us improve our services"
        errorText={
          feedback.length < 10
            ? 'Feedback must be at least 10 characters'
            : 'Feedback must be less than 500 characters'
        }
        successText="Thank you for your detailed feedback"
        showClearButton={true}
        size="medium"
        necessityIndicator="required"
        data-analytics-section="feedback-form"
        data-analytics-component="text-area"
        marginBottom="spacing.4"
      />
    </Box>
  );
}

export default FeedbackForm;

```
### TextArea with Various Feature Combinations

This example demonstrates TextArea with different configurations including label position, disabled state, and custom styling.

```tsx
import { TextArea } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';

function ProductDescriptionEditor() {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.5">
      <TextArea
        label="Product Description"
        labelPosition="left"
        placeholder="Enter a detailed description of the product"
        name="description"
        defaultValue="This premium product offers high quality materials and exceptional durability."
        numberOfLines={4}
        maxCharacters={1000}
        showClearButton={true}
        size="large"
        marginBottom="spacing.3"
        data-analytics-field="product-description"
      />

      <TextArea
        label="Short Summary"
        placeholder="Enter a short summary (will appear in search results)"
        name="summary"
        maxCharacters={150}
        necessityIndicator="optional"
        helpText="Keep it concise and highlight key features"
        numberOfLines={2}
        marginBottom="spacing.3"
        data-analytics-field="product-summary"
      />

      <TextArea
        label="Internal Notes"
        placeholder="These notes are only visible to team members"
        name="internalNotes"
        isDisabled={true}
        defaultValue="This product is scheduled for a price adjustment next quarter."
        helpText="Disabled until approval process is complete"
        data-analytics-field="internal-notes"
      />
    </Box>
  );
}
```

### TextArea Without Visible Label

This example shows a TextArea without a visible label but with proper accessibility support using the accessibilityLabel prop.

```tsx
import { TextArea } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';

function SearchQueryBuilder() {
  return (
    <Box
      display="flex"
      flexDirection="column"
      padding="spacing.5"
      backgroundColor="surface.background.gray.subtle"
      borderRadius="medium"
    >
      <TextArea
        accessibilityLabel="Advanced Search Query"
        placeholder="Enter your search query using operators like AND, OR, NOT"
        name="searchQuery"
        numberOfLines={3}
        helpText="Example: payment AND (failed OR declined) NOT refunded"
        showClearButton={true}
        data-analytics-field="advanced-search"
        marginBottom="spacing.0"
      />
    </Box>
  );
}
```

### Tagged TextArea for Multiple Entries

This example demonstrates a TextArea with tagging functionality, allowing users to enter multiple distinct items.

```tsx
import { useState } from 'react';
import { TextArea } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';

function EmailInviter() {
  const [emails, setEmails] = useState(['john.doe@example.com']);

  const handleTagChange = ({ tags }) => {
    setEmails(tags);
  };

  const isValidEmail = (email) => {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
  };

  // Determine if all emails are valid
  const allEmailsValid = emails.every(isValidEmail);

  return (
    <Box width="100%">
      <TextArea
        label="Invite Team Members"
        placeholder="Type an email address and press Enter to add"
        name="teamEmails"
        isTaggedInput={true}
        tags={emails}
        onTagChange={handleTagChange}
        numberOfLines={3}
        helpText="Separate multiple email addresses with Enter"
        validationState={allEmailsValid ? 'success' : 'error'}
        errorText="Please enter valid email addresses"
        successText={`${emails.length} valid email${emails.length !== 1 ? 's' : ''} added`}
        showClearButton={true}
        data-analytics-section="team-invites"
        data-analytics-action="add-email"
        position="relative"
        zIndex={1}
      />
    </Box>
  );
}
```

### TextArea with Custom Key Handling

This example shows how to implement custom keyboard behavior, like submitting on Enter or formatting text.

```tsx
import { useState } from 'react';
import { TextArea } from '@razorpay/blade/components';
import { Box } from '@razorpay/blade/components';
import { Button } from '@razorpay/blade/components';

function MessageComposer() {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState([]);

  const handleChange = ({ value }) => {
    setMessage(value || '');
  };

  const handleKeyDown = ({ event, value }) => {
    // Submit on Shift+Enter, normal Enter creates a new line
    if (event.key === 'Enter' && event.shiftKey) {
      event.preventDefault();
      if (value.trim()) {
        setMessages([...messages, value]);
        setMessage('');
      }
    }
  };

  const handleSubmit = () => {
    if (message.trim()) {
      setMessages([...messages, message]);
      setMessage('');
    }
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.4">
      <Box
        display="flex"
        flexDirection="column"
        gap="spacing.2"
        padding="spacing.3"
        backgroundColor="surface.background.gray.subtle"
        borderRadius="medium"
        maxHeight="200px"
        overflow="auto"
      >
        {messages.map((msg, index) => (
          <Box
            key={index}
            padding="spacing.3"
            backgroundColor="surface.background.gray.intense"
            borderRadius="medium"
          >
            {msg}
          </Box>
        ))}
      </Box>

      <Box display="flex" gap="spacing.3" alignItems="flex-end">
        <Box flexGrow={1}>
          <TextArea
            label="Message"
            placeholder="Type your message (Shift+Enter to send)"
            name="message"
            value={message}
            onChange={handleChange}
            onKeyDown={handleKeyDown}
            numberOfLines={2}
            showClearButton={true}
            data-analytics-action="compose-message"
          />
        </Box>
        <Button onClick={handleSubmit}>Send</Button>
      </Box>
    </Box>
  );
}
```

---

## TextInput

## Component Name

TextInput

## Description

TextInput is a component for collecting user input in a text field. It supports various input types (text, email, number, url, etc.), validation states, and visual elements like icons, prefix/suffix text, and character counters. It can be used for names, email addresses, search queries, and other text-based inputs with optional validation and visual feedback.

## TypeScript Types

The following types define the props that the TextInput component accepts. These types are essential for proper usage of the component in TypeScript projects.

```typescript
type TextInputSizes = 'medium' | 'large';

type Type = 'text' | 'telephone' | 'email' | 'url' | 'number' | 'search';

type TextInputCommonProps = {
  label?: string;
  accessibilityLabel?: string;
  labelPosition?: 'top' | 'left';
  necessityIndicator?: 'optional' | 'required';
  validationState?: 'none' | 'error' | 'success';
  helpText?: string;
  errorText?: string;
  successText?: string;
  placeholder?: string;
  defaultValue?: string;
  name?: string;
  onChange?: ({
    name,
    value,
    rawValue,
  }: {
    name?: string;
    value?: string;
    rawValue?: string;
  }) => void;
  onFocus?: ({ name, value }: { name?: string; value?: string }) => void;
  onBlur?: ({ name, value }: { name?: string; value?: string }) => void;
  value?: string;
  isDisabled?: boolean;
  isRequired?: boolean;
  prefix?: string;
  suffix?: string;
  maxCharacters?: number;
  autoFocus?: boolean;
  keyboardReturnKeyType?: 'default' | 'go' | 'done' | 'next' | 'search' | 'send';
  autoCompleteSuggestionType?:
    | 'none'
    | 'name'
    | 'email'
    | 'username'
    | 'password'
    | 'newPassword'
    | 'oneTimeCode'
    | 'telephone'
    | 'postalCode'
    | 'countryName'
    | 'creditCardNumber'
    | 'creditCardCSC'
    | 'creditCardExpiry'
    | 'creditCardExpiryMonth'
    | 'creditCardExpiryYear'
    | 'on';
  onSubmit?: ({ name, value }: { name?: string; value?: string }) => void;
  onClick?: ({ name, value }: { name?: string; value?: string }) => void;
  size?: TextInputSizes;
  leadingIcon?: React.ComponentType<any>;
  /**
   * Leading React component (e.g., Icon, Badge, Dropdown, or custom component)
   * When provided, component will be shown at the beginning of the input
   * Commonly used for currency symbols, country codes, or dropdown selectors
   *
   * @example <BankIcon /> for financial inputs
   * @example <Badge>+91</Badge> for country codes
   * @example <Dropdown>...</Dropdown> for prefix selectors
   */
  leading?: React.ReactElement | React.ComponentType<any>;
  trailingButton?: React.ReactElement;
  trailingIcon?: React.ComponentType<any>;
  /**
   * Trailing React component (e.g., Icon, Badge, Dropdown, or custom component)
   * When provided, component will be shown at the end of the input
   * Commonly used for payment card icons, status indicators, or dropdown selectors
   *
   * @example <VisaIcon /> for payment card detection
   * @example <CheckIcon /> for validation status
   * @example <Dropdown>...</Dropdown> for suffix selectors
   */
  trailing?: React.ReactElement | React.ComponentType<any>;
  textAlign?: 'left' | 'center' | 'right';
  autoCapitalize?: 'none' | 'sentences' | 'words' | 'characters';
  showClearButton?: boolean;
  onClearButtonClick?: () => void;
  isLoading?: boolean;
  icon?: React.ComponentType<any>;
  type?: Type;
  isTaggedInput?: boolean;
  tags?: string[];
  onTagChange?: ({ tags }: { tags: string[] }) => void;
  testID?: string;
  /**
   * Format pattern where # represents input characters and other symbols act as delimiters
   * When provided, input will be automatically formatted and onChange will include rawValue
   *
   * **Note:**
   * 1. Format pattern should only contain # symbols and special characters as delimiters.
   *    Alphanumeric characters (letters and numbers) are not allowed in the format pattern.
   * 2. When format is provided, user input is restricted to alphanumeric characters only.
   *    Special characters and symbols will be filtered out automatically from user input.
   *
   * @example "#### #### #### ####" for card numbers
   * @example "##/##" for expiry dates
   * @example "(###) ###-####" for phone numbers
   */
  format?:
    | '#### #### #### ####'
    | '##/##'
    | '##/##/####'
    | '(###) ###-####'
    | '###-##-####'
    | '##:##'
    | '##:##:##'
    | '#### #### ####'
    | '###.###.###.###'
    | '## ## ####'
    | '##-###-##'
    | (string & {});
} & DataAnalyticsAttribute &
  StyledPropsBlade;

type TextInputPropsWithA11yLabel = {
  label?: undefined;
  accessibilityLabel: string;
} & TextInputCommonProps;

type TextInputPropsWithLabel = {
  label: string;
  accessibilityLabel?: string;
} & TextInputCommonProps;

type TextInputProps = TextInputPropsWithA11yLabel | TextInputPropsWithLabel;
```

## Example

### Basic Usage with Validation States

This example demonstrates basic TextInput usage with different validation states.

```tsx
import { TextInput, Box } from '@razorpay/blade/components';

function TextInputExample() {
  const handleChange = ({ name, value }) => {
    console.log(`Input ${name} changed to ${value}`);
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.4">
      <TextInput
        label="Full Name"
        placeholder="Enter your full name"
        name="fullName"
        onChange={handleChange}
        necessityIndicator="required"
        data-analytics-field="full-name"
        marginBottom="spacing.2"
      />

      <TextInput
        label="Email Address"
        placeholder="Enter your email"
        name="email"
        type="email"
        validationState="error"
        errorText="Please enter a valid email address"
        data-analytics-field="email"
        marginBottom="spacing.2"
      />

      <TextInput
        label="Username"
        placeholder="Choose a username"
        name="username"
        validationState="success"
        successText="Username is available"
        data-analytics-field="username"
        marginBottom="spacing.2"
      />

      <TextInput
        label="Phone Number"
        placeholder="Enter your phone number"
        name="phone"
        type="telephone"
        isDisabled={true}
        defaultValue="+919876543210"
        data-analytics-field="phone"
      />
    </Box>
  );
}
```

### Feature-Rich TextInput Examples

This example showcases TextInput with combined visual and functional features.

```tsx
import {
  TextInput,
  Box,
  Link,
  SearchIcon,
  CreditCardIcon,
  InfoIcon,
} from '@razorpay/blade/components';

function FeatureRichTextInputExample() {
  return (
    <Box display="flex" flexDirection="column" gap="spacing.5">
      <TextInput
        label="Search Products"
        placeholder="Search the catalog"
        name="search"
        type="search"
        leadingIcon={SearchIcon}
        showClearButton={true}
        maxCharacters={50}
        helpText="Search by product name or SKU"
        size="medium"
        data-analytics-action="search"
        marginBottom="spacing.3"
      />

      <TextInput
        label="Transaction Amount"
        placeholder="0.00"
        name="amount"
        type="number"
        prefix="â‚¹"
        suffix=".00"
        textAlign="right"
        labelPosition="left"
        leadingIcon={CreditCardIcon}
        necessityIndicator="required"
        data-analytics-field="transaction-amount"
        marginBottom="spacing.3"
      />

      <TextInput
        label="Discount Code"
        placeholder="Enter code"
        name="discountCode"
        trailingButton={<Link>Apply</Link>}
        necessityIndicator="optional"
        isLoading={false}
        maxCharacters={10}
        data-analytics-field="discount-code"
        position="relative"
      />
    </Box>
  );
}
```

### TextInput Without Visible Labels

This example demonstrates how to create TextInput components without visible labels but with proper accessibility support using the accessibilityLabel prop, useful for compact UI designs.

```tsx
import { TextInput, Box, SearchIcon, UserIcon } from '@razorpay/blade/components';

function AccessibleTextInputExample() {
  return (
    <Box display="flex" gap="spacing.4">
      <TextInput
        accessibilityLabel="Search"
        placeholder="Search"
        name="search"
        leadingIcon={SearchIcon}
        showClearButton={true}
        type="search"
        data-analytics-action="search"
        marginRight="spacing.2"
      />

      <TextInput
        accessibilityLabel="First Name"
        placeholder="First Name"
        name="firstName"
        leadingIcon={UserIcon}
        data-analytics-field="first-name"
      />
    </Box>
  );
}
```

### Tagged Input for Multiple Values

This example demonstrates using TextInput to collect multiple values as tags.

```tsx
import { useState } from 'react';
import { TextInput, Box, MailIcon } from '@razorpay/blade/components';

function TaggedTextInputExample() {
  const [emails, setEmails] = useState(['user@example.com']);

  const handleTagChange = ({ tags }) => {
    setEmails(tags);
  };

  const isValidEmail = (email) => {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
  };

  return (
    <Box width="100%">
      <TextInput
        label="Recipients"
        placeholder="Type email and press Enter"
        name="recipients"
        isTaggedInput={true}
        tags={emails}
        onTagChange={handleTagChange}
        helpText="Add multiple email addresses by pressing Enter after each one"
        validationState={emails.every(isValidEmail) ? 'success' : 'error'}
        errorText="Please enter valid email addresses"
        autoCompleteSuggestionType="email"
        leadingIcon={MailIcon}
        showClearButton={true}
        data-analytics-section="email-recipients"
        data-analytics-action="add-email"
        position="relative"
        zIndex={1}
      />
    </Box>
  );
}
```

### TextInput with Leading/Trailing Elements and Formatting

This example demonstrates TextInput with leading/trailing elements, formatting patterns, and dynamic trailing icons.

```tsx
import { useState } from 'react';
import {
  TextInput,
  Box,
  Text,
  Badge,
  CreditCardIcon,
  CheckIcon,
  ClockIcon,
  BankIcon,
  Dropdown,
  DropdownOverlay,
  InputDropdownButton,
  ActionList,
  ActionListItem,
} from '@razorpay/blade/components';

function AdvancedTextInputExample() {
  const [cardNumber, setCardNumber] = useState('');
  const [rawCardNumber, setRawCardNumber] = useState('');
  const [cardIcon, setCardIcon] = useState(null);
  const [phoneNumber, setPhoneNumber] = useState('');
  const [rawPhoneNumber, setRawPhoneNumber] = useState('');
  const [currencyAmount, setCurrencyAmount] = useState('');
  const [upiId, setUpiId] = useState('');

  const detectCardType = (number) => {
    const patterns = {
      visa: /^4/,
      mastercard: /^5[1-5]/,
      amex: /^3[47]/,
    };

    for (const [type, pattern] of Object.entries(patterns)) {
      if (pattern.test(number)) return type;
    }
    return 'unknown';
  };

  const getCardIcon = (cardType) => {
    const icons = {
      visa: 'https://cdn.razorpay.com/card-networks/visa.svg',
      mastercard: 'https://cdn.razorpay.com/card-networks/mastercard.svg',
      amex: 'https://cdn.razorpay.com/card-networks/amex.svg',
      unknown: CreditCardIcon,
    };
    return icons[cardType] || CreditCardIcon;
  };

  const handleCardNumberChange = ({ value, rawValue }) => {
    if (rawValue && rawValue.length >= 1) {
      const cardType = detectCardType(rawValue);
      setCardIcon(getCardIcon(cardType));
    } else {
      setCardIcon(null);
    }

    setCardNumber(value || '');
    setRawCardNumber(rawValue || '');
  };

  const handlePhoneChange = ({ value, rawValue }) => {
    setPhoneNumber(value || '');
    setRawPhoneNumber(rawValue || '');
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.5">
      {/* Card Number with Dynamic Trailing Icon */}
      <Box>
        <TextInput
          label="Card Number"
          placeholder="Enter card number"
          name="cardNumber"
          value={cardNumber}
          format="#### #### #### ####"
          trailing={cardIcon}
          onChange={handleCardNumberChange}
          helpText="Try: 4111111111111111 (Visa), 5555555555554444 (Mastercard)"
          type="number"
          autoCompleteSuggestionType="creditCardNumber"
          data-analytics-field="card-number"
        />

        <Box
          backgroundColor="surface.background.gray.moderate"
          padding="spacing.3"
          borderRadius="medium"
          marginTop="spacing.2"
        >
          <Text size="small" color="surface.text.gray.muted">
            Formatted: {cardNumber} | Raw: {rawCardNumber}
          </Text>
        </Box>
      </Box>

      {/* Phone Number with Leading Badge and Formatting */}
      <TextInput
        label="Phone Number"
        placeholder="Enter phone number"
        name="phoneNumber"
        value={phoneNumber}
        leading={<Badge>+91</Badge>}
        format="(###) ###-####"
        trailing={rawPhoneNumber.length === 10 ? CheckIcon : undefined}
        onChange={handlePhoneChange}
        validationState={rawPhoneNumber.length === 10 ? 'success' : 'none'}
        successText={rawPhoneNumber.length === 10 ? 'Valid phone number' : undefined}
        helpText="Enter 10-digit phone number"
        type="telephone"
        autoCompleteSuggestionType="telephone"
        data-analytics-field="phone-number"
      />

      {/* Currency Input with Leading Dropdown */}
      <TextInput
        label="Amount"
        placeholder="Enter amount"
        name="currencyAmount"
        value={currencyAmount}
        onChange={({ value }) => setCurrencyAmount(value || '')}
        leading={
          <Dropdown>
            <InputDropdownButton defaultValue="inr" icon={BankIcon} />
            <DropdownOverlay>
              <ActionList>
                <ActionListItem title="INR" value="inr" />
                <ActionListItem title="USD" value="usd" />
                <ActionListItem title="EUR" value="eur" />
              </ActionList>
            </DropdownOverlay>
          </Dropdown>
        }
        type="number"
        helpText="Select currency and enter amount"
        data-analytics-field="currency-amount"
      />

      {/* UPI ID with Trailing Badge */}
      <TextInput
        label="UPI ID"
        placeholder="Enter UPI handle"
        name="upiHandle"
        value={upiId}
        onChange={({ value }) => setUpiId(value || '')}
        trailing={<Badge>@oksbi</Badge>}
        helpText="Enter your UPI handle"
        data-analytics-field="upi-handle"
      />

      {/* Expiry Date with Static Trailing Icon */}
      <TextInput
        label="Expiry Date"
        placeholder="MM/YY"
        name="expiryDate"
        format="##/##"
        trailing={ClockIcon}
        helpText="Enter expiry date in MM/YY format"
        type="number"
        autoCompleteSuggestionType="creditCardExpiry"
        data-analytics-field="expiry-date"
      />
    </Box>
  );
}
```

---

## TimePicker

# TimePicker

## Description

The TimePicker component is a comprehensive time selection input that supports both 12-hour and 24-hour formats with configurable minute step intervals. It features an accessible segmented input field where users can directly type or use dropdown/bottom sheet selection with scrollable spin wheels. The component provides responsive layouts with desktop dropdown and mobile bottom sheet, includes validation states, and supports both controlled and uncontrolled usage patterns.

## Important Constraints

- `timeFormat` only accepts `'12h'` or `'24h'` values
- `minuteStep` only accepts `1`, `5`, `15`, or `30` as valid values
- `size` only accepts `'medium'` or `'large'` values
- `labelPosition` only accepts `'top'` or `'left'` values
- When using controlled mode, both `value` and `onChange` props must be provided
- `onApply` callback is only triggered when `showFooterActions` is `true` and user clicks Apply button
- Component requires a valid Date object or null for `value` and `defaultValue` props
- `validationState` only accepts `'error'`, `'success'`, or `'none'` values

## TypeScript Types

These types define the props that the TimePicker component and its related components accept. Use these for proper TypeScript integration and to understand available configuration options.

```typescript
/**
 * Time format types supported by TimePicker
 * Both 12h and 24h formats are supported using React Aria.
 */
type TimeFormat = '12h' | '24h';

/**
 * Minute step intervals supported by TimePicker
 */
type MinuteStep = 1 | 5 | 15 | 30;

/**
 * Value object returned by TimePicker onChange and onApply callbacks
 * Designed for future extensibility while maintaining backwards compatibility
 */
type TimePickerValue = {
  /**
   * The selected time as a Date object
   */
  value: Date | null;
};

/**
 * Individual time component identifiers
 */
type TimePart = 'hour' | 'minute' | 'period';

type TimePickerCommonInputProps = {
  inputRef?: React.Ref<any>;
  referenceProps?: any;
} & Pick<
  BaseInputProps,
  | 'labelPosition'
  | 'size'
  | 'isRequired'
  | 'necessityIndicator'
  | 'autoFocus'
  | 'isDisabled'
  | 'accessibilityLabel'
  | 'name'
  | 'placeholder'
  | 'label'
  | 'onFocus'
  | 'onBlur'
  | 'labelSuffix'
  | 'labelTrailing'
> &
  FormInputValidationProps;

/**
 * Main TimePicker component props
 * Combines input functionality with time selection capabilities
 */
type TimePickerProps = Omit<
  TimePickerInputProps,
  'inputRef' | 'refrenceProps' | 'successText' | 'errorText' | 'helpText' | 'time' | 'onChange'
> &
  Omit<TimePickerSelectorProps, 'isOpen' | 'defaultIsOpen' | 'onOpenChange' | 'time'> & {
    /**
     * Current time value as Date object (for controlled usage)
     */
    value?: Date | null;

    /**
     * Callback fired when time value changes
     * @param timeValue - Object containing the selected time
     */
    onChange?: (timeValue: TimePickerValue) => void;

    /**
     * Label for the time input
     */
    label?: string;

    /**
     * Help text to guide the user
     */
    helpText?: string;

    /**
     * Error text to show validation errors
     */
    errorText?: string;

    /**
     * Success text to show validation success
     */
    successText?: string;

    /**
     * Controls dropdown open state (for controlled usage)
     * @default false
     */
    isOpen?: boolean;

    /**
     * Default open state (for uncontrolled usage)
     * @default false
     */
    defaultIsOpen?: boolean;

    /**
     * Callback fired when dropdown open state changes
     * @param state - Object containing the new open state
     */
    onOpenChange?: (state: { isOpen: boolean }) => void;

    /**
     * Test ID for testing purposes
     */
    testID?: string;

    /**
     * Accessibility label for screen readers
     * When not provided, falls back to label prop
     */
    accessibilityLabel?: string;
  };

type TimePickerSelectorProps = {
  /**
   * Current time value as Date object (for controlled usage)
   */
  time?: Date | null;

  /**
   * Default time value as Date object (for uncontrolled usage)
   */
  defaultValue?: Date;

  /**
   * Callback fired when time value changes during selection
   * @param timeValue - Object containing the selected time and future extensible properties
   */
  onChange?: (timeValue: TimePickerValue) => void;

  /**
   * Time format for display and interaction
   * @default "12h"
   *
   * Both 12h and 24h formats are supported using React Aria.
   */
  timeFormat?: TimeFormat;

  /**
   * Controls dropdown open state (for controlled usage)
   * @default false
   */
  isOpen?: boolean;

  /**
   * Default open state (for uncontrolled usage)
   * @default false
   */
  defaultIsOpen?: boolean;

  /**
   * Step interval for minutes selection
   * @default 1
   * @example 15 // allows 00, 15, 30, 45 minutes only
   */
  minuteStep?: MinuteStep;

  /**
   * Callback fired when dropdown open state changes
   * @param state - Object containing the new open state
   */
  onOpenChange?: (state: { isOpen: boolean }) => void;

  /**
   * Whether to show the apply/cancel buttons in the dropdown
   * @default true
   *
   * When true:
   * - Shows Apply/Cancel buttons for explicit confirmation
   * - User must click Apply to confirm selection
   * - Better for complex time selections
   *
   * When false:
   * - On blur, selected time will automatically apply and close the dropdown
   * - Pressing Enter immediately applies the current selection and closes
   * - More streamlined interaction experience
   */
  showFooterActions?: boolean;

  /**
   * Callback fired when user applies time selection
   * Only called when showFooterActions is true and user clicks Apply
   * @param timeValue - Object containing the confirmed time value
   */
  onApply?: (timeValue: TimePickerValue) => void;

  /**
   * To set the controlled value of the time picker
   */
  setControlledValue?: (time: Date | null) => void;

  size?: 'medium' | 'large';
};

/**
 * Props for individual time column components (Hours, Minutes, Period)
 */
type TimeColumnProps = {
  values: string[];
  selectedValue: string;
  onValueChange: (value: string) => void;
};

/**
 * Props for time picker footer actions (Apply/Cancel buttons)
 */
type TimePickerFooterProps = {
  onApply: () => void;
  onCancel: () => void;
  isApplyDisabled?: boolean;
};

type TimeSegmentProps = {
  segment: DateSegment;
  state: TimeFieldState;
  isDisabled?: boolean;
};
```

## Example

### TimePicker Usage

```tsx
import React, { useState } from 'react';
import {
  TimePicker,
  Box,
  Button,
  Link,
  Tooltip,
  TooltipInteractiveWrapper,
  InfoIcon,
} from '@razorpay/blade/components';

function TimePickerExample() {
  const [basicTime, setBasicTime] = useState<Date | null>(null);
  const [advancedTime, setAdvancedTime] = useState<Date | null>(null);
  const [isOpen, setIsOpen] = useState(false);
  const [hasError, setHasError] = useState(false);

  // Validation for business hours (9 AM - 6 PM)
  const validateTime = (time: Date | null) => {
    if (!time) return;
    const hour = time.getHours();
    setHasError(hour < 9 || hour >= 18);
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.5">
      {/* Basic TimePicker - shows common usage */}
      <TimePicker
        label="Meeting Time"
        timeFormat="12h"
        size="medium"
        value={basicTime}
        onChange={({ value }) => setBasicTime(value)}
        showFooterActions={false}
        minuteStep={15}
        helpText="Select your meeting time (15-minute intervals)"
        placeholder="Select time"
        accessibilityLabel="Select meeting time"
      />

      {/* Advanced TimePicker - shows all advanced features */}
      <TimePicker
        label="Business Hours Appointment"
        labelPosition="top"
        labelSuffix={
          <Tooltip content="Must be during business hours (9 AM - 6 PM)" placement="right">
            <TooltipInteractiveWrapper display="flex">
              <InfoIcon size="small" color="surface.icon.gray.muted" />
            </TooltipInteractiveWrapper>
          </Tooltip>
        }
        labelTrailing={<Link size="small">Time zones</Link>}
        timeFormat="24h"
        size="large"
        value={advancedTime}
        defaultValue={new Date('2024-01-01T14:30:00')}
        onChange={({ value }) => {
          setAdvancedTime(value);
          validateTime(value);
        }}
        onApply={({ value }) => console.log('Applied:', value)}
        isOpen={isOpen}
        onOpenChange={({ isOpen }) => setIsOpen(isOpen)}
        isRequired
        necessityIndicator="required"
        validationState={hasError ? 'error' : advancedTime ? 'success' : 'none'}
        errorText={hasError ? 'Please select time during business hours (9 AM - 6 PM)' : undefined}
        successText={!hasError && advancedTime ? 'Valid appointment time' : undefined}
        showFooterActions={true}
        minuteStep={30}
        isDisabled={false}
        autoFocus={false}
        name="appointment-time"
        testID="advanced-timepicker"
        accessibilityLabel="Select appointment time during business hours"
      />

      {/* Control buttons to demonstrate programmatic usage */}
      <Box display="flex" gap="spacing.3">
        <Button size="small" onClick={() => setAdvancedTime(new Date())}>
          Set Current Time
        </Button>
        <Button size="small" variant="secondary" onClick={() => setIsOpen(!isOpen)}>
          Toggle Dropdown
        </Button>
      </Box>
    </Box>
  );
}
```

---

## Toast

## Component Name

Toast

## Description

The Toast component displays temporary feedback messages in the interface. It can be used to provide notifications about completed actions, system events, or important information. Toasts appear in a small overlay and can be configured to automatically dismiss after a certain duration or require manual dismissal by the user.

## TypeScript Types

These types represent the props that the Toast component and its associated hooks accept.

```typescript
// Main Toast component props
type ToastProps = {
  /**
   * @default `informational`
   */
  type?: 'informational' | 'promotional';

  /**
   * Content of the toast
   */
  content: React.ReactNode;

  /**
   * @default `neutral`
   */
  color?: FeedbackColors; // 'neutral' | 'positive' | 'negative' | 'notice' | 'information'

  /**
   * Can be used to render an icon
   */
  leading?: React.ComponentType<any>;

  /**
   * If true, the toast will be dismissed after few seconds
   *
   * Duration for promotional toast is 8s
   * Duration for informational toast is 4s
   *
   * @default false
   */
  autoDismiss?: boolean;

  /**
   * Duration in milliseconds for which the toast will be visible
   *
   * @default 4000 for informational toast
   * @default 8000 for promotional toast
   */
  duration?: number;

  /**
   * Called when the toast is dismissed or duration runs out
   */
  onDismissButtonClick?: ({
    event,
    toastId,
  }: {
    event: React.MouseEvent<HTMLButtonElement>;
    toastId: string;
  }) => void;

  /**
   * Primary action of toast
   */
  action?: {
    text: string;
    onClick?: ({ event, toastId }: { event: ButtonProps['onClick']; toastId: string }) => void;
    isLoading?: boolean;
  };

  /**
   * Forwarded to react-hot-toast
   *
   * This can be used to programatically update toasts by providing an id
   */
  id?: string;
};

// Return type of useToast hook
type UseToastReturn = {
  toasts: BladeToast[]; // Currently active toasts
  show: (props: ToastProps) => string; // Show a toast and return its ID
  dismiss: (id?: string) => void; // Dismiss a specific toast or all toasts
};
```

## Example

### Basic Usage

This example demonstrates the simplest implementation of a Toast notification with success message using the useToast hook.

```tsx
import { ToastContainer, useToast, Box, Button } from '@razorpay/blade/components';

function BasicToastExample() {
  const toast = useToast();

  return (
    <Box>
      {/* Place ToastContainer at the root of your app */}
      <ToastContainer />

      <Button
        onClick={() => {
          toast.show({
            content: 'Payment successful',
            color: 'positive',
          });
        }}
      >
        Show Success Toast
      </Button>
    </Box>
  );
}
```

### Toast with Different Colors

This example shows how to create toasts with different color schemes to convey various types of messages like success, error, warning, and information.

```tsx
import { ToastContainer, useToast, Box, Button } from '@razorpay/blade/components';

function ColoredToastExample() {
  const toast = useToast();

  return (
    <Box display="flex" gap="spacing.4">
      <Button
        variant="tertiary"
        onClick={() => {
          toast.show({
            content: 'Payment successful',
            color: 'positive',
          });
        }}
      >
        Positive Toast
      </Button>

      <Button
        variant="tertiary"
        onClick={() => {
          toast.show({
            content: 'Unable to fetch merchant details',
            color: 'negative',
          });
        }}
      >
        Negative Toast
      </Button>

      <Button
        variant="tertiary"
        onClick={() => {
          toast.show({
            content: 'Your KYC is pending',
            color: 'notice',
          });
        }}
      >
        Notice Toast
      </Button>

      <Button
        variant="tertiary"
        onClick={() => {
          toast.show({
            content: 'Your transaction will be settled in 3 business days',
            color: 'information',
          });
        }}
      >
        Information Toast
      </Button>

      <Button
        variant="tertiary"
        onClick={() => {
          toast.show({
            content: 'Transaction has been initiated',
            color: 'neutral',
          });
        }}
      >
        Neutral Toast
      </Button>
    </Box>
  );
}
```

### Toast with Action Button

This example demonstrates how to add an interactive action button to a toast, along with custom dismissal behavior and event logging.

```tsx
import { ToastContainer, useToast, Box, Button } from '@razorpay/blade/components';

function ActionToastExample() {
  const toast = useToast();

  const showToastWithAction = () => {
    const toastId = toast.show({
      content: 'Payment successful',
      color: 'positive',
      autoDismiss: false,
      action: {
        text: 'View Details',
        onClick: ({ toastId }) => {
          console.log('View details clicked');
          toast.dismiss(toastId);
        },
      },
      onDismissButtonClick: ({ toastId }) => {
        console.log(`Toast ${toastId} dismissed`);
      },
    });

    console.log(`Toast ID: ${toastId}`);
  };

  return (
    <Box>
      <Button onClick={showToastWithAction}>Show Toast with Action</Button>
    </Box>
  );
}
```

### Promotional Toast

This example shows how to create a rich promotional toast with custom content, images, and multiple text elements for marketing announcements.

```tsx
import { ToastContainer, useToast, Box, Button, Heading, Text } from '@razorpay/blade/components';

function PromotionalToastExample() {
  const toast = useToast();

  const showPromotionalToast = () => {
    toast.show({
      type: 'promotional',
      content: (
        <Box display="flex" gap="spacing.3" flexDirection="column">
          <Heading>Introducing TurboUPI</Heading>
          <img
            loading="lazy"
            width="100%"
            height="100px"
            alt="Promotional Toast"
            src="https://example.com/promotional-image.png"
          />
          <Text weight="semibold">Lightning-fast payments with the new Razorpay Turbo UPI</Text>
          <Text size="xsmall">
            Turbo UPI allows end-users to complete their payment in-app, with no redirections or
            dependence on third-party UPI apps. With Turbo UPI, payments will be 5x faster with a
            significantly-improved success rate of 10%!
          </Text>
        </Box>
      ),
      action: {
        text: 'Try TurboUPI',
        onClick: ({ toastId }) => {
          console.log('Try TurboUPI clicked');
          toast.dismiss(toastId);
        },
      },
      onDismissButtonClick: ({ toastId }) => {
        console.log(`Promotional toast ${toastId} dismissed`);
      },
    });
  };

  return (
    <Box>
      <Button onClick={showPromotionalToast}>Show Promotional Toast</Button>
    </Box>
  );
}
```

### Comprehensive Example

This advanced example demonstrates multiple toast types, dynamic updating of toast content, handling loading states, and programmatic toast management.

```tsx
import {
  ToastContainer,
  useToast,
  Box,
  Button,
  Heading,
  Text,
  CheckCircleIcon,
} from '@razorpay/blade/components';

function ComprehensiveToastExample() {
  const toast = useToast();

  // Show a basic informational toast with auto-dismiss
  const showBasicToast = () => {
    toast.show({
      content: 'Your changes have been saved',
      color: 'positive',
      autoDismiss: true,
      duration: 4000, // 4 seconds
    });
  };

  // Show a toast with custom icon and action button
  const showCustomIconToast = () => {
    toast.show({
      content: 'Payment of â‚¹1,000 received',
      color: 'positive',
      leading: CheckCircleIcon,
      autoDismiss: false,
      action: {
        text: 'View Receipt',
        onClick: ({ toastId }) => {
          console.log('View receipt clicked');
          toast.dismiss(toastId);
        },
        isLoading: false, // Can be set to true when performing async action
      },
      onDismissButtonClick: ({ toastId }) => {
        console.log(`Toast ${toastId} dismissed`);
      },
    });
  };

  // Show a negative toast for errors
  const showErrorToast = () => {
    toast.show({
      content: 'Failed to process transaction',
      color: 'negative',
      autoDismiss: false,
      action: {
        text: 'Retry',
        onClick: ({ toastId }) => {
          // Update the same toast to show loading state
          toast.show({
            id: toastId,
            content: 'Retrying transaction...',
            color: 'notice',
            action: {
              text: 'Retry',
              isLoading: true,
            },
          });

          // Simulate API call
          setTimeout(() => {
            toast.show({
              id: toastId,
              content: 'Transaction processed successfully',
              color: 'positive',
              autoDismiss: true,
            });
          }, 2000);
        },
      },
    });
  };

  // Show a promotional toast with rich content
  const showPromotionalToast = () => {
    toast.show({
      type: 'promotional',
      content: (
        <Box display="flex" gap="spacing.3" flexDirection="column">
          <Heading>New Feature Available</Heading>
          <Text weight="semibold">Try our new instant settlement feature</Text>
          <Text size="xsmall">
            Get your funds instantly with our new settlement option. Available for all business
            accounts.
          </Text>
        </Box>
      ),
      action: {
        text: 'Enable Now',
        onClick: ({ toastId }) => {
          console.log('Enable now clicked');
          toast.dismiss(toastId);
        },
      },
    });
  };

  // Dismiss all toasts
  const dismissAllToasts = () => {
    toast.dismiss();
  };

  return (
    <Box display="flex" flexDirection="column" gap="spacing.4">
      <ToastContainer />

      <Box display="flex" gap="spacing.4">
        <Button onClick={showBasicToast}>Basic Toast</Button>

        <Button onClick={showCustomIconToast}>Custom Icon Toast</Button>

        <Button onClick={showErrorToast}>Error Toast</Button>

        <Button onClick={showPromotionalToast}>Promotional Toast</Button>

        <Button variant="tertiary" onClick={dismissAllToasts}>
          Dismiss All Toasts
        </Button>
      </Box>
    </Box>
  );
}
```

---

## Tooltip

## Component Name

Tooltip

## Description

The Tooltip component provides additional context about elements or their functions. It's triggered by mouse hover on desktop and on tap on mobile devices. Tooltips appear in a small overlay that floats near its target element, offering supplementary information without disrupting the main workflow.

## TypeScript Types

These types represent the props that the Tooltip component and its subcomponents accept.

```typescript
// Main Tooltip component props
type TooltipProps = {
  /**
   * Tooltip title
   */
  title?: string;
  /**
   * Tooltip content
   */
  content: string;
  /**
   * Placement of tooltip
   *
   * @default "top"
   */
  placement?: Exclude<
    UseFloatingOptions['placement'],
    'left-end' | 'left-start' | 'right-end' | 'right-start'
  >;
  children: React.ReactElement;
  onOpenChange?: ({ isOpen }: { isOpen: boolean }) => void;
  /**
   * Sets the z-index of the modal
   * @default 1100
   */
  zIndex?: number;
} & DataAnalyticsAttribute;

// Props for TooltipInteractiveWrapper - used for non-interactive triggers like icons
// Accepts all BaseBox props except 'as'
type TooltipInteractiveWrapperProps = Omit<BaseBoxProps, 'as'>;
```

## Example

### Basic Usage

This example shows the simplest implementation of a Tooltip component providing additional information for a button element.

```tsx
import { Tooltip, Button } from '@razorpay/blade/components';

function BasicTooltipExample() {
  return (
    <Tooltip content="Additional information about this action" placement="bottom">
      <Button>Hover over me</Button>
    </Tooltip>
  );
}
```

### Tooltip with Title

This example demonstrates a Tooltip with both a title and content, including a callback function that triggers when the tooltip opens or closes.

```tsx
import { Tooltip, Button } from '@razorpay/blade/components';

function TooltipWithTitleExample() {
  return (
    <Tooltip
      title="Important Information"
      content="This action will submit your form data"
      placement="top"
      onOpenChange={({ isOpen }) => console.log(`Tooltip is ${isOpen ? 'open' : 'closed'}`)}
    >
      <Button>Submit Form</Button>
    </Tooltip>
  );
}
```

### Using with Non-Interactive Elements

This example shows how to properly implement tooltips on non-interactive elements like icons by using the TooltipInteractiveWrapper to ensure accessibility.

```tsx
import {
  Tooltip,
  TooltipInteractiveWrapper,
  InfoIcon,
  Box,
  Text,
} from '@razorpay/blade/components';

function NonInteractiveTooltipExample() {
  return (
    <Box display="flex" alignItems="center" gap="spacing.2">
      <Text>Transaction Details</Text>
      <Tooltip content="View detailed information about this transaction" placement="bottom-start">
        <TooltipInteractiveWrapper>
          <InfoIcon size="medium" />
        </TooltipInteractiveWrapper>
      </Tooltip>
    </Box>
  );
}
```

---

## TopNav

## Component Name

TopNav

## Description

The TopNav component is a navigation bar positioned at the top of the screen that provides quick access to different products, search functionality, and user profile. TopNav always uses TabNav for multi-product navigation. TopNav has a responsive design that adapts well to different viewport sizes and integrates seamlessly with side navigation systems.

## TypeScript Types

Below are the props that the TopNav component and its subcomponents accept. These types allow you to properly configure each component to build a complete navigation system.

````typescript
// Main TopNav Component Types
type TopNavProps = {
  children: React.ReactNode;
} & Pick<
  BoxProps,
  | 'padding'
  | 'paddingTop'
  | 'paddingBottom'
  | 'paddingLeft'
  | 'paddingRight'
  | 'paddingX'
  | 'paddingY'
  | 'backgroundColor'
  | 'position'
  | 'top'
  | 'bottom'
  | 'left'
  | 'right'
  | 'width'
  | 'zIndex'
  | keyof DataAnalyticsAttribute
> &
  TestID &
  StyledPropsBlade;

// TopNav Subcomponents Types - These components have simple props
type TopNavBrandProps = {
  children: React.ReactNode;
};

type TopNavContentProps = {
  children: React.ReactNode;
};

type TopNavActionsProps = {
  children: React.ReactNode;
};

// TabNav Types (Used within TopNav)
type TabNavProps = {
  items: Item[];
  children: (props: {
    items: TabNavItemData[];
    overflowingItems: TabNavItemData[];
  }) => React.ReactElement;
};

type Item = TabNavItemProps & {
  description?: string;
  isAlwaysOverflowing?: boolean;
};

type TabNavItemData = Item & {
  isOverflowing?: boolean;
  tabWidth?: number;
  offsetX?: number;
};

// TabNavItem Types
type TabNavItemProps = {
  /**
   * href of the link
   */
  href?: LinkProps['href'];
  /**
   * Anchor tag `target` attribute
   */
  target?: LinkProps['target'];
  /**
   * as prop to pass ReactRouter's Link component.
   *
   * @default 'a'
   *
   * @example
   * ```
   * import { Link } from 'react-router-dom';
   *
   * <TabNavItem as={Link} />
   * ```
   */
  as?: React.ComponentType<any> | 'a' | 'button';
  /**
   * Selected state of the navigation item.
   *
   * @default false
   */
  isActive?: boolean;
  /**
   * Leading icon for TabNavItem.
   *
   * @default undefined
   */
  icon?: IconComponent;
  /**
   * Element to render after the navigation item.
   *
   * @default undefined
   */
  trailing?: React.ReactElement;
  /**
   * Title of the navigation item.
   */
  title?: string;
  /**
   * Accessibility label for the navigation item.
   */
  accessibilityLabel?: string;
} & MenuTriggerProps;

type MenuTriggerProps = {
  onMouseDown?: Platform.Select<{ web: React.MouseEventHandler; native: undefined }>;
  onPointerDown?: Platform.Select<{ web: React.PointerEventHandler; native: undefined }>;
  onKeyDown?: Platform.Select<{ web: React.KeyboardEventHandler; native: undefined }>;
  onKeyUp?: Platform.Select<{ web: React.KeyboardEventHandler; native: undefined }>;
  onClick?: Platform.Select<{ web: React.MouseEventHandler; native: undefined }>;
};
````

## Example

Below is a comprehensive example showing how to use the TopNav component with its subcomponents, including TabNav integration and responsive behavior:

```tsx
import React, { useState, useEffect } from 'react';
import { useLocation, useNavigate, Link } from 'react-router-dom';
import {
  TopNav,
  TopNavBrand,
  TopNavContent,
  TopNavActions,
  TabNav,
  TabNavItems,
  TabNavItem,
  Box,
  SearchInput,
  Button,
  Tooltip,
  Avatar,
  Text,
  Menu,
  MenuHeader,
  MenuItem,
  MenuFooter,
  MenuOverlay,
  Link as BladeLink,
  Badge,
  HomeIcon,
  SearchIcon,
  ActivityIcon,
  AnnouncementIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  AcceptPaymentsIcon,
  RazorpayxPayrollIcon,
  ShoppingBagIcon,
  AwardIcon,
} from '@razorpay/blade/components';

// Helper function to determine if a route is active
const isRouteActive = (currentPath, routePath, activeOnPaths = []) => {
  if (currentPath === routePath) return true;
  if (activeOnPaths.some((path) => currentPath.startsWith(path))) return true;
  return false;
};

// Example item format for a product in the navigation
const ExploreItem = ({ icon: Icon, title, description }) => {
  return (
    <Box display="flex" gap="spacing.4">
      <Box
        borderRadius="medium"
        padding="spacing.5"
        backgroundColor="surface.background.gray.subtle"
      >
        <Icon color="interactive.icon.neutral.subtle" size="medium" />
      </Box>
      <Box>
        <Text color="surface.text.gray.subtle" size="medium" weight="semibold">
          {title}
        </Text>
        <Text size="small" color="surface.text.gray.muted">
          {description}
        </Text>
      </Box>
    </Box>
  );
};

const AppNavigation = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const [selectedProduct, setSelectedProduct] = useState(null);
  const [isMobile, setIsMobile] = useState(window.innerWidth < 768);

  // Update selectedProduct when route changes
  useEffect(() => {
    setSelectedProduct(location.pathname);
  }, [location.pathname]);

  // Handle responsive behavior
  useEffect(() => {
    const handleResize = () => {
      setIsMobile(window.innerWidth < 768);
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Product navigation items
  const navItems = [
    {
      title: 'Home',
      href: '/home',
      icon: HomeIcon,
    },
    {
      title: 'Payroll',
      href: '/payroll',
      icon: RazorpayxPayrollIcon,
      description: 'Automate payroll with ease.',
    },
    {
      title: 'Payments',
      href: '/payments',
      icon: AcceptPaymentsIcon,
      description: 'Manage payments effortlessly.',
    },
    {
      title: 'Checkout',
      href: '/checkout',
      icon: ShoppingBagIcon,
      description: 'Fast, one-click checkout.',
    },
    {
      title: 'Growth',
      href: '/growth',
      icon: AwardIcon,
      isAlwaysOverflowing: true,
      description: 'Boost your business growth.',
    },
  ];

  return (
    <TopNav>
      {isMobile ? (
        /* Mobile View */
        <>
          <BladeLink icon={HomeIcon} size="medium" href="/home">
            Home
          </BladeLink>
          <Text size="medium" weight="semibold" textAlign="center">
            {navItems.find((item) => item.href === selectedProduct)?.title || 'Dashboard'}
          </Text>
          <Menu openInteraction="click">
            <Avatar size="medium" name="Jane Smith" />
            <MenuOverlay>
              <MenuHeader title="Profile" />
              <Box display="flex" gap="spacing.4" padding="spacing.4" alignItems="center">
                <Avatar size="medium" name="Jane Smith" />
                <Box display="flex" flexDirection="column" gap="spacing.2">
                  <Text size="medium" weight="semibold">
                    Jane Smith
                  </Text>
                  <Text size="xsmall" color="surface.text.gray.muted">
                    Business Admin
                  </Text>
                </Box>
              </Box>
              <MenuItem onClick={() => navigate('/settings')}>
                <Text color="surface.text.gray.subtle">Settings</Text>
              </MenuItem>
              <MenuItem color="negative" onClick={() => navigate('/logout')}>
                <Text color="feedback.text.negative.intense">Logout</Text>
              </MenuItem>
            </MenuOverlay>
          </Menu>
        </>
      ) : (
        /* Desktop View */
        <>
          <TopNavBrand>
            <BladeLink href="/home">Home</BladeLink>
          </TopNavBrand>

          <TopNavContent>
            <TabNav items={navItems}>
              {({ items, overflowingItems }) => {
                const activeProduct = overflowingItems.find(
                  (item) => item.href === selectedProduct,
                );

                return (
                  <>
                    <TabNavItems>
                      {items.map((item) => (
                        <TabNavItem
                          key={item.title}
                          as={Link}
                          title={item.title}
                          href={item.href}
                          icon={item.icon}
                          isActive={isRouteActive(location.pathname, item.href)}
                          accessibilityLabel={`Go to ${item.title}`}
                        />
                      ))}
                    </TabNavItems>

                    {overflowingItems.length > 0 && (
                      <Menu openInteraction="hover">
                        <TabNavItem
                          title={activeProduct ? `More: ${activeProduct.title}` : 'More'}
                          trailing={<ChevronDownIcon />}
                          isActive={Boolean(activeProduct)}
                          accessibilityLabel="View more navigation options"
                        />
                        <MenuOverlay>
                          <MenuHeader
                            title="Products for you"
                            trailing={
                              <Badge emphasis="subtle" color="notice">
                                Recommended
                              </Badge>
                            }
                          />
                          {overflowingItems.map((item) => (
                            <MenuItem
                              key={item.href}
                              onClick={() => {
                                navigate(item.href);
                                setSelectedProduct(item.href);
                              }}
                            >
                              <ExploreItem
                                icon={item.icon}
                                title={item.title}
                                description={item.description}
                              />
                            </MenuItem>
                          ))}
                          <MenuFooter>
                            <BladeLink
                              href="/products"
                              icon={ChevronRightIcon}
                              iconPosition="right"
                            >
                              View all products
                            </BladeLink>
                          </MenuFooter>
                        </MenuOverlay>
                      </Menu>
                    )}
                  </>
                );
              }}
            </TabNav>
          </TopNavContent>

          <TopNavActions>
            <SearchInput placeholder="Search..." accessibilityLabel="Search across application" />
            <Tooltip content="View system status">
              <Button
                variant="tertiary"
                icon={ActivityIcon}
                accessibilityLabel="View system status"
              />
            </Tooltip>
            <Tooltip content="View announcements">
              <Button
                variant="tertiary"
                icon={AnnouncementIcon}
                accessibilityLabel="View announcements"
              />
            </Tooltip>
            <Menu openInteraction="click">
              <Avatar size="medium" name="Jane Smith" />
              <MenuOverlay>
                <MenuHeader title="Profile" />
                <Box display="flex" gap="spacing.4" padding="spacing.4" alignItems="center">
                  <Avatar size="medium" name="Jane Smith" />
                  <Box display="flex" flexDirection="column" gap="spacing.2">
                    <Text size="medium" weight="semibold">
                      Jane Smith
                    </Text>
                    <Text size="xsmall" color="surface.text.gray.muted">
                      Business Admin
                    </Text>
                  </Box>
                </Box>
                <MenuItem onClick={() => navigate('/settings')}>
                  <Text color="surface.text.gray.subtle">Settings</Text>
                </MenuItem>
                <MenuItem color="negative" onClick={() => navigate('/logout')}>
                  <Text color="feedback.text.negative.intense">Logout</Text>
                </MenuItem>
              </MenuOverlay>
            </Menu>
          </TopNavActions>
        </>
      )}
    </TopNav>
  );
};

export default AppNavigation;
```

### Usage with React Router v6

When using TopNav with React Router, you need to handle the active state for navigation items by checking the current location against routes:

```tsx
import { useLocation, Link, TabNavItem } from 'react-router-dom';

// Inside your component
const location = useLocation();

// Check if a route is active
const isActive = (path) => {
  return location.pathname === path || location.pathname.startsWith(`${path}/`);
};

// Then use it with TabNavItem
<TabNavItem as={Link} to="/dashboard" title="Dashboard" isActive={isActive('/dashboard')} />;
```

### Responsive Design

The TopNav component adapts to different screen sizes by showing a simplified interface on mobile:

```jsx
import { useBreakpoint } from '@razorpay/blade/utils';
import { useTheme, TopNav } from '@razorpay/blade/components';

const MyTopNav = (): React.ReactElement => {
  const { theme } = useTheme();
  const { matchedDeviceType } = useBreakpoint({ breakpoints: theme.breakpoints });
  const isMobile = matchedDeviceType === 'mobile';

  return (
    <TopNav>
      {isMobile
        ? {
            /* Mobile view with essential controls */
          }
        : {
            /* Desktop view with full navigation */
          }}
    </TopNav>
  );
};

export default MyTopNav;
```

---

## VisuallyHidden

## Component Name

VisuallyHidden

## Description

The VisuallyHidden component makes content hidden from sighted users but available for screen reader users. It allows you to provide additional context for assistive technologies without visually displaying that information. This component is essential for improving accessibility in your application by providing information exclusively for screen readers.

## TypeScript Types

These are the props that the VisuallyHidden component accepts. When using the VisuallyHidden component, you'll need to provide these props to configure its behavior:

```typescript
type VisuallyHiddenProps = {
  /**
   * Content to be hidden visually but available to screen readers
   */
  children: React.ReactNode;
} & TestID;
```

## Example

### Basic Usage

This example demonstrates how to use the VisuallyHidden component to create accessible controls with hidden labels that are only available to screen readers.

```tsx
import { VisuallyHidden, Checkbox, Box, Text } from '@razorpay/blade/components';

function AccessibleCheckboxExample() {
  return (
    <Box padding="spacing.4">
      <Text marginBottom="spacing.3">
        The checkbox below has a label that is only visible to screen readers.
      </Text>

      <Box display="flex" alignItems="center" gap="spacing.3">
        <Checkbox>
          <VisuallyHidden>
            <Text>Toggle dark mode</Text>
          </VisuallyHidden>
        </Checkbox>
        <Text>Enable dark mode</Text>
      </Box>

      <Box marginTop="spacing.5">
        <Text marginBottom="spacing.3">
          This technique is useful when you want to provide additional context to screen reader
          users without cluttering the visual interface.
        </Text>
      </Box>
    </Box>
  );
}

export default AccessibleCheckboxExample;
```

---
